---
title: 新增功能
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 111430bf32debfcb80ea12aa9eb89c52f695d3cb
ms.sourcegitcommit: 65af0f0ad316858882845391d60ef7e303b756e8
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2021
ms.locfileid: "99585684"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="7d15f-102">Visual Basic 的新增功能</span><span class="sxs-lookup"><span data-stu-id="7d15f-102">What's new for Visual Basic</span></span>

<span data-ttu-id="7d15f-103">本主题列出每个 Visual Basic 版本的重要功能名以及该语言最新版本中的新功能和增强功能的详细说明。</span><span class="sxs-lookup"><span data-stu-id="7d15f-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="7d15f-104">当前版本</span><span class="sxs-lookup"><span data-stu-id="7d15f-104">Current version</span></span>

<span data-ttu-id="7d15f-105">Visual Basic 16.9/Visual Studio 2019 版本 16.9</span><span class="sxs-lookup"><span data-stu-id="7d15f-105">Visual Basic 16.9 / Visual Studio 2019 version 16.9</span></span>\
<span data-ttu-id="7d15f-106">有关新功能，请参阅 [Visual Basic 16.9](#visual-basic-169)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-106">For new features, see [Visual Basic 16.9](#visual-basic-169).</span></span>

<span data-ttu-id="7d15f-107">可以从 [.NET 下载页](https://dotnet.microsoft.com/download)下载最新 .NET SDK。</span><span class="sxs-lookup"><span data-stu-id="7d15f-107">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="7d15f-108">早期版本</span><span class="sxs-lookup"><span data-stu-id="7d15f-108">Previous versions</span></span>

<span data-ttu-id="7d15f-109">Visual Basic 16.0/Visual Studio 2019 版本 16.0</span><span class="sxs-lookup"><span data-stu-id="7d15f-109">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="7d15f-110">有关新功能，请参阅 [Visual Basic 16.0](#visual-basic-160)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-110">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

<span data-ttu-id="7d15f-111">Visual Basic 15.8/Visual Studio 2017 版本 15.8</span><span class="sxs-lookup"><span data-stu-id="7d15f-111">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="7d15f-112">有关新功能，请参阅 [Visual Basic 15.8](#visual-basic-158)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-112">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="7d15f-113">Visual Basic 15.5/Visual Studio 2017 版本 15.5</span><span class="sxs-lookup"><span data-stu-id="7d15f-113">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="7d15f-114">有关新功能，请参阅 [Visual Basic 15.5](#visual-basic-155)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-114">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="7d15f-115">Visual Basic 15.3/Visual Studio 2017 版本 15.3</span><span class="sxs-lookup"><span data-stu-id="7d15f-115">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="7d15f-116">有关新功能，请参阅 [Visual Basic 15.3](#visual-basic-153)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-116">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="7d15f-117">Visual Basic 2017/Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="7d15f-117">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="7d15f-118">有关新功能，请参阅 [Visual Basic 2017](#visual-basic-2017)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-118">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="7d15f-119">Visual Basic/Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="7d15f-119">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="7d15f-120">有关新功能，请参阅 [Visual Basic 14](#visual-basic-14)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-120">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="7d15f-121">Visual Basic/Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="7d15f-121">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="7d15f-122">.NET Compiler Platform（“Roslyn”）的技术预览</span><span class="sxs-lookup"><span data-stu-id="7d15f-122">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="7d15f-123">Visual Basic/Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="7d15f-123">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="7d15f-124">`Async` 和 `await` 关键字、迭代器、调用方信息特性</span><span class="sxs-lookup"><span data-stu-id="7d15f-124">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="7d15f-125">Visual Basic、Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="7d15f-125">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="7d15f-126">自动实现的属性、集合初始值设定项、隐式行继续符、动态、泛型协变/逆变、全局命名空间访问</span><span class="sxs-lookup"><span data-stu-id="7d15f-126">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="7d15f-127">Visual Basic/Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="7d15f-127">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="7d15f-128">语言集成查询 (LINQ)、XML 文本、本地类型推断、对象初始值设定项、匿名类型、扩展方法、本地 `var` 类型推断、lambda 表达式、`if` 运算符、分部方法、可以为 null 的值类型</span><span class="sxs-lookup"><span data-stu-id="7d15f-128">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="7d15f-129">Visual Basic/Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="7d15f-129">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="7d15f-130">`My` 类型和帮助程序类型（对应用、计算机、文件系统、网络的访问）</span><span class="sxs-lookup"><span data-stu-id="7d15f-130">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="7d15f-131">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="7d15f-131">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="7d15f-132">移位运算符、循环变量声明</span><span class="sxs-lookup"><span data-stu-id="7d15f-132">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="7d15f-133">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="7d15f-133">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="7d15f-134">Visual Basic.NET 的首次发布</span><span class="sxs-lookup"><span data-stu-id="7d15f-134">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-169"></a><span data-ttu-id="7d15f-135">Visual Basic 16.9</span><span class="sxs-lookup"><span data-stu-id="7d15f-135">Visual Basic 16.9</span></span>

<span data-ttu-id="7d15f-136">Visual Basic 16.9 允许使用仅限 init 属性。</span><span class="sxs-lookup"><span data-stu-id="7d15f-136">Visual Basic 16.9 enables consumption of init-only properties.</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="7d15f-137">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="7d15f-137">Visual Basic 16.0</span></span>

<span data-ttu-id="7d15f-138">Visual Basic 16.0 侧重于向 .NET Core 提供 Visual Basic 运行时 (microsoft.visualbasic.dll) 的更多功能，这是 Visual Basic 侧重于 .NET Core 的第一个版本。</span><span class="sxs-lookup"><span data-stu-id="7d15f-138">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="7d15f-139">Visual Basic 运行时的许多部分都依赖于 WinForms，它们将添加到 Visual Basic 的更高版本中。</span><span class="sxs-lookup"><span data-stu-id="7d15f-139">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="7d15f-140">**允许在语句中的更多位置进行注释**</span><span class="sxs-lookup"><span data-stu-id="7d15f-140">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="7d15f-141">在 Visual Basic 15.8 及更早版本中，只允许在空行上、语句末尾或在语句中允许使用隐式行继续符的特定位置进行注释。</span><span class="sxs-lookup"><span data-stu-id="7d15f-141">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="7d15f-142">从 Visual Basic 16.0 开始，还允许在显式行继续符之后以及以空格开头后跟下划线的行上的语句中进行注释。</span><span class="sxs-lookup"><span data-stu-id="7d15f-142">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="7d15f-143">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="7d15f-143">Visual Basic 15.8</span></span>

<span data-ttu-id="7d15f-144">**优化的浮点到整数转换**</span><span class="sxs-lookup"><span data-stu-id="7d15f-144">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="7d15f-145">在以前版本的 Visual Basic 中，[双精度](../language-reference/data-types/double-data-type.md)和[单精度](../language-reference/data-types/single-data-type.md)值到整数的转换的性能相对较差。</span><span class="sxs-lookup"><span data-stu-id="7d15f-145">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="7d15f-146">Visual Basic 15.8 显著增强了以下情况下的浮点到整数转换的性能：将以下任何方法返回的值传递到一个 [Visual Basic 内部整数转换函数](../language-reference/functions/type-conversion-functions.md)（CByte、CShort、CInt、CLng、CSByte、CUShort、CUInt、CULng）时，或是在 [Option Strict](../language-reference/statements/option-strict-statement.md) 设置为 `Off` 的情况下将以下任何方法返回的值隐式强制转换为整型类型时：</span><span class="sxs-lookup"><span data-stu-id="7d15f-146">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="7d15f-147">此优化使代码可以更快运行 -- 对于进行大量到整型类型的转换的代码，可快达两倍。</span><span class="sxs-lookup"><span data-stu-id="7d15f-147">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="7d15f-148">下面的示例说明了受此优化影响的一些简单方法调用：</span><span class="sxs-lookup"><span data-stu-id="7d15f-148">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="7d15f-149">请注意，这会截断而不是舍入浮点值。</span><span class="sxs-lookup"><span data-stu-id="7d15f-149">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="7d15f-150">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="7d15f-150">Visual Basic 15.5</span></span>

[<span data-ttu-id="7d15f-151">非尾随命名参数</span><span class="sxs-lookup"><span data-stu-id="7d15f-151">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="7d15f-152">在 Visual Basic 15.3 和更早版本中，当方法通过位置和名称调用包含的参数时，位置参数必须位于命名参数之前。</span><span class="sxs-lookup"><span data-stu-id="7d15f-152">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="7d15f-153">从 Visual Basic 15.5 开始，只要到最后一个位置参数的所有参数都处于正确的位置，位置参数和命名参数就可以以任何顺序出现。</span><span class="sxs-lookup"><span data-stu-id="7d15f-153">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="7d15f-154">当使用命名参数提高代码的可读性时，此方法特别有用。</span><span class="sxs-lookup"><span data-stu-id="7d15f-154">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="7d15f-155">例如，以下方法调用在命名参数之间有两个位置参数。</span><span class="sxs-lookup"><span data-stu-id="7d15f-155">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="7d15f-156">命名参数清楚地表明值 19 代表年龄。</span><span class="sxs-lookup"><span data-stu-id="7d15f-156">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="7d15f-157">`Private Protected` 成员访问修饰符</span><span class="sxs-lookup"><span data-stu-id="7d15f-157">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="7d15f-158">这个新的关键字组合定义了一个成员，该成员可以由其包含的类中的所有成员访问，也可以由从包含的类派生的类型访问，但前提是它们也可以在包含的程序集中找到。</span><span class="sxs-lookup"><span data-stu-id="7d15f-158">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="7d15f-159">由于无法继承结构，因此 `Private Protected` 仅适用于类的成员。</span><span class="sxs-lookup"><span data-stu-id="7d15f-159">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="7d15f-160">**前导十六进制/二进制/八进制分隔符**</span><span class="sxs-lookup"><span data-stu-id="7d15f-160">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="7d15f-161">Visual Basic 2017 新增支持下划线字符 (`_`) 作为数字分隔符。</span><span class="sxs-lookup"><span data-stu-id="7d15f-161">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="7d15f-162">从 Visual Basic 15.5 开始，可以使用下划线字符作为前缀和十六进制、二进制或八进制数字之间的前导分隔符。</span><span class="sxs-lookup"><span data-stu-id="7d15f-162">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="7d15f-163">以下示例使用前导数字分隔符将 3,271,948,384 定义为十六进制数字：</span><span class="sxs-lookup"><span data-stu-id="7d15f-163">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="7d15f-164">若要使用下划线字符作为前导分隔符，必须将以下元素添加到 Visual Basic 项目 (\*.vbproj) 文件中：</span><span class="sxs-lookup"><span data-stu-id="7d15f-164">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="7d15f-165">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="7d15f-165">Visual Basic 15.3</span></span>

[<span data-ttu-id="7d15f-166">**命名元组推理**</span><span class="sxs-lookup"><span data-stu-id="7d15f-166">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="7d15f-167">从变量分配元组元素的值时，Visual Basic 会从相应的变量名推断元组元素名；因此无需显式命名元组元素。</span><span class="sxs-lookup"><span data-stu-id="7d15f-167">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="7d15f-168">以下示例使用推理创建元组，其中包含三个命名元素`state`、`stateName` 和 `capital`。</span><span class="sxs-lookup"><span data-stu-id="7d15f-168">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="7d15f-169">**其他编译器开关**</span><span class="sxs-lookup"><span data-stu-id="7d15f-169">**Additional compiler switches**</span></span>

<span data-ttu-id="7d15f-170">Visual Basic 命令行编译器现在支持 [-refout](../reference/command-line-compiler/refout-compiler-option.md) 和 [-refonly](../reference/command-line-compiler/refonly-compiler-option.md) 编译器选项，可控制引用程序集的输出 。</span><span class="sxs-lookup"><span data-stu-id="7d15f-170">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="7d15f-171">-refout 定义引用程序集的输出目录，-refonly 指定只通过编译输出一个引用程序集 。</span><span class="sxs-lookup"><span data-stu-id="7d15f-171">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="7d15f-172">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="7d15f-172">Visual Basic 2017</span></span>

[<span data-ttu-id="7d15f-173">**元祖**</span><span class="sxs-lookup"><span data-stu-id="7d15f-173">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="7d15f-174">元组是一种轻量级数据结构，通常用于从单个方法调用返回多个值。</span><span class="sxs-lookup"><span data-stu-id="7d15f-174">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="7d15f-175">一般情况下，若要从方法返回多个值，必须执行以下操作之一：</span><span class="sxs-lookup"><span data-stu-id="7d15f-175">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="7d15f-176">定义自定义类型（`Class` 或 `Structure`）。</span><span class="sxs-lookup"><span data-stu-id="7d15f-176">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="7d15f-177">这是重量级解决方案。</span><span class="sxs-lookup"><span data-stu-id="7d15f-177">This is a heavyweight solution.</span></span>

- <span data-ttu-id="7d15f-178">定义一个或多个 `ByRef` 参数，以及从方法返回一个值。</span><span class="sxs-lookup"><span data-stu-id="7d15f-178">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="7d15f-179">通过 Visual Basic 对元组的支持，可快速定义元组、为其值分配语义名称（可选），并快速检索其值。</span><span class="sxs-lookup"><span data-stu-id="7d15f-179">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="7d15f-180">以下示例包装对 <xref:System.Int32.TryParse%2A> 方法的调用，并返回一个元组。</span><span class="sxs-lookup"><span data-stu-id="7d15f-180">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="7d15f-181">然后，可以调用该方法并使用如下所示的代码处理返回的元组。</span><span class="sxs-lookup"><span data-stu-id="7d15f-181">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="7d15f-182">**二进制文本和数字分隔符**</span><span class="sxs-lookup"><span data-stu-id="7d15f-182">**Binary literals and digit separators**</span></span>

<span data-ttu-id="7d15f-183">可通过使用前缀 `&B` 或 `&b` 定义二进制文本。</span><span class="sxs-lookup"><span data-stu-id="7d15f-183">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="7d15f-184">此外，可以将下划线字符 `_` 用作数字分隔符，以增强可读性。</span><span class="sxs-lookup"><span data-stu-id="7d15f-184">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="7d15f-185">以下示例使用这两项功能分配 `Byte` 值，并将其显示为十进制、十六进制和二进制数字。</span><span class="sxs-lookup"><span data-stu-id="7d15f-185">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="7d15f-186">有关详细信息，请参阅 [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments)、[Integer](../language-reference/data-types/integer-data-type.md#literal-assignments)、[Long](../language-reference/data-types/long-data-type.md#literal-assignments)、[Short](../language-reference/data-types/short-data-type.md#literal-assignments)、[SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments)、[UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments)、[ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) 和 [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) 数据类型的“文本分配”部分。</span><span class="sxs-lookup"><span data-stu-id="7d15f-186">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="7d15f-187">支持 C# 引用返回值</span><span class="sxs-lookup"><span data-stu-id="7d15f-187">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="7d15f-188">从 C# 7.0 开始，C# 支持引用返回值。</span><span class="sxs-lookup"><span data-stu-id="7d15f-188">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="7d15f-189">也就是说，当调用方法收到引用返回的值时，可以更改引用的值。</span><span class="sxs-lookup"><span data-stu-id="7d15f-189">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="7d15f-190">Visual Basic 不允许使用引用返回值创建方法，但允许使用和修改引用返回值。</span><span class="sxs-lookup"><span data-stu-id="7d15f-190">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="7d15f-191">例如，用 C# 编写的以下 `Sentence` 类包括 `FindNext` 方法，该方法查找句子中以指定的子字符串开头的下一个单词。</span><span class="sxs-lookup"><span data-stu-id="7d15f-191">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="7d15f-192">该字符串作为引用返回值返回，方法引用传递的 `Boolean` 变量指示搜索是否成功。</span><span class="sxs-lookup"><span data-stu-id="7d15f-192">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="7d15f-193">这意味着，除了读取返回值外，调用方还可以对其进行修改，并且该修改会反映在 `Sentence` 类中。</span><span class="sxs-lookup"><span data-stu-id="7d15f-193">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="7d15f-194">在最简单的形式中，可以使用如下所示的代码修改句子中找到的单词。</span><span class="sxs-lookup"><span data-stu-id="7d15f-194">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="7d15f-195">请注意，不是将值分配到方法，而是将值分配到方法返回的表达式（即引用返回值）。</span><span class="sxs-lookup"><span data-stu-id="7d15f-195">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="7d15f-196">但是，此代码的问题是，如果找不到匹配项，方法将返回第一个单词。</span><span class="sxs-lookup"><span data-stu-id="7d15f-196">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="7d15f-197">由于该示例不检查 `Boolean` 参数的值以确定是否找到匹配项，所以如果没有匹配项，则修改第一个单词。</span><span class="sxs-lookup"><span data-stu-id="7d15f-197">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="7d15f-198">以下示例对此进行了更正：如果没有匹配项，则将第一个单词替换为自身。</span><span class="sxs-lookup"><span data-stu-id="7d15f-198">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="7d15f-199">更好的解决方案是使用引用将引用返回值传递到的帮助程序方法。</span><span class="sxs-lookup"><span data-stu-id="7d15f-199">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="7d15f-200">然后，帮助程序方法可以修改引用传递给其的参数。</span><span class="sxs-lookup"><span data-stu-id="7d15f-200">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="7d15f-201">以下示例执行该操作。</span><span class="sxs-lookup"><span data-stu-id="7d15f-201">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="7d15f-202">有关详细信息，请参阅[引用返回值](../programming-guide/language-features/procedures/ref-return-values.md)。</span><span class="sxs-lookup"><span data-stu-id="7d15f-202">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="7d15f-203">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="7d15f-203">Visual Basic 14</span></span>

[<span data-ttu-id="7d15f-204">NameOf</span><span class="sxs-lookup"><span data-stu-id="7d15f-204">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="7d15f-205">可以在错误消息中使用类型或成员的非限定字符串名，而无需对字符串进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="7d15f-205">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="7d15f-206">这使代码可以在重构时保持正确。</span><span class="sxs-lookup"><span data-stu-id="7d15f-206">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="7d15f-207">此功能也可用于挂接“模型-视图-控制器”MVC 链接并触发属性更改事件。</span><span class="sxs-lookup"><span data-stu-id="7d15f-207">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="7d15f-208">字符串内插</span><span class="sxs-lookup"><span data-stu-id="7d15f-208">String interpolation</span></span>](../programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="7d15f-209">可以使用字符串内插表达式构造字符串。</span><span class="sxs-lookup"><span data-stu-id="7d15f-209">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="7d15f-210">内插字符串表达式类似于包含表达式的模板字符串。</span><span class="sxs-lookup"><span data-stu-id="7d15f-210">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="7d15f-211">与[复合格式设置](../../standard/base-types/composite-formatting.md)相比，内插字符串在自变量方面更易于理解。</span><span class="sxs-lookup"><span data-stu-id="7d15f-211">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="7d15f-212">NULL 条件成员访问和索引</span><span class="sxs-lookup"><span data-stu-id="7d15f-212">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="7d15f-213">可以在执行成员访问 (`?.`) 或索引 (`?[]`) 操作之前以非常轻量的语法方式测试是否存在 null。</span><span class="sxs-lookup"><span data-stu-id="7d15f-213">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="7d15f-214">这些运算符可帮助编写更少的代码来处理 null 检查，尤其是对于下降到数据结构。</span><span class="sxs-lookup"><span data-stu-id="7d15f-214">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="7d15f-215">如果左操作数或对象引用为 null，则操作会返回 null。</span><span class="sxs-lookup"><span data-stu-id="7d15f-215">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="7d15f-216">多行字符串文本</span><span class="sxs-lookup"><span data-stu-id="7d15f-216">Multi-line string literals</span></span>](../programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="7d15f-217">字符串可以包含换行符序列。</span><span class="sxs-lookup"><span data-stu-id="7d15f-217">String literals can contain newline sequences.</span></span>  <span data-ttu-id="7d15f-218">不再需要使用 `<xml><![CDATA[...text with newlines...]]></xml>.Value` 这种旧的解决方法</span><span class="sxs-lookup"><span data-stu-id="7d15f-218">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="7d15f-219">**注释**</span><span class="sxs-lookup"><span data-stu-id="7d15f-219">**Comments**</span></span>

<span data-ttu-id="7d15f-220">可以在隐式行继续符之后、初始值设定项表达式内部以及 LINQ 表达式项之间放置注释。</span><span class="sxs-lookup"><span data-stu-id="7d15f-220">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="7d15f-221">**更智能的完全限定名称解析**</span><span class="sxs-lookup"><span data-stu-id="7d15f-221">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="7d15f-222">如果提供了 `Threading.Thread.Sleep(1000)` 这类代码，Visual Basic 过去会查找命名空间“Threading”，发现它在 System.Threading 与 System.Windows.Threading 混淆，然后报告错误。</span><span class="sxs-lookup"><span data-stu-id="7d15f-222">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="7d15f-223">Visual Basic 现在将这两个可能的命名空间结合在一起进行考虑。</span><span class="sxs-lookup"><span data-stu-id="7d15f-223">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="7d15f-224">如果显示完成列表，则 Visual Studio 编辑器会在完成列表中列出这两种类型中的成员。</span><span class="sxs-lookup"><span data-stu-id="7d15f-224">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="7d15f-225">**以年份开头的日期文本**</span><span class="sxs-lookup"><span data-stu-id="7d15f-225">**Year-first date literals**</span></span>

<span data-ttu-id="7d15f-226">可以使用 yyyy-mm-dd 格式的日期文本 `#2015-03-17 16:10 PM#`。</span><span class="sxs-lookup"><span data-stu-id="7d15f-226">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="7d15f-227">**只读接口属性**</span><span class="sxs-lookup"><span data-stu-id="7d15f-227">**Readonly interface properties**</span></span>

<span data-ttu-id="7d15f-228">可以使用读写属性实现只读接口属性。</span><span class="sxs-lookup"><span data-stu-id="7d15f-228">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="7d15f-229">该接口可保证最小功能，不会阻止实现类允许设置属性。</span><span class="sxs-lookup"><span data-stu-id="7d15f-229">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="7d15f-230">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="7d15f-230">TypeOf \<expr> IsNot \<type></span></span>](../language-reference/operators/typeof-operator.md)

<span data-ttu-id="7d15f-231">为提高代码的可读性，现在可以将 `TypeOf` 与 `IsNot` 一起使用。</span><span class="sxs-lookup"><span data-stu-id="7d15f-231">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="7d15f-232">#Disable Warning \<ID> 和 #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="7d15f-232">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../language-reference/directives/index.md)

<span data-ttu-id="7d15f-233">可以对源文件中的区域禁用和启用特定警告。</span><span class="sxs-lookup"><span data-stu-id="7d15f-233">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="7d15f-234">**XML 文档注释改进**</span><span class="sxs-lookup"><span data-stu-id="7d15f-234">**XML doc comment improvements**</span></span>

<span data-ttu-id="7d15f-235">编写文档注释时，可获取智能编辑器和生成支持，以用于验证参数名、正确处理 `crefs`（泛型、运算符等）、着色和重构。</span><span class="sxs-lookup"><span data-stu-id="7d15f-235">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="7d15f-236">部分模块和接口定义</span><span class="sxs-lookup"><span data-stu-id="7d15f-236">Partial module and interface definitions</span></span>](../language-reference/modifiers/partial.md)

<span data-ttu-id="7d15f-237">除了类和结构之外，还可以声明部分模块和接口。</span><span class="sxs-lookup"><span data-stu-id="7d15f-237">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="7d15f-238">方法体中的 #Region 指令</span><span class="sxs-lookup"><span data-stu-id="7d15f-238">#Region directives inside method bodies</span></span>](../language-reference/directives/region-directive.md)

<span data-ttu-id="7d15f-239">可以将 #Region…#End Region 限定符放置在文件中、函数内部甚至是跨越函数体的任何位置。</span><span class="sxs-lookup"><span data-stu-id="7d15f-239">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="7d15f-240">替代定义是隐式重载</span><span class="sxs-lookup"><span data-stu-id="7d15f-240">Overrides definitions are implicitly overloads</span></span>](../language-reference/modifiers/overrides.md)

<span data-ttu-id="7d15f-241">如果你向定义添加 `Overrides` 修饰符，则编译器会隐式添加 `Overloads`，以便你可以在常见情况下输入更少的代码。</span><span class="sxs-lookup"><span data-stu-id="7d15f-241">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="7d15f-242">**属性参数中允许使用 CObj**</span><span class="sxs-lookup"><span data-stu-id="7d15f-242">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="7d15f-243">当 CObj(...) 在特性构造中使用时，编译器过去会发出错误，指出它不是常量。</span><span class="sxs-lookup"><span data-stu-id="7d15f-243">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="7d15f-244">**从不同接口声明和使用不明确的方法**</span><span class="sxs-lookup"><span data-stu-id="7d15f-244">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="7d15f-245">以下代码以前会生成错误，从而阻止你声明 `IMock` 或调用 `GetDetails`（如果这些内容已在 C# 中声明）：</span><span class="sxs-lookup"><span data-stu-id="7d15f-245">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="7d15f-246">现在，编译器会使用正常的重载决策规则来选择最合适的 `GetDetails` 进行调用，你可以在 Visual Basic 中声明接口关系（如示例中所示的这些关系）。</span><span class="sxs-lookup"><span data-stu-id="7d15f-246">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="7d15f-247">请参阅</span><span class="sxs-lookup"><span data-stu-id="7d15f-247">See also</span></span>

- [<span data-ttu-id="7d15f-248">Visual Studio 2017 中的新增功能</span><span class="sxs-lookup"><span data-stu-id="7d15f-248">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="7d15f-249">Visual Studio 2019 中的新增功能</span><span class="sxs-lookup"><span data-stu-id="7d15f-249">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
