---
title: 使用规则（代码分析）
description: 了解代码分析使用规则。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: b05edde3c6faef39aa724dd49d159abe23d049f5
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "102102966"
---
# <a name="usage-rules"></a><span data-ttu-id="1e2d8-103">用法规则</span><span class="sxs-lookup"><span data-stu-id="1e2d8-103">Usage rules</span></span>

<span data-ttu-id="1e2d8-104">使用规则支持 .NET 的正确用法。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="1e2d8-105">在本节中</span><span class="sxs-lookup"><span data-stu-id="1e2d8-105">In this section</span></span>

|<span data-ttu-id="1e2d8-106">规则</span><span class="sxs-lookup"><span data-stu-id="1e2d8-106">Rule</span></span>|<span data-ttu-id="1e2d8-107">描述</span><span class="sxs-lookup"><span data-stu-id="1e2d8-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="1e2d8-108">CA1801:检查未使用的参数</span><span class="sxs-lookup"><span data-stu-id="1e2d8-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="1e2d8-109">方法签名包含一个没有在方法体中使用的参数。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="1e2d8-110">CA1816:正确调用 GC.SuppressFinalize</span><span class="sxs-lookup"><span data-stu-id="1e2d8-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="1e2d8-111">表示 Dispose 实现的方法不调用 `GC.SuppressFinalize`；或表示不是 `Dispose` 实现的方法调用 `GC.SuppressFinalize`；或方法调用 `GC.SuppressFinalize` 并传递除 `this`（Visual Basic 中的 `Me`）以外的其他内容。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="1e2d8-112">CA2200:再次引发以保留堆栈详细信息</span><span class="sxs-lookup"><span data-stu-id="1e2d8-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="1e2d8-113">再次引发某个异常，在 throw 语句中显式指定了该异常。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="1e2d8-114">如果通过在 throw 语句中指定异常来重新引发该异常，则引发该异常的原始方法与当前方法之间的方法调用的列表将丢失。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="1e2d8-115">CA2201:不要引发保留的异常类型</span><span class="sxs-lookup"><span data-stu-id="1e2d8-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="1e2d8-116">这使得很难检测和调试原始错误。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="1e2d8-117">CA2207:以内联方式初始化值类型的静态字段</span><span class="sxs-lookup"><span data-stu-id="1e2d8-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="1e2d8-118">某值类型声明了显式静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="1e2d8-119">要修复与该规则的冲突，请在声明它时初始化所有静态数据并移除静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="1e2d8-120">CA2208:正确实例化参数异常</span><span class="sxs-lookup"><span data-stu-id="1e2d8-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="1e2d8-121">调用了异常类型 ArgumentException 或其派生类型的默认（无参数）构造函数，或者向异常类型 ArgumentException 或其派生类型的参数化构造函数传递了错误的字符串参数。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="1e2d8-122">CA2211:非常量字段不应是可见的</span><span class="sxs-lookup"><span data-stu-id="1e2d8-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="1e2d8-123">不是常数也不是只读的静态字段不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="1e2d8-124">必须谨慎控制对这类字段的访问，并需要使用高级编程技术来实现对类对象的同步访问。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="1e2d8-125">CA2213:应释放可释放的字段</span><span class="sxs-lookup"><span data-stu-id="1e2d8-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="1e2d8-126">实现 <xref:System.IDisposable?displayProperty=fullName> 的类型声明具有同样实现 `IDisposable` 的类型的字段。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="1e2d8-127">字段的 `Dispose` 方法不由声明类型的 `Dispose` 方法调用。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="1e2d8-128">CA2214:不要在构造函数中调用可重写的方法</span><span class="sxs-lookup"><span data-stu-id="1e2d8-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="1e2d8-129">构造函数调用虚拟方法时，可能尚未执行调用该方法的实例的构造函数。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="1e2d8-130">CA2215:Dispose 方法应调用基类释放</span><span class="sxs-lookup"><span data-stu-id="1e2d8-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="1e2d8-131">如果某个类型继承自一个可释放类型，则该类型必须从其自身的 `Dispose` 方法内调用基类型的 `Dispose` 方法。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="1e2d8-132">CA2216:可释放类型应声明终结器</span><span class="sxs-lookup"><span data-stu-id="1e2d8-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="1e2d8-133">实现 <xref:System.IDisposable?displayProperty=fullName> 并包含建议使用非托管资源的字段的类型未实现 `Object.Finalize` 所描述的终结器。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="1e2d8-134">CA2217:不要使用 FlagsAttribute 标记枚举</span><span class="sxs-lookup"><span data-stu-id="1e2d8-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="1e2d8-135">外部可见的枚举通过 `FlagsAttribute` 进行标记，并且它包含的一个或多个值不是 2 的幂或枚举上定义的其他值的组合。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="1e2d8-136">CA2218:重写 Equals 时重写 GetHashCode</span><span class="sxs-lookup"><span data-stu-id="1e2d8-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="1e2d8-137">公共类型重写 <xref:System.Object.Equals%2A?displayProperty=fullName>，但不重写 <xref:System.Object.GetHashCode%2A?displayProperty=fullName>。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="1e2d8-138">CA2219:在异常子句中不引发异常</span><span class="sxs-lookup"><span data-stu-id="1e2d8-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="1e2d8-139">如果在 finally 或 fault 子句中引发异常，新异常将隐藏活动异常。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="1e2d8-140">当在 filter 子句中引发异常时，运行时会在不提示的情况下捕捉异常。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="1e2d8-141">这使得很难检测和调试原始错误。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="1e2d8-142">CA2224:重载相等运算符时重写 Equals 方法</span><span class="sxs-lookup"><span data-stu-id="1e2d8-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="1e2d8-143">公共类型会实现相等运算符，但不重写 <xref:System.Object.Equals%2A?displayProperty=fullName>。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="1e2d8-144">CA2225:运算符重载具有命名的备用项</span><span class="sxs-lookup"><span data-stu-id="1e2d8-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="1e2d8-145">检测到运算符重载，但未找到预期的指定备用方法。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="1e2d8-146">命名的备用成员提供对与运算符相同的功能的访问，并且可供以不支持重载运算符的语言进行编程的开发人员使用。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="1e2d8-147">CA2226:运算符应有对称重载</span><span class="sxs-lookup"><span data-stu-id="1e2d8-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="1e2d8-148">类型实现相等运算符或不相等运算符，但不实现相反运算符。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="1e2d8-149">CA2227:集合属性应为只读</span><span class="sxs-lookup"><span data-stu-id="1e2d8-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="1e2d8-150">使用可写的集合属性，用户可以将该集合替换为不同的集合。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="1e2d8-151">只读属性禁止替换该集合，但仍允许设置单个成员。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="1e2d8-152">CA2229:实现序列化构造函数</span><span class="sxs-lookup"><span data-stu-id="1e2d8-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="1e2d8-153">要修复与该规则的冲突，请实现序列化构造函数。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="1e2d8-154">对于密封类，请使构造函数成为私有；否则，请使构造函数成为受保护。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="1e2d8-155">CA2231:重写 ValueType.Equals 时应重载相等运算符</span><span class="sxs-lookup"><span data-stu-id="1e2d8-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="1e2d8-156">值类型重写 `Object.Equals`，但不实现相等运算符。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="1e2d8-157">CA2234:传递 System.Uri 对象，而不传递字符串</span><span class="sxs-lookup"><span data-stu-id="1e2d8-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="1e2d8-158">调用了带有一个字符串参数的方法，该参数的名称中包含“uri”、“URI”、“urn”、“URN”、“url”或“URL”。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="1e2d8-159">此方法的声明类型包含具有 <xref:System.Uri?displayProperty=fullName> 参数的对应方法重载。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="1e2d8-160">CA2235:标记所有不可序列化的字段</span><span class="sxs-lookup"><span data-stu-id="1e2d8-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="1e2d8-161">在可以序列化的类型中声明了类型不可序列化的实例字段。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="1e2d8-162">CA2237:用 SerializableAttribute 标记 ISerializable 类型</span><span class="sxs-lookup"><span data-stu-id="1e2d8-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="1e2d8-163">若要被公共语言运行时识别为可序列化，类型必须用 SerializableAttribute 特性标记，即使该类型通过实现 `ISerializable` 接口使用了自定义的序列化例程也是如此。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="1e2d8-164">CA2241:为格式化方法提供正确的参数</span><span class="sxs-lookup"><span data-stu-id="1e2d8-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="1e2d8-165">传递到 <xref:System.String.Format%2A?displayProperty=nameWithType> 的 format 实参不包含对应于每个对象实参的格式项，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="1e2d8-166">CA2242:正确测试 NaN</span><span class="sxs-lookup"><span data-stu-id="1e2d8-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="1e2d8-167">此表达式针对 `Single.Nan` 或 `Double.Nan` 测试值。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="1e2d8-168">使用 `Single.IsNan(Single)` 或 `Double.IsNan(Double)` 测试值。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="1e2d8-169">CA2243:特性字符串文本应正确分析</span><span class="sxs-lookup"><span data-stu-id="1e2d8-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="1e2d8-170">特性的字符串文本形参不能正确解析为 URL、GUID 或版本。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="1e2d8-171">CA2244:不要复制已索引的元素初始值设定项</span><span class="sxs-lookup"><span data-stu-id="1e2d8-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="1e2d8-172">对象初始值设定项有多个具有相同常量索引的索引元素初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="1e2d8-173">除最后一个初始值设定项之外，其余都是冗余的。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="1e2d8-174">CA2245:请勿将属性分配给其自身</span><span class="sxs-lookup"><span data-stu-id="1e2d8-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="1e2d8-175">属性意外赋值给了其自身。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="1e2d8-176">CA2246:请勿在同一语句中分配符号及其成员</span><span class="sxs-lookup"><span data-stu-id="1e2d8-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="1e2d8-177">不建议在同一语句中分配符号及其成员（即字段或属性）。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="1e2d8-178">目前尚不清楚成员访问是打算在赋值之前使用符号的旧值还是打算使用此语句中赋值的新值。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="1e2d8-179">CA2247:传递给 TaskCompletionSource 构造函数的参数应为 TaskCreationOptions 枚举，而不是 TaskContinuationOptions 枚举</span><span class="sxs-lookup"><span data-stu-id="1e2d8-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2247.md)|<span data-ttu-id="1e2d8-180">TaskCompletionSource 既有采用控制基础任务的 TaskCreationOptions 的构造函数，也有采用任务中存储的对象状态的构造函数。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="1e2d8-181">如果意外传递 TaskContinuationOptions 而不是 TaskCreationOptions，则将导致调用将选项视为状态。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="1e2d8-182">CA2248：向 Enum.HasFlag 提供正确的 enum 实参</span><span class="sxs-lookup"><span data-stu-id="1e2d8-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="1e2d8-183">作为实参传递给 `HasFlag` 方法调用的枚举类型不同于调用枚举类型。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="1e2d8-184">CA2249：请考虑使用 String.Contains 而不是 String.IndexOf</span><span class="sxs-lookup"><span data-stu-id="1e2d8-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="1e2d8-185">对 `string.IndexOf` 的调用（其结果用于检查是否存在子字符串）可以用 `string.Contains` 替换。</span><span class="sxs-lookup"><span data-stu-id="1e2d8-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
