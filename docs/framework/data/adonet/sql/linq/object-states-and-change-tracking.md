---
description: 了解有关：对象状态和 Change-Tracking 的详细信息
title: 对象状态和更改跟踪
ms.date: 03/30/2017
ms.assetid: 7a808b00-9c3c-479a-aa94-717280fefd71
ms.openlocfilehash: 5f3aa6197fa44d8b5ea9333c85255202cbfe519b
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99695497"
---
# <a name="object-states-and-change-tracking"></a><span data-ttu-id="b5ed6-103">对象状态和更改跟踪</span><span class="sxs-lookup"><span data-stu-id="b5ed6-103">Object States and Change-Tracking</span></span>

[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="b5ed6-104">对象始终参与某种 *状态*。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-104">objects always participate in some *state*.</span></span> <span data-ttu-id="b5ed6-105">例如，当 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 创建一个新对象时，该对象就处于 `Unchanged` 状态。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-105">For example, when [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] creates a new object, the object is in `Unchanged` state.</span></span> <span data-ttu-id="b5ed6-106">您自己创建的新对象对于 <xref:System.Data.Linq.DataContext> 而言是未知的，因而处于 `Untracked` 状态。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-106">A new object that you yourself create is unknown to the <xref:System.Data.Linq.DataContext> and is in `Untracked` state.</span></span> <span data-ttu-id="b5ed6-107">在成功执行 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 后，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 已知的所有对象均处于 `Unchanged` 状态。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-107">Following successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, all objects known to [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] are in `Unchanged` state.</span></span> <span data-ttu-id="b5ed6-108">（唯一的例外是已从数据库中成功删除的那些对象，它们处于 `Deleted` 状态，并且在该 <xref:System.Data.Linq.DataContext> 实例中无法使用。）</span><span class="sxs-lookup"><span data-stu-id="b5ed6-108">(The single exception is represented by those that have been successfully deleted from the database, which are in `Deleted` state and unusable in that <xref:System.Data.Linq.DataContext> instance.)</span></span>

## <a name="object-states"></a><span data-ttu-id="b5ed6-109">对象状态</span><span class="sxs-lookup"><span data-stu-id="b5ed6-109">Object States</span></span>

<span data-ttu-id="b5ed6-110">下表列出了 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 对象可能的状态。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-110">The following table lists the possible states for [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] objects.</span></span>

|<span data-ttu-id="b5ed6-111">状态</span><span class="sxs-lookup"><span data-stu-id="b5ed6-111">State</span></span>|<span data-ttu-id="b5ed6-112">说明</span><span class="sxs-lookup"><span data-stu-id="b5ed6-112">Description</span></span>|
|-----------|-----------------|
|`Untracked`|<span data-ttu-id="b5ed6-113">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 未跟踪的对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-113">An object not tracked by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span> <span data-ttu-id="b5ed6-114">这方面的例子有：</span><span class="sxs-lookup"><span data-stu-id="b5ed6-114">Examples include the following:</span></span><br /><br /> <span data-ttu-id="b5ed6-115">-不通过当前 <xref:System.Data.Linq.DataContext> (（如新创建的对象) ）进行查询的对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-115">-   An object not queried through the current <xref:System.Data.Linq.DataContext> (such as a newly created object).</span></span><br /><span data-ttu-id="b5ed6-116">-通过反序列化创建的对象</span><span class="sxs-lookup"><span data-stu-id="b5ed6-116">-   An object created through deserialization</span></span><br /><span data-ttu-id="b5ed6-117">-通过不同的查询的对象 <xref:System.Data.Linq.DataContext> 。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-117">-   An object queried through a different <xref:System.Data.Linq.DataContext>.</span></span>|
|`Unchanged`|<span data-ttu-id="b5ed6-118">通过使用当前 <xref:System.Data.Linq.DataContext> 检索到的对象，并且尚未获知此对象自创建以来已被修改。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-118">An object retrieved by using the current <xref:System.Data.Linq.DataContext> and not known to have been modified since it was created.</span></span>|
|`PossiblyModified`|<span data-ttu-id="b5ed6-119">*附加* 到的对象 <xref:System.Data.Linq.DataContext> 。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-119">An object which is *attached* to a <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="b5ed6-120">有关详细信息，请参阅 [N 层应用程序中的数据检索和 CUD 操作 (LINQ to SQL) ](data-retrieval-and-cud-operations-in-n-tier-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-120">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>|
|`ToBeInserted`|<span data-ttu-id="b5ed6-121">使用当前 <xref:System.Data.Linq.DataContext> 未检索到的对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-121">An object not retrieved by using the current <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="b5ed6-122">这会导致在 `INSERT` 期间执行数据库 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 操作。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-122">This causes a database `INSERT` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|
|`ToBeUpdated`|<span data-ttu-id="b5ed6-123">符合如下条件的对象：已获知自检索到该对象以来它已被修改。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-123">An object known to have been modified since it was retrieved.</span></span> <span data-ttu-id="b5ed6-124">这会导致在 `UPDATE` 期间执行数据库 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 操作。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-124">This causes a database `UPDATE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|
|`ToBeDeleted`|<span data-ttu-id="b5ed6-125">标记为删除，从而导致在 `DELETE` 期间执行数据库 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 操作的对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-125">An object marked for deletion, causing a database `DELETE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|
|`Deleted`|<span data-ttu-id="b5ed6-126">已从数据库中删除的对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-126">An object that has been deleted in the database.</span></span> <span data-ttu-id="b5ed6-127">此状态为最终状态，不允许再进行其他转换。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-127">This state is final and does not allow for additional transitions.</span></span>|

## <a name="inserting-objects"></a><span data-ttu-id="b5ed6-128">插入对象</span><span class="sxs-lookup"><span data-stu-id="b5ed6-128">Inserting Objects</span></span>

<span data-ttu-id="b5ed6-129">您可以通过使用 `Inserts` 显式请求 <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-129">You can explicitly request `Inserts` by using <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.</span></span> <span data-ttu-id="b5ed6-130">此外，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 还可以通过查找与必须更新的已知对象之一相连接的对象来推断 `Inserts`。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-130">Alternatively, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] can infer `Inserts` by finding objects connected to one of the known objects that must be updated.</span></span> <span data-ttu-id="b5ed6-131">例如，如果将 `Untracked` 对象添加到 <xref:System.Data.Linq.EntitySet%601> 或将 <xref:System.Data.Linq.EntityRef%601> 设置为 `Untracked` 对象，则可以通过关系图中的被跟踪对象使 `Untracked` 对象可访问。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-131">For example, if you add an `Untracked` object to an <xref:System.Data.Linq.EntitySet%601> or set an <xref:System.Data.Linq.EntityRef%601> to an `Untracked` object, you make the `Untracked` object reachable by way of tracked objects in the graph.</span></span> <span data-ttu-id="b5ed6-132">在处理 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 时，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 遍历被跟踪的对象，并查找未被跟踪的任何可访问的持久性对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-132">While processing <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] traverses the tracked objects and discovers any reachable persistent objects that are not tracked.</span></span> <span data-ttu-id="b5ed6-133">此类对象是要插入到数据库中的候选对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-133">Such objects are candidates for insertion into the database.</span></span>

<span data-ttu-id="b5ed6-134">对于继承层次结构中的类， <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> (`o`) 还会将指定为 *鉴别* 器的成员的值设置为与对象的类型匹配 `o` 。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-134">For classes in an inheritance hierarchy, <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>(`o`) also sets the value of the member designated as the *discriminator* to match the type of the object `o`.</span></span> <span data-ttu-id="b5ed6-135">对于与默认鉴别器值匹配的类型，此操作会导致鉴别器值被默认值覆盖。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-135">In the case of a type matching the default discriminator value, this action causes the discriminator value to be overwritten with the default value.</span></span> <span data-ttu-id="b5ed6-136">有关详细信息，请参阅 [继承支持](inheritance-support.md)。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-136">For more information, see [Inheritance Support](inheritance-support.md).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b5ed6-137">添加到 `Table` 的对象不在标识缓存中。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-137">An object added to a `Table` is not in the identity cache.</span></span> <span data-ttu-id="b5ed6-138">标识缓存仅反映从数据库中检索到的内容。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-138">The identity cache reflects only what is retrieved from the database.</span></span> <span data-ttu-id="b5ed6-139">调用 <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> 后，直到 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 成功完成，所添加的实体才会出现在对数据库的查询中。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-139">After a call to <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>, the added entity does not appear in queries against the database until <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is successfully completed.</span></span>

## <a name="deleting-objects"></a><span data-ttu-id="b5ed6-140">删除对象</span><span class="sxs-lookup"><span data-stu-id="b5ed6-140">Deleting Objects</span></span>

<span data-ttu-id="b5ed6-141">通过对相应的 `o` 调用 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o)，可以将被跟踪的对象 <xref:System.Data.Linq.Table%601> 标记为删除。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-141">You mark a tracked object `o` for deletion by calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o) on the appropriate <xref:System.Data.Linq.Table%601>.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="b5ed6-142">将从 <xref:System.Data.Linq.EntitySet%601> 中移除对象视为更新操作，并且将对应的外键值设置为 null。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-142">considers the removal of an object from an <xref:System.Data.Linq.EntitySet%601> as an update operation, and the corresponding foreign key value is set to null.</span></span> <span data-ttu-id="b5ed6-143">不会将操作的目标 (`o`) 从其所在表中删除。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-143">The target of the operation (`o`) is not deleted from its table.</span></span> <span data-ttu-id="b5ed6-144">例如，当通过将外键 `cust.Orders.DeleteOnSubmit(ord)` 设置为 null 切断 `cust` 与 `ord` 之间的关系时，`ord.CustomerID` 指示更新操作。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-144">For example, `cust.Orders.DeleteOnSubmit(ord)` indicates an update where the relationship between `cust` and `ord` is severed by setting the foreign key `ord.CustomerID` to null.</span></span> <span data-ttu-id="b5ed6-145">它不会导致删除与 `ord` 对应的行。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-145">It does not cause the deletion of the row corresponding to `ord`.</span></span>

<span data-ttu-id="b5ed6-146">将对象从其所在表中删除 ([!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]) 时，<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> 执行以下处理：</span><span class="sxs-lookup"><span data-stu-id="b5ed6-146">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] performs the following processing when an object is deleted (<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>) from its table:</span></span>

- <span data-ttu-id="b5ed6-147">调用 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 时，会对该对象执行 `DELETE` 操作。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-147">When <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called, a `DELETE` operation is performed for that object.</span></span>

- <span data-ttu-id="b5ed6-148">不论相关对象是否已加载，都不会将此移除操作传播到相关对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-148">The removal is not propagated to related objects regardless of whether they are loaded.</span></span> <span data-ttu-id="b5ed6-149">具体而言，不会为更新关系属性而加载相关对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-149">Specifically, related objects are not loaded for updating the relationship property.</span></span>

- <span data-ttu-id="b5ed6-150">在成功执行 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 后，会将这些对象设置为 `Deleted` 状态。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-150">After successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, the objects are set to the `Deleted` state.</span></span> <span data-ttu-id="b5ed6-151">因此，您不能在该 `id` 中使用此类对象或其 <xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-151">As a result, you cannot use the object or its `id` in that <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="b5ed6-152">由 <xref:System.Data.Linq.DataContext> 实例维护的内部缓存不会消除检索到的对象或作为新对象添加的对象，即使这些对象已从数据库中删除也不例外。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-152">The internal cache maintained by a <xref:System.Data.Linq.DataContext> instance does not eliminate objects that are retrieved or added as new, even after the objects have been deleted in the database.</span></span>

<span data-ttu-id="b5ed6-153">您只能对由 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> 跟踪的对象调用 <xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-153">You can call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> only on an object tracked by the <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="b5ed6-154">对于 `Untracked` 对象，您必须先调用 <xref:System.Data.Linq.Table%601.Attach%2A>，再调用 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-154">For an `Untracked` object, you must call <xref:System.Data.Linq.Table%601.Attach%2A> before you call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.</span></span> <span data-ttu-id="b5ed6-155">对 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> 对象调用 `Untracked` 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-155">Calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> on an `Untracked` object throws an exception.</span></span>

> [!NOTE]
> <span data-ttu-id="b5ed6-156">从表中移除对象使得 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 在 `DELETE` 时生成对应的 SQL <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 命令。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-156">Removing an object from a table tells [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] to generate a corresponding SQL `DELETE` command at the time of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="b5ed6-157">此操作不会从缓存中移除该对象或将删除操作传播到相关对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-157">This action does not remove the object from the cache or propagate the deletion to related objects.</span></span>
>
> <span data-ttu-id="b5ed6-158">若要回收已删除对象的 `id`，请使用新的 <xref:System.Data.Linq.DataContext> 实例。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-158">To reclaim the `id` of a deleted object, use a new <xref:System.Data.Linq.DataContext> instance.</span></span> <span data-ttu-id="b5ed6-159">若要清除相关对象，可以使用数据库的 *级联删除* 功能，或者手动删除相关对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-159">For cleanup of related objects, you can use the *cascade delete* feature of the database, or else manually delete the related objects.</span></span>
>
> <span data-ttu-id="b5ed6-160">无需按任何特殊顺序删除相关对象（与在数据库中进行删除不同）。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-160">The related objects do not have to be deleted in any special order (unlike in the database).</span></span>

## <a name="updating-objects"></a><span data-ttu-id="b5ed6-161">更新对象</span><span class="sxs-lookup"><span data-stu-id="b5ed6-161">Updating Objects</span></span>

<span data-ttu-id="b5ed6-162">您可以通过观察有关更改的通知来检测 `Updates`。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-162">You can detect `Updates` by observing notifications of changes.</span></span> <span data-ttu-id="b5ed6-163">通知是通过属性 setter 中的 <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> 事件提供的。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-163">Notifications are provided through the <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> event in property setters.</span></span> <span data-ttu-id="b5ed6-164">当 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 收到有关对象的第一项更改的通知时，它会创建该对象的一个副本，并将该对象视为用于生成 `Update` 语句的候选对象。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-164">When [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is notified of the first change to an object, it creates a copy of the object and considers the object a candidate for generating an `Update` statement.</span></span>

<span data-ttu-id="b5ed6-165">对于未实现 <xref:System.ComponentModel.INotifyPropertyChanging> 的对象，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 保存这些对象在第一次具体化时所具有的值的副本。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-165">For objects that do not implement <xref:System.ComponentModel.INotifyPropertyChanging>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] maintains a copy of the values that objects had when they were first materialized.</span></span> <span data-ttu-id="b5ed6-166">调用 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 时，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 会比较当前值和原始值，以确定对象是否已更改。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-166">When you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] compares the current and original values to decide whether the object has been changed.</span></span>

<span data-ttu-id="b5ed6-167">对于关系的更新，从子级到父级的引用（即与外键对应的引用）被视为授权。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-167">For updates to relationships, the reference from the child to the parent (that is, the reference corresponding to the foreign key) is considered the authority.</span></span> <span data-ttu-id="b5ed6-168">反方向上（即从父级到子级）的引用是可选的。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-168">The reference in the reverse direction (that is, from parent to child) is optional.</span></span> <span data-ttu-id="b5ed6-169">关系类（<xref:System.Data.Linq.EntitySet%601> 和 <xref:System.Data.Linq.EntityRef%601>）保证双向引用对于一对多和一对一关系是一致的。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-169">Relationship classes (<xref:System.Data.Linq.EntitySet%601> and <xref:System.Data.Linq.EntityRef%601>) guarantee that the bidirectional references are consistent for one-to-many and one-to-one relationships.</span></span> <span data-ttu-id="b5ed6-170">如果对象模型不使用 <xref:System.Data.Linq.EntitySet%601> 或 <xref:System.Data.Linq.EntityRef%601>，且存在反向引用，则需要您来确保在更新关系时反向引用与前向引用一致。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-170">If the object model does not use <xref:System.Data.Linq.EntitySet%601> or <xref:System.Data.Linq.EntityRef%601>, and if the reverse reference is present, it is your responsibility to keep it consistent with the forward reference when the relationship is updated.</span></span>

<span data-ttu-id="b5ed6-171">如果您既更新所需的引用，又更新对应的外键，则必须确保它们一致。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-171">If you update both the required reference and the corresponding foreign key, you must make sure that they agree.</span></span> <span data-ttu-id="b5ed6-172">如果在您调用 <xref:System.InvalidOperationException> 时这两者不同步，则会引发 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 异常。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-172">An <xref:System.InvalidOperationException> exception is thrown if the two are not synchronized at the time that you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="b5ed6-173">尽管外键值的更改足以影响基础行的更新，但您应更改相应的引用以维护对象图的连接性和关系的双向一致性。</span><span class="sxs-lookup"><span data-stu-id="b5ed6-173">Although foreign key value changes are sufficient for affecting an update of the underlying row, you should change the reference to maintain connectivity of the object graph and bidirectional consistency of relationships.</span></span>

## <a name="see-also"></a><span data-ttu-id="b5ed6-174">请参阅</span><span class="sxs-lookup"><span data-stu-id="b5ed6-174">See also</span></span>

- [<span data-ttu-id="b5ed6-175">背景信息</span><span class="sxs-lookup"><span data-stu-id="b5ed6-175">Background Information</span></span>](background-information.md)
- [<span data-ttu-id="b5ed6-176">插入、更新和删除操作</span><span class="sxs-lookup"><span data-stu-id="b5ed6-176">Insert, Update, and Delete Operations</span></span>](insert-update-and-delete-operations.md)
