---
description: 了解详细信息：合并数据集内容
title: 合并数据集内容
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: bdd7184d2b3a46f8ee59a052239dcd472db5e404
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99651868"
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="c51f0-103">合并数据集内容</span><span class="sxs-lookup"><span data-stu-id="c51f0-103">Merging DataSet Contents</span></span>

<span data-ttu-id="c51f0-104">您可以使用 <xref:System.Data.DataSet.Merge%2A> 方法将 <xref:System.Data.DataSet>、<xref:System.Data.DataTable> 或 <xref:System.Data.DataRow> 数组的内容合并到现有的 `DataSet` 中。</span><span class="sxs-lookup"><span data-stu-id="c51f0-104">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="c51f0-105">若干因素和选项会影响将新数据合并到现有 `DataSet` 中的方式。</span><span class="sxs-lookup"><span data-stu-id="c51f0-105">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>

## <a name="primary-keys"></a><span data-ttu-id="c51f0-106">主键</span><span class="sxs-lookup"><span data-stu-id="c51f0-106">Primary Keys</span></span>

<span data-ttu-id="c51f0-107">如果从合并接收新数据和架构的表具有主键，则传入数据中的新行将匹配具有与传入数据中的这些行相同 <xref:System.Data.DataRowVersion.Original> 主键值的现有行。</span><span class="sxs-lookup"><span data-stu-id="c51f0-107">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="c51f0-108">如果传入架构中的列匹配现有架构的相应列，则会修改现有行中的数据。</span><span class="sxs-lookup"><span data-stu-id="c51f0-108">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="c51f0-109">将会忽略或添加与现有架构不匹配的列，具体根据 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 参数而定。</span><span class="sxs-lookup"><span data-stu-id="c51f0-109">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="c51f0-110">主键值与任何现有行都不匹配的新行将追加到现有表中。</span><span class="sxs-lookup"><span data-stu-id="c51f0-110">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>

<span data-ttu-id="c51f0-111">如果传入行或现有行的行状态为 <xref:System.Data.DataRowState.Added>，则将使用 <xref:System.Data.DataRowVersion.Current> 行的 `Added` 主键值来匹配他们的主键值，这是因为不存在 `Original` 行版本。</span><span class="sxs-lookup"><span data-stu-id="c51f0-111">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>

<span data-ttu-id="c51f0-112">如果传入表和现有表包含一个具有相同名称但不同数据类型的列，将引发异常，并引发 <xref:System.Data.DataSet.MergeFailed> 的 `DataSet` 事件。</span><span class="sxs-lookup"><span data-stu-id="c51f0-112">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="c51f0-113">如果传入表和现有表都具有已定义的键，但是主键针对不同的列，将引发异常，并引发 `MergeFailed` 的 `DataSet` 事件。</span><span class="sxs-lookup"><span data-stu-id="c51f0-113">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>

<span data-ttu-id="c51f0-114">如果从合并中接收新数据的表不具有主键，传入数据中的新行将无法与该表中的现有行匹配，而这些新行则会追加到现有表。</span><span class="sxs-lookup"><span data-stu-id="c51f0-114">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>

## <a name="table-names-and-namespaces"></a><span data-ttu-id="c51f0-115">表名称和命名空间</span><span class="sxs-lookup"><span data-stu-id="c51f0-115">Table Names and Namespaces</span></span>

<span data-ttu-id="c51f0-116">可以选择为 <xref:System.Data.DataTable> 对象分配 <xref:System.Data.DataTable.Namespace%2A> 属性值。</span><span class="sxs-lookup"><span data-stu-id="c51f0-116"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="c51f0-117">如果分配了 <xref:System.Data.DataTable.Namespace%2A> 值，则一个 <xref:System.Data.DataSet> 可以包含多个具有相同 <xref:System.Data.DataTable> 值的 <xref:System.Data.DataTable.TableName%2A> 对象。</span><span class="sxs-lookup"><span data-stu-id="c51f0-117">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="c51f0-118">在合并操作期间，<xref:System.Data.DataTable.TableName%2A> 和 <xref:System.Data.DataTable.Namespace%2A> 都用于标识合并目标。</span><span class="sxs-lookup"><span data-stu-id="c51f0-118">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="c51f0-119">如果未分配 <xref:System.Data.DataTable.Namespace%2A>，则只使用 <xref:System.Data.DataTable.TableName%2A> 来标识合并目标。</span><span class="sxs-lookup"><span data-stu-id="c51f0-119">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>

> [!NOTE]
> <span data-ttu-id="c51f0-120">这种行为在 .NET Framework 2.0 版中发生了变化。</span><span class="sxs-lookup"><span data-stu-id="c51f0-120">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="c51f0-121">在 1.1 版中，虽然支持命名空间，但会在合并操作过程中被忽略。</span><span class="sxs-lookup"><span data-stu-id="c51f0-121">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="c51f0-122">因此，使用 <xref:System.Data.DataSet> 属性值的 <xref:System.Data.DataTable.Namespace%2A> 将具有不同的行为，具体取决于您运行哪个版本的 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="c51f0-122">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="c51f0-123">例如，假设您有两个 `DataSets`，其中包含具有相同 `DataTables` 属性值但不同 <xref:System.Data.DataTable.TableName%2A> 属性值的 <xref:System.Data.DataTable.Namespace%2A>。</span><span class="sxs-lookup"><span data-stu-id="c51f0-123">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="c51f0-124">在 .NET Framework 1.1 版中，在合并两个 <xref:System.Data.DataTable.Namespace%2A> 对象时，将会忽略不同的 <xref:System.Data.DataSet> 名称。</span><span class="sxs-lookup"><span data-stu-id="c51f0-124">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="c51f0-125">但从 2.0 版开始，合并操作会导致在目标 `DataTables` 中创建两个新的 <xref:System.Data.DataSet>。</span><span class="sxs-lookup"><span data-stu-id="c51f0-125">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="c51f0-126">原始的 `DataTables` 将不受合并的影响。</span><span class="sxs-lookup"><span data-stu-id="c51f0-126">The original `DataTables` will be unaffected by the merge.</span></span>

## <a name="preservechanges"></a><span data-ttu-id="c51f0-127">PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="c51f0-127">PreserveChanges</span></span>

<span data-ttu-id="c51f0-128">在将 `DataSet`、`DataTable` 或 `DataRow` 数组传递给 `Merge` 方法时，可以包括可选参数用以指定是否在现有 `DataSet` 中保留更改以及如何处理在传入数据中发现的新架构元素。</span><span class="sxs-lookup"><span data-stu-id="c51f0-128">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="c51f0-129">在传入数据后面，这些数据的第一个参数是一个布尔型标志 <xref:System.Data.LoadOption.PreserveChanges>，它指定是否在现有 `DataSet` 中保留更改。</span><span class="sxs-lookup"><span data-stu-id="c51f0-129">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="c51f0-130">如果 `PreserveChanges` 标志设置为 `true`，则传入值不会覆盖现有行的 `Current` 行版本中的现有值。</span><span class="sxs-lookup"><span data-stu-id="c51f0-130">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="c51f0-131">如果 `PreserveChanges` 标志设置为 `false`，则传入值将覆盖现有行的 `Current` 行版本中的现有值。</span><span class="sxs-lookup"><span data-stu-id="c51f0-131">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="c51f0-132">如果未指定 `PreserveChanges` 标志，默认情况下它将设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="c51f0-132">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="c51f0-133">有关行版本的详细信息，请参阅 [行状态和行版本](row-states-and-row-versions.md)。</span><span class="sxs-lookup"><span data-stu-id="c51f0-133">For more information about row versions, see [Row States and Row Versions](row-states-and-row-versions.md).</span></span>

<span data-ttu-id="c51f0-134">如果 `PreserveChanges` 为 `true`，则现有行的 <xref:System.Data.DataRowVersion.Current> 行版本中将保持现有行中的数据，而现有行的 <xref:System.Data.DataRowVersion.Original> 行版本中的数据将由传入行的 `Original` 行版本中的数据覆盖。</span><span class="sxs-lookup"><span data-stu-id="c51f0-134">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="c51f0-135">现有行的 <xref:System.Data.DataRow.RowState%2A> 设置为 <xref:System.Data.DataRowState.Modified>。</span><span class="sxs-lookup"><span data-stu-id="c51f0-135">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="c51f0-136">存在以下例外：</span><span class="sxs-lookup"><span data-stu-id="c51f0-136">The following exceptions apply:</span></span>

- <span data-ttu-id="c51f0-137">如果现有行的 `RowState` 为 `Deleted`，则此 `RowState` 将保持为 `Deleted` 而不设置为 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="c51f0-137">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="c51f0-138">在这种情况下，传入行中的数据将仍然存储在现有行的 `Original` 行版本中，并覆盖现有行的 `Original` 行版本（除非传入行的 `RowState` 为 `Added`）。</span><span class="sxs-lookup"><span data-stu-id="c51f0-138">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>

- <span data-ttu-id="c51f0-139">如果传入行的 `RowState` 为 `Added`，则现有行的 `Original` 行版本中的数据将不会由传入行中的数据覆盖，因为传入行不具有 `Original` 行版本。</span><span class="sxs-lookup"><span data-stu-id="c51f0-139">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

<span data-ttu-id="c51f0-140">如果 `PreserveChanges` 为 `false`，则现有行中的 `Current` 和 `Original` 行版本将都由传入行中的数据覆盖，并且现有行的 `RowState` 将设置为传入行的 `RowState`。</span><span class="sxs-lookup"><span data-stu-id="c51f0-140">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="c51f0-141">存在以下例外：</span><span class="sxs-lookup"><span data-stu-id="c51f0-141">The following exceptions apply:</span></span>

- <span data-ttu-id="c51f0-142">如果传入行的 `RowState` 为 `Unchanged` 且现有行的 `RowState` 为 `Modified`、`Deleted` 或 `Added`，则现有行的 `RowState` 将设置为 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="c51f0-142">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>

- <span data-ttu-id="c51f0-143">如果传入行的 `RowState` 为 `Added` 且现有行的 `RowState` 为 `Unchanged`、`Modified` 或 `Deleted`，则现有行的 `RowState` 将设置为 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="c51f0-143">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="c51f0-144">此外，现有行的 `Original` 行版本中的数据不会由传入行中的数据覆盖，因为传入行不具有 `Original` 行版本。</span><span class="sxs-lookup"><span data-stu-id="c51f0-144">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

## <a name="missingschemaaction"></a><span data-ttu-id="c51f0-145">MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="c51f0-145">MissingSchemaAction</span></span>

<span data-ttu-id="c51f0-146">您可以使用 <xref:System.Data.MissingSchemaAction> 方法的可选 `Merge` 参数来指定 `Merge` 将如何处理传入数据中不属于现有 `DataSet` 的架构元素。</span><span class="sxs-lookup"><span data-stu-id="c51f0-146">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>

<span data-ttu-id="c51f0-147">下表说明用于 `MissingSchemaAction` 的选项。</span><span class="sxs-lookup"><span data-stu-id="c51f0-147">The following table describes the options for `MissingSchemaAction`.</span></span>

|<span data-ttu-id="c51f0-148">MissingSchemaAction 选项</span><span class="sxs-lookup"><span data-stu-id="c51f0-148">MissingSchemaAction option</span></span>|<span data-ttu-id="c51f0-149">说明</span><span class="sxs-lookup"><span data-stu-id="c51f0-149">Description</span></span>|
|--------------------------------|-----------------|
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="c51f0-150">将新的架构信息添加到 `DataSet` 并用传入值填充新列。</span><span class="sxs-lookup"><span data-stu-id="c51f0-150">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="c51f0-151">这是默认设置。</span><span class="sxs-lookup"><span data-stu-id="c51f0-151">This is the default.</span></span>|
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="c51f0-152">将新的架构和主键信息添加到 `DataSet` 并用传入值填充新列。</span><span class="sxs-lookup"><span data-stu-id="c51f0-152">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="c51f0-153">如果遇到不匹配的架构信息，则引发异常。</span><span class="sxs-lookup"><span data-stu-id="c51f0-153">Throw an exception if mismatched schema information is encountered.</span></span>|
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="c51f0-154">忽略新的架构信息。</span><span class="sxs-lookup"><span data-stu-id="c51f0-154">Ignore the new schema information.</span></span>|

## <a name="constraints"></a><span data-ttu-id="c51f0-155">约束</span><span class="sxs-lookup"><span data-stu-id="c51f0-155">Constraints</span></span>

<span data-ttu-id="c51f0-156">使用 `Merge` 方法时，所有新数据都添加到现有 `DataSet` 之前不会检查约束。</span><span class="sxs-lookup"><span data-stu-id="c51f0-156">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="c51f0-157">添加了数据后，会对 `DataSet` 中的当前值实施约束。</span><span class="sxs-lookup"><span data-stu-id="c51f0-157">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="c51f0-158">你必须确保你的代码可以处理可能因约束冲突而引发的任何异常。</span><span class="sxs-lookup"><span data-stu-id="c51f0-158">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>

<span data-ttu-id="c51f0-159">设想有这样一种情况：`DataSet` 中的某一现有行是主键值为 1 的 `Unchanged`。</span><span class="sxs-lookup"><span data-stu-id="c51f0-159">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="c51f0-160">在与 `Modified` 主键值为 2 且 `Original` 主键值为 1 的 `Current` 传入行进行合并期间，由于 `Original` 主键值不同，现有行和传入行将被视为不匹配。</span><span class="sxs-lookup"><span data-stu-id="c51f0-160">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="c51f0-161">不过，完成合并和检查完约束后，将会引发一个异常，因为 `Current` 主键值违反了主键列的唯一约束。</span><span class="sxs-lookup"><span data-stu-id="c51f0-161">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>

> [!NOTE]
> <span data-ttu-id="c51f0-162">在向包含自动递增列（如标识列）的数据库表中插入行时，插入时操作返回的标识列值可能不匹配 `DataSet` 中的值，从而导致追加而不是合并返回的行。</span><span class="sxs-lookup"><span data-stu-id="c51f0-162">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="c51f0-163">有关详细信息，请参阅 [检索标识或自动编号值](../retrieving-identity-or-autonumber-values.md)。</span><span class="sxs-lookup"><span data-stu-id="c51f0-163">For more information, see [Retrieving Identity or Autonumber Values](../retrieving-identity-or-autonumber-values.md).</span></span>

<span data-ttu-id="c51f0-164">下面的代码示例将 `DataSet` 具有不同架构的两个对象合并为一个 `DataSet` ，其中包含两个传入对象的组合架构 `DataSet` 。</span><span class="sxs-lookup"><span data-stu-id="c51f0-164">The following code example merges two `DataSet` objects with different schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>

[!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]

<span data-ttu-id="c51f0-165">下面的代码示例采用带有更新的现有 `DataSet`，并将这些更新传递给 `DataAdapter` 以便在数据源中处理。</span><span class="sxs-lookup"><span data-stu-id="c51f0-165">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="c51f0-166">随后将结果合并到原始 `DataSet` 中。</span><span class="sxs-lookup"><span data-stu-id="c51f0-166">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="c51f0-167">在拒绝导致错误的更改之后，合并的更改与 `AcceptChanges` 一起提交。</span><span class="sxs-lookup"><span data-stu-id="c51f0-167">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]

## <a name="see-also"></a><span data-ttu-id="c51f0-168">请参阅</span><span class="sxs-lookup"><span data-stu-id="c51f0-168">See also</span></span>

- [<span data-ttu-id="c51f0-169">数据集、数据表和数据视图</span><span class="sxs-lookup"><span data-stu-id="c51f0-169">DataSets, DataTables, and DataViews</span></span>](index.md)
- [<span data-ttu-id="c51f0-170">行状态和行版本</span><span class="sxs-lookup"><span data-stu-id="c51f0-170">Row States and Row Versions</span></span>](row-states-and-row-versions.md)
- [<span data-ttu-id="c51f0-171">DataAdapter 和 DataReader</span><span class="sxs-lookup"><span data-stu-id="c51f0-171">DataAdapters and DataReaders</span></span>](../dataadapters-and-datareaders.md)
- [<span data-ttu-id="c51f0-172">在 ADO.NET 中检索和修改数据</span><span class="sxs-lookup"><span data-stu-id="c51f0-172">Retrieving and Modifying Data in ADO.NET</span></span>](../retrieving-and-modifying-data.md)
- [<span data-ttu-id="c51f0-173">检索标识或自动编号值</span><span class="sxs-lookup"><span data-stu-id="c51f0-173">Retrieving Identity or Autonumber Values</span></span>](../retrieving-identity-or-autonumber-values.md)
- [<span data-ttu-id="c51f0-174">ADO.NET 概述</span><span class="sxs-lookup"><span data-stu-id="c51f0-174">ADO.NET Overview</span></span>](../ado-net-overview.md)
