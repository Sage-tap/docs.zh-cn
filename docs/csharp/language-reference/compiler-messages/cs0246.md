---
description: 编译器错误 CS0246
title: 编译器错误 CS0246
ms.date: 01/23/2018
f1_keywords:
- CS0246
helpviewer_keywords:
- CS0246
ms.assetid: 4948fae2-2cc0-4ce4-b98c-ea69a8120b71
ms.openlocfilehash: 2a50ee8799794dcf0d074bb2eadd94c06962b892
ms.sourcegitcommit: 0bb8074d524e0dcf165430b744bb143461f17026
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/15/2021
ms.locfileid: "103479651"
---
# <a name="compiler-error-cs0246"></a><span data-ttu-id="24014-103">编译器错误 CS0246</span><span class="sxs-lookup"><span data-stu-id="24014-103">Compiler Error CS0246</span></span>

<span data-ttu-id="24014-104">未能找到类型或命名空间名称“type/namespace”（是否缺少 using 指令或程序集引用？）</span><span class="sxs-lookup"><span data-stu-id="24014-104">The type or namespace name 'type/namespace' could not be found (are you missing a using directive or an assembly reference?)</span></span>  
  
<span data-ttu-id="24014-105">找不到在程序中使用的类型或命名空间。</span><span class="sxs-lookup"><span data-stu-id="24014-105">A type or namespace that is used in the program was not found.</span></span> <span data-ttu-id="24014-106">你可能忘记引用 ([References](../compiler-options/inputs.md#references)) 包含此类型的程序集，或者可能未添加所需的 [using 指令](../keywords/using-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="24014-106">You might have forgotten to reference ([**References**](../compiler-options/inputs.md#references)) the assembly that contains the type, or you might not have added the required [using directive](../keywords/using-directive.md).</span></span>  <span data-ttu-id="24014-107">或者，可能想要引用的程序集存在问题。</span><span class="sxs-lookup"><span data-stu-id="24014-107">Or, there might be an issue with the assembly you are trying to reference.</span></span>  
  
<span data-ttu-id="24014-108">以下情况下会导致编译器错误 CS0246。</span><span class="sxs-lookup"><span data-stu-id="24014-108">The following situations cause compiler error CS0246.</span></span>  
  
- <span data-ttu-id="24014-109">类型或命名空间的名称是否拼写有误？</span><span class="sxs-lookup"><span data-stu-id="24014-109">Did you misspell the name of the type or namespace?</span></span> <span data-ttu-id="24014-110">没有正确的名称，编译器找不到类型或命名空间的定义。</span><span class="sxs-lookup"><span data-stu-id="24014-110">Without the correct name, the compiler cannot find the definition for the type or namespace.</span></span> <span data-ttu-id="24014-111">这通常是因为类型名称中使用大小写不正确。</span><span class="sxs-lookup"><span data-stu-id="24014-111">This often occurs because the casing used in the name of the type is not correct.</span></span> <span data-ttu-id="24014-112">例如， `Dataset ds;` 生成 CS0246，因为“Dataset”中的 s，必须大写。</span><span class="sxs-lookup"><span data-stu-id="24014-112">For example, `Dataset ds;` generates CS0246 because the s in Dataset must be capitalized.</span></span>  
  
- <span data-ttu-id="24014-113">如果错误针对的是命名空间名称，那么你是否已将引用 ([References](../compiler-options/inputs.md#references)) 添加到包含命名空间的程序集？</span><span class="sxs-lookup"><span data-stu-id="24014-113">If the error is for a namespace name, did you add a reference ([**References**](../compiler-options/inputs.md#references)) to the assembly that contains the namespace?</span></span> <span data-ttu-id="24014-114">例如，你的代码可能包含指令 `using Accessibility`。</span><span class="sxs-lookup"><span data-stu-id="24014-114">For example, your code might contain the directive `using Accessibility`.</span></span> <span data-ttu-id="24014-115">但是，如果你的项目未引用程序集 Accessibility.dll，将报告错误 CS0246。</span><span class="sxs-lookup"><span data-stu-id="24014-115">However, if your project does not reference the assembly Accessibility.dll, error CS0246 is reported.</span></span> <span data-ttu-id="24014-116">有关详细信息，请参阅[管理项目中的引用](/visualstudio/ide/managing-references-in-a-project)</span><span class="sxs-lookup"><span data-stu-id="24014-116">For more information, see [Managing references in a project](/visualstudio/ide/managing-references-in-a-project)</span></span>  
  
- <span data-ttu-id="24014-117">如果错误针对的是类型名称，那么你是否包含了正确的 [using](../keywords/using-directive.md) 指令，或者是否完全限定了类型的名称？</span><span class="sxs-lookup"><span data-stu-id="24014-117">If the error is for a type name, did you include the proper [using directive](../keywords/using-directive.md), or, alternatively, fully qualify the name of the type?</span></span> <span data-ttu-id="24014-118">请考虑以下声明： `DataSet ds`。</span><span class="sxs-lookup"><span data-stu-id="24014-118">Consider the following declaration: `DataSet ds`.</span></span> <span data-ttu-id="24014-119">若要使用 `DataSet` 类型，需要以下两项。</span><span class="sxs-lookup"><span data-stu-id="24014-119">To use the `DataSet` type, you need two things.</span></span> <span data-ttu-id="24014-120">首先，你需要对程序集的引用，该程序集包含 `DataSet` 类型的定义。</span><span class="sxs-lookup"><span data-stu-id="24014-120">First, you need a reference to the assembly that contains the definition for the `DataSet` type.</span></span> <span data-ttu-id="24014-121">其次，你需要针对 `using` 所在命名空间的 `DataSet` 指令。</span><span class="sxs-lookup"><span data-stu-id="24014-121">Second, you need a `using` directive for the namespace where `DataSet` is located.</span></span> <span data-ttu-id="24014-122">例如，因为 `DataSet` 位于 **System.Data** 命名空间中，在代码的开头你需要以下指令： `using System.Data`。</span><span class="sxs-lookup"><span data-stu-id="24014-122">For example, because `DataSet` is located in the **System.Data** namespace, you need the following directive at the beginning of your code: `using System.Data`.</span></span>  
  
     <span data-ttu-id="24014-123">`using` 指令则不需要。</span><span class="sxs-lookup"><span data-stu-id="24014-123">The `using` directive is not required.</span></span> <span data-ttu-id="24014-124">但是，如果省略该指令，则在对其引用时必须完全限定 `DataSet` 类型。</span><span class="sxs-lookup"><span data-stu-id="24014-124">However, if you omit the directive, you must fully qualify the `DataSet` type when referring to it.</span></span> <span data-ttu-id="24014-125">完全限定意味着每次在代码中引用该类型时要指定命名空间和类型。</span><span class="sxs-lookup"><span data-stu-id="24014-125">Full qualification means that you specify both the namespace and the type each time you refer to the type in your code.</span></span> <span data-ttu-id="24014-126">如果在上一示例中省略 `using` 指令，则必须编写 `System.Data.DataSet ds` 以声明 `ds` 而不是 `DataSet ds`。</span><span class="sxs-lookup"><span data-stu-id="24014-126">If you omit the `using` directive in the previous example, you must write `System.Data.DataSet ds` to declare `ds` instead of `DataSet ds`.</span></span>  
  
- <span data-ttu-id="24014-127">是否在应该为类型的地方使用了变量或某种其他语言元素？</span><span class="sxs-lookup"><span data-stu-id="24014-127">Did you use a variable or some other language element where a type was expected?</span></span> <span data-ttu-id="24014-128">例如，在 **is** 语句中，如果使用 `Type` 对象而不使用实际类型，则会出现错误 CS0246。</span><span class="sxs-lookup"><span data-stu-id="24014-128">For example, in an **is** statement, if you use a `Type` object instead of an actual type, you get error CS0246.</span></span>  

- <span data-ttu-id="24014-129">引用的程序集是否针对比程序的目标框架版本更高的框架版本而生成？</span><span class="sxs-lookup"><span data-stu-id="24014-129">Did you reference the assembly that was built against a higher framework version than the target framework of the program?</span></span> <span data-ttu-id="24014-130">或者，引用的项目所面向的框架版本是否高于程序的目标框架版本？</span><span class="sxs-lookup"><span data-stu-id="24014-130">Or did you reference the project that is targeting a higher framework version than the target framework of the program?</span></span> <span data-ttu-id="24014-131">例如，你在处理面向 .NET Framework 4.6.1 的项目，但使用的是面向 .NET Framework 4.7.1 的项目中的类型。</span><span class="sxs-lookup"><span data-stu-id="24014-131">For example, you work on the project that is targeting .NET Framework 4.6.1 and use the type from the project that is targeting .NET Framework 4.7.1.</span></span> <span data-ttu-id="24014-132">这样就显示错误 CS0246。</span><span class="sxs-lookup"><span data-stu-id="24014-132">Then you get error CS0246.</span></span>
  
- <span data-ttu-id="24014-133">是否使用了 *using 别名指令* 而没有完全限定类型名称？</span><span class="sxs-lookup"><span data-stu-id="24014-133">Did you use a *using alias directive* without fully qualifying the type name?</span></span> <span data-ttu-id="24014-134">`using` 别名指令不使用源代码文件中的 `using` 指令来解析类型。</span><span class="sxs-lookup"><span data-stu-id="24014-134">A `using` alias directive does not use the `using` directives in the source code file to resolve types.</span></span> <span data-ttu-id="24014-135">以下示例生成 CS0246，因为类型 `List<int>` 未完全限定。</span><span class="sxs-lookup"><span data-stu-id="24014-135">The following example generates CS0246 because the type `List<int>` is not fully qualified.</span></span> <span data-ttu-id="24014-136">`using` 的 `System.Collections.Generic` 指令不会避免该错误。</span><span class="sxs-lookup"><span data-stu-id="24014-136">The `using` directive for `System.Collections.Generic` does not prevent the error.</span></span>  
  
    ```csharp  
    using System.Collections.Generic;  
  
    // The following declaration generates CS0246.  
    using myAliasName = List<int>;
  
    // To avoid the error, fully qualify List.  
    using myAliasName2 = System.Collections.Generic.List<int>;  
    ```  
  
     <span data-ttu-id="24014-137">如果在之前运行的代码中遇到此错误，首先在解决方案资源管理器中查找丢失或未解析的引用。</span><span class="sxs-lookup"><span data-stu-id="24014-137">If you get this error in code that was previously working, first look for missing or unresolved references in Solution Explorer.</span></span> <span data-ttu-id="24014-138">是否需要重新安装 [NuGet](https://www.nuget.org/) 包？</span><span class="sxs-lookup"><span data-stu-id="24014-138">Do you need to reinstall a [NuGet](https://www.nuget.org/) package?</span></span> <span data-ttu-id="24014-139">有关生成系统如何搜索引用方面的信息，请参阅 [解析团队生成中的文件引用](/archive/blogs/manishagarwal/resolving-file-references-in-team-build-part-2)。</span><span class="sxs-lookup"><span data-stu-id="24014-139">For information about how the build system searches for references, see [Resolving file references in team build](/archive/blogs/manishagarwal/resolving-file-references-in-team-build-part-2).</span></span> <span data-ttu-id="24014-140">如果所有引用都似乎正确，请在源代码管理历史记录中查看在 .csproj 文件和/或你的本地源文件中有哪些更改。</span><span class="sxs-lookup"><span data-stu-id="24014-140">If all references seem to be correct, look in your source control history to see what has changed in your .csproj file and/or your local source file.</span></span>  
  
     <span data-ttu-id="24014-141">如果尚未成功访问过该引用，则使用对象浏览器来检查应包含此命名空间的程序集并验证命名空间是否存在。</span><span class="sxs-lookup"><span data-stu-id="24014-141">If you haven’t successfully accessed the reference yet, use the Object Browser to inspect the assembly that is supposed to contain this namespace and verify that the namespace is present.</span></span> <span data-ttu-id="24014-142">如果使用对象浏览器验证出该程序集包含命名空间，请尝试删除命名空间的 `using` 指令，并查看其他中断部分。</span><span class="sxs-lookup"><span data-stu-id="24014-142">If you verify with Object Browser that the assembly contains the namespace, try removing the `using` directive for the namespace and see what else breaks.</span></span> <span data-ttu-id="24014-143">根本问题可能涉及另一个程序集中的某些其他类型。</span><span class="sxs-lookup"><span data-stu-id="24014-143">The root problem may be with some other type in another assembly.</span></span>  
  
<span data-ttu-id="24014-144">以下示例生成 CS0246，因为必需的 `using` 指令缺失。</span><span class="sxs-lookup"><span data-stu-id="24014-144">The following example generates CS0246 because a necessary `using` directive is missing.</span></span>  
  
```csharp  
// CS0246.cs  
//using System.Diagnostics;  
  
public class MyClass  
{  
    // The following line causes CS0246. To fix the error, uncomment  
    // the using directive for the namespace for this attribute,  
    // System.Diagnostics.  
    [Conditional("A")]  
    public void Test()  
    {  
    }  
  
    public static void Main()  
    {  
    }  
}  
```  
  
<span data-ttu-id="24014-145">下面的示例会导致 CS0246，因为应该在使用实际类型的时候使用了 `Type` 类型。</span><span class="sxs-lookup"><span data-stu-id="24014-145">The following example causes CS0246 because an object of type `Type` was used where an actual type was expected.</span></span>  
  
```csharp  
// CS0246b.cs  
using System;  
  
class ExampleClass  
{  
    public bool supports(object o, Type t)  
    {  
        // The following line causes CS0246. You must use an  
        // actual type, such as ExampleClass, String, or Type.  
        if (o is t)  
        {  
            return true;  
        }  
        return false;  
    }  
}  
  
class Program  
{  
    public static void Main()  
    {  
        ExampleClass myC = new ExampleClass();  
        myC.supports(myC, myC.GetType());  
    }  
}  
```
