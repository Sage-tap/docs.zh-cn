---
title: 弃元 - C# 指南
description: 介绍 C# 对弃元的支持（弃元是未赋值的可丢弃变量），以及弃元的使用方式。
ms.technology: csharp-fundamentals
ms.date: 09/22/2020
ms.openlocfilehash: 7562da880ff3136dfc04ce4061bafa8ed55f5a23
ms.sourcegitcommit: 38999dc0ec4f7c4404de5ce0951b64c55997d9ab
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/02/2021
ms.locfileid: "99426913"
---
# <a name="discards---c-guide"></a><span data-ttu-id="ebdaa-103">弃元 - C# 指南</span><span class="sxs-lookup"><span data-stu-id="ebdaa-103">Discards - C# Guide</span></span>

<span data-ttu-id="ebdaa-104">从 C# 7.0 开始，C# 支持弃元，这是一种在应用程序代码中人为取消使用的占位符变量。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-104">Starting with C# 7.0, C# supports discards, which are placeholder variables that are intentionally unused in application code.</span></span> <span data-ttu-id="ebdaa-105">弃元相当于未赋值的变量；它们没有值。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-105">Discards are equivalent to unassigned variables; they don't have a value.</span></span> <span data-ttu-id="ebdaa-106">弃元将意图传达给编译器和其他读取代码的文件：你打算忽略表达式的结果。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-106">A discard communicates intent to the compiler and others that read your code: You intended to ignore the result of an expression.</span></span> <span data-ttu-id="ebdaa-107">你可能需要忽略表达式的结果、元组表达式的一个或多个成员、方法的 `out` 参数或模式匹配表达式的目标。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-107">You may want to ignore the result of an expression, one or more members of a tuple expression, an `out` parameter to a method, or the target of a pattern matching expression.</span></span>

<span data-ttu-id="ebdaa-108">因为只有一个弃元变量，甚至不为该变量分配存储空间。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-108">Because there's only a single discard variable, that variable may not even be allocated storage.</span></span> <span data-ttu-id="ebdaa-109">所以，弃元可以减少内存分配。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-109">Discards can reduce memory allocations.</span></span> <span data-ttu-id="ebdaa-110">弃元使代码意图更加明确。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-110">Discards make the intent of your code clear.</span></span> <span data-ttu-id="ebdaa-111">它们可以增强其可读性和可维护性。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-111">They enhance its readability and maintainability.</span></span>

<span data-ttu-id="ebdaa-112">通过将下划线 (`_`) 赋给一个变量作为其变量名，指示该变量为一个占位符变量。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-112">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="ebdaa-113">例如，以下方法调用返回一个元组，其中第一个值和第二个值为弃元。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-113">For example, the following method call returns a tuple in which the first and second values are discards.</span></span> <span data-ttu-id="ebdaa-114">`area` 是以前声明的变量，设置为由 `GetCityInformation` 返回的第三个组件：</span><span class="sxs-lookup"><span data-stu-id="ebdaa-114">`area` is a previously declared variable set to the third component returned by `GetCityInformation`:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="ebdaa-115">从 C# 9.0 开始，可以使用弃元指定 Lambda 表达式中不使用的输入参数。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-115">Beginning with C# 9.0, you can use discards to specify unused input parameters of a lambda expression.</span></span> <span data-ttu-id="ebdaa-116">有关详细信息，请参阅 [Lambda 表达式](language-reference/operators/lambda-expressions.md)一文中的 [Lambda 表达式的输入参数](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression)一节。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-116">For more information, see the [Input parameters of a lambda expression](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="ebdaa-117">当 `_` 是有效弃元时，尝试检索其值或在赋值操作中使用它时会生成编译器错误 CS0301：“当前上下文中不存在名称 ‘\_’”。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-117">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' doesn't exist in the current context".</span></span> <span data-ttu-id="ebdaa-118">出现此错误是因为 `_` 未赋值，甚至可能未分配存储位置。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-118">This error is because `_` isn't assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="ebdaa-119">如果它是一个实际变量，则不能像之前的示例那样对多个值使用弃元。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-119">If it were an actual variable, you couldn't discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="ebdaa-120">元组和对象析构</span><span class="sxs-lookup"><span data-stu-id="ebdaa-120">Tuple and object deconstruction</span></span>

<span data-ttu-id="ebdaa-121">如果应用程序代码使用某些元组元素，但忽略其他元素，这时使用弃元来处理元组就会很有用。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-121">Discards are useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="ebdaa-122">例如，以下 `QueryCityDataForYears` 方法返回一个元组，包含城市名称、城市面积、一个年份、该年份的城市人口、另一个年份及该年份的城市人口。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-122">For example, the following `QueryCityDataForYears` method returns a tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="ebdaa-123">该示例显示了两个年份之间人口的变化。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-123">The example shows the change in population between those two years.</span></span> <span data-ttu-id="ebdaa-124">对于元组提供的数据，我们不关注城市面积，并在一开始就知道城市名称和两个日期。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-124">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="ebdaa-125">因此，我们只关注存储在元组中的两个人口数量值，可将其余值作为占位符处理。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-125">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

:::code language="csharp" source="snippets/discards/discard-tuple.cs" ID="DiscardTupleMember" :::

<span data-ttu-id="ebdaa-126">有关使用占位符析构元组的详细信息，请参阅 [析构元组和其他类型](deconstruct.md#deconstructing-tuple-elements-with-discards)。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-126">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="ebdaa-127">类、结构或接口的 `Deconstruct` 方法还允许从对象中检索和析构一组特定的数据。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-127">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="ebdaa-128">如果想只使用析构值的一个子集，可使用弃元。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-128">You can use discards when you're interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="ebdaa-129">以下示例将 `Person` 对象析构为四个字符串（名字、姓氏、城市和省/市/自治区），但舍弃姓氏和省/市/自治区。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-129">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

:::code language="csharp" source="snippets/discards/discard-class.cs" :::

<span data-ttu-id="ebdaa-130">有关使用弃元析构用户定义的类型的详细信息，请参阅 [析构元组和其他类型](deconstruct.md#deconstructing-a-user-defined-type-with-discards)。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-130">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch"></a><span data-ttu-id="ebdaa-131">使用 \`switch 的模式匹配</span><span class="sxs-lookup"><span data-stu-id="ebdaa-131">Pattern matching with \`switch</span></span>

<span data-ttu-id="ebdaa-132">弃元模式可通过 [switch](language-reference/keywords/switch.md) 关键字用于模式匹配。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-132">The *discard pattern* can be used in pattern matching with the [switch](language-reference/keywords/switch.md) keyword.</span></span> <span data-ttu-id="ebdaa-133">每个表达式始终匹配弃元模式。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-133">Every expression always matches the discard pattern.</span></span> <span data-ttu-id="ebdaa-134">（可将其与 [is](language-reference/keywords/is.md) 表达式一起使用。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-134">(It can be used with [is](language-reference/keywords/is.md) expressions.</span></span> <span data-ttu-id="ebdaa-135">不过，这种情况很少出现，因为可以删除弃元，但不会更改其含义。）</span><span class="sxs-lookup"><span data-stu-id="ebdaa-135">However, that use is rare because the discard can be removed without changing its meaning).</span></span>

<span data-ttu-id="ebdaa-136">以下示例定义了一个 `ProvidesFormatInfo` 方法，该方法使用 [is](language-reference/keywords/is.md) 语句来确定对象是否提供 <xref:System.IFormatProvider> 实现并测试对象是否为 `null`。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-136">The following example defines a `ProvidesFormatInfo` method that uses [is](language-reference/keywords/is.md) statements to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="ebdaa-137">它还使用占位符模式来处理任何其他类型的非 null 对象。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-137">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

:::code language="csharp" source="snippets/discards/discard-pattern2.cs" ID="DiscardSwitchExample" :::

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="ebdaa-138">对具有 `out` 参数的方法的调用</span><span class="sxs-lookup"><span data-stu-id="ebdaa-138">Calls to methods with `out` parameters</span></span>

<span data-ttu-id="ebdaa-139">当调用 `Deconstruct` 方法来析构用户定义类型（类、结构或接口的实例）时，可使用占位符表示单个 `out` 参数的值。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-139">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="ebdaa-140">但当使用 `out` 参数调用任何方法时，也可使用弃元表示 `out` 参数的值。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-140">But you can also discard the value of `out` arguments when calling any method with an `out` parameter.</span></span>

<span data-ttu-id="ebdaa-141">以下示例调用 [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) 方法来确定日期的字符串表示形式在当前区域性中是否有效。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-141">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="ebdaa-142">因为该示例侧重验证日期字符串，而不是解析它来提取日期，所以方法的 `out` 参数为占位符。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-142">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

:::code language="csharp" source="snippets/discards/discard-out1.cs" ID="DiscardOutParameter" :::

## <a name="a-standalone-discard"></a><span data-ttu-id="ebdaa-143">独立弃元</span><span class="sxs-lookup"><span data-stu-id="ebdaa-143">A standalone discard</span></span>

<span data-ttu-id="ebdaa-144">可使用独立弃元来指示要忽略的任何变量。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-144">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="ebdaa-145">一种典型的用法是使用赋值来确保一个参数不为 null。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-145">One typical use is to use an assignment to ensure that an argument isn't null.</span></span> <span data-ttu-id="ebdaa-146">下面的代码使用弃元来强制赋值。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-146">The following code uses a discard to force an assignment.</span></span> <span data-ttu-id="ebdaa-147">赋值的右侧使用 [Null 合并操作符](language-reference/operators/null-coalescing-operator.md)，用于在参数为 `null` 时引发 <xref:System.ArgumentNullException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-147">The right side of the assignment uses the [null coalescing operator](language-reference/operators/null-coalescing-operator.md) to throw an <xref:System.ArgumentNullException?displayProperty=nameWithType> when the argument is `null`.</span></span> <span data-ttu-id="ebdaa-148">此代码不需要赋值结果，因此将对其使用弃元。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-148">The code doesn't need the result of the assignment, so it's discarded.</span></span> <span data-ttu-id="ebdaa-149">该表达式强制执行 null 检查。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-149">The expression forces a null check.</span></span> <span data-ttu-id="ebdaa-150">弃元说明你的意图：不需要或不使用赋值结果。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-150">The discard clarifies your intent: the result of the assignment isn't needed or used.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="ArgNullCheck" :::

<span data-ttu-id="ebdaa-151">以下示例使用独立占位符来忽略异步操作返回的 <xref:System.Threading.Tasks.Task> 对象。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-151">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="ebdaa-152">分配任务的效果等同于抑制操作即将完成时所引发的异常。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-152">Assigning the task has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span> <span data-ttu-id="ebdaa-153">这使你的意图更加明确：你需要对 `Task` 使用弃元，并忽略该异步操作生成的任何错误。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-153">It makes your intent clear: You want to discard the `Task`, and ignore any errors generated from that asynchronous operation.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetDiscardTask" :::

<span data-ttu-id="ebdaa-154">如果不将任务分配给弃元，则以下代码会生成编译器警告：</span><span class="sxs-lookup"><span data-stu-id="ebdaa-154">Without assigning the task to a discard, the following code generates a compiler warning:</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetNoDiscardTask" :::

> [!NOTE]
> <span data-ttu-id="ebdaa-155">如果使用调试器运行前面两个示例中的任意一个，则在引发异常时，调试器将停止该程序。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-155">If you run either of the preceding two samples using a debugger, the debugger will stop the program when the exception is thrown.</span></span> <span data-ttu-id="ebdaa-156">在没有附加调试器的情况下，这两种情况下的异常都会被以静默方式忽略。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-156">Without a debugger attached, the exception is silently ignored in both cases.</span></span>

<span data-ttu-id="ebdaa-157">`_` 也是有效标识符。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-157">`_` is also a valid identifier.</span></span> <span data-ttu-id="ebdaa-158">当在支持的上下文之外使用时，`_` 不视为占位符，而视为有效变量。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-158">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="ebdaa-159">如果名为 `_` 的标识符已在范围内，则使用 `_` 作为独立占位符可能导致：</span><span class="sxs-lookup"><span data-stu-id="ebdaa-159">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="ebdaa-160">将预期的占位符的值赋给范围内 `_` 变量，会导致该变量的值被意外修改。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-160">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="ebdaa-161">例如：</span><span class="sxs-lookup"><span data-stu-id="ebdaa-161">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableIdentifier" :::
- <span data-ttu-id="ebdaa-162">因违反类型安全而发生的编译器错误。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-162">A compiler error for violating type safety.</span></span> <span data-ttu-id="ebdaa-163">例如：</span><span class="sxs-lookup"><span data-stu-id="ebdaa-163">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableTypeInference" :::
- <span data-ttu-id="ebdaa-164">编译器错误 CS0136：“无法在此范围中声明名为“\_”的局部变量或参数，因为该名称用于在封闭的局部范围中定义局部变量或参数”。</span><span class="sxs-lookup"><span data-stu-id="ebdaa-164">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="ebdaa-165">例如：</span><span class="sxs-lookup"><span data-stu-id="ebdaa-165">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="CannotRedeclare" :::

## <a name="see-also"></a><span data-ttu-id="ebdaa-166">另请参阅</span><span class="sxs-lookup"><span data-stu-id="ebdaa-166">See also</span></span>

- [<span data-ttu-id="ebdaa-167">析构元组和其他类型</span><span class="sxs-lookup"><span data-stu-id="ebdaa-167">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="ebdaa-168">`is` 关键字</span><span class="sxs-lookup"><span data-stu-id="ebdaa-168">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="ebdaa-169">`switch` 关键字</span><span class="sxs-lookup"><span data-stu-id="ebdaa-169">`switch` keyword</span></span>](language-reference/keywords/switch.md)
