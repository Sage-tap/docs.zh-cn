---
title: '安全规则 (代码分析) '
description: 了解代码分析安全规则。
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 861827662a771ec7cc1827cdd8125be6c05bf05c
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99719716"
---
# <a name="security-rules"></a><span data-ttu-id="8c987-103">安全规则</span><span class="sxs-lookup"><span data-stu-id="8c987-103">Security rules</span></span>

<span data-ttu-id="8c987-104">安全规则支持更安全的库和应用程序。</span><span class="sxs-lookup"><span data-stu-id="8c987-104">Security rules support safer libraries and applications.</span></span> <span data-ttu-id="8c987-105">这些规则可帮助防止程序中出现安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-105">These rules help prevent security flaws in your program.</span></span> <span data-ttu-id="8c987-106">如果您禁用这些规则中的任何一种，您应该清楚地标记代码中的原因，并向您的开发项目通知指定的安全官员。</span><span class="sxs-lookup"><span data-stu-id="8c987-106">If you disable any of these rules, you should clearly mark the reason in code and also inform the designated security officer for your development project.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="8c987-107">本节内容</span><span class="sxs-lookup"><span data-stu-id="8c987-107">In this section</span></span>

|<span data-ttu-id="8c987-108">规则</span><span class="sxs-lookup"><span data-stu-id="8c987-108">Rule</span></span>|<span data-ttu-id="8c987-109">描述</span><span class="sxs-lookup"><span data-stu-id="8c987-109">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="8c987-110">CA2100:检查 SQL 查询是否存在安全漏洞</span><span class="sxs-lookup"><span data-stu-id="8c987-110">CA2100: Review SQL queries for security vulnerabilities</span></span>](ca2100.md)|<span data-ttu-id="8c987-111">一个方法使用按该方法的字符串参数生成的字符串设置 System.Data.IDbCommand.CommandText 属性。</span><span class="sxs-lookup"><span data-stu-id="8c987-111">A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method.</span></span> <span data-ttu-id="8c987-112">此规则假定字符串参数中包含用户输入。</span><span class="sxs-lookup"><span data-stu-id="8c987-112">This rule assumes that the string argument contains user input.</span></span> <span data-ttu-id="8c987-113">基于用户输入生成的 SQL 命令字符串易于受到 SQL 注入式攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-113">A SQL command string built from user input is vulnerable to SQL injection attacks.</span></span>|
|[<span data-ttu-id="8c987-114">CA2109:检查可见的事件处理程序</span><span class="sxs-lookup"><span data-stu-id="8c987-114">CA2109: Review visible event handlers</span></span>](ca2109.md)|<span data-ttu-id="8c987-115">检测到公共事件处理方法或受保护事件处理方法。</span><span class="sxs-lookup"><span data-stu-id="8c987-115">A public or protected event-handling method was detected.</span></span> <span data-ttu-id="8c987-116">除非绝对必要，否则不应公开事件处理方法。</span><span class="sxs-lookup"><span data-stu-id="8c987-116">Event-handling methods should not be exposed unless absolutely necessary.</span></span>|
|[<span data-ttu-id="8c987-117">CA2119:密封满足私有接口的方法</span><span class="sxs-lookup"><span data-stu-id="8c987-117">CA2119: Seal methods that satisfy private interfaces</span></span>](ca2119.md)|<span data-ttu-id="8c987-118">可继承的公共类型为 internal（在 Visual Basic 中为 Friend）接口提供可重写的方法实现。</span><span class="sxs-lookup"><span data-stu-id="8c987-118">An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface.</span></span> <span data-ttu-id="8c987-119">若要修复与此规则的冲突，请禁止方法在程序集外重写。</span><span class="sxs-lookup"><span data-stu-id="8c987-119">To fix a violation of this rule, prevent the method from being overridden outside the assembly.</span></span>|
|[<span data-ttu-id="8c987-120">CA2153:避免处理损坏状态异常</span><span class="sxs-lookup"><span data-stu-id="8c987-120">CA2153: Avoid Handling Corrupted State Exceptions</span></span>](ca2153.md)|<span data-ttu-id="8c987-121">[损坏状态异常 (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) 指示进程中存在内存损坏。</span><span class="sxs-lookup"><span data-stu-id="8c987-121">[Corrupted State Exceptions (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) indicate that memory corruption exists in your process.</span></span> <span data-ttu-id="8c987-122">如果攻击者可以将攻击放置到损坏的内存区域，则捕获它们（而非允许进程崩溃）可能导致安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-122">Catching these rather than allowing the process to crash can lead to security vulnerabilities if an attacker can place an exploit into the corrupted memory region.</span></span>|
|[<span data-ttu-id="8c987-123">CA2300：请勿使用不安全的反序列化程序 BinaryFormatte</span><span class="sxs-lookup"><span data-stu-id="8c987-123">CA2300: Do not use insecure deserializer BinaryFormatter</span></span>](ca2300.md)|<span data-ttu-id="8c987-124">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-124">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-125">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-125">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-126">CA2301：在未先设置 BinaryFormatter.Binder 的情况下，请不要调用 BinaryFormatter.Deserialize</span><span class="sxs-lookup"><span data-stu-id="8c987-126">CA2301: Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</span></span>](ca2301.md)|<span data-ttu-id="8c987-127">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-127">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-128">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-128">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-129">CA2302：在调用 BinaryFormatter.Deserialize 之前，确保设置 BinaryFormatter.Binder</span><span class="sxs-lookup"><span data-stu-id="8c987-129">CA2302: Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</span></span>](ca2302.md)|<span data-ttu-id="8c987-130">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-130">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-131">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-131">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-132">CA2305：请勿使用不安全的反序列化程序 LosFormatter</span><span class="sxs-lookup"><span data-stu-id="8c987-132">CA2305: Do not use insecure deserializer LosFormatter</span></span>](ca2305.md)|<span data-ttu-id="8c987-133">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-133">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-134">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-134">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-135">CA2310：请勿使用不安全的反序列化程序 NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="8c987-135">CA2310: Do not use insecure deserializer NetDataContractSerializer</span></span>](ca2310.md)|<span data-ttu-id="8c987-136">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-136">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-137">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-137">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-138">CA2311：在未先设置 NetDataContractSerializer.Binder 的情况下，请不要反序列化</span><span class="sxs-lookup"><span data-stu-id="8c987-138">CA2311: Do not deserialize without first setting NetDataContractSerializer.Binder</span></span>](ca2311.md)|<span data-ttu-id="8c987-139">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-139">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-140">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-140">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-141">CA2312：确保在反序列化之前设置 NetDataContractSerializer.Binder</span><span class="sxs-lookup"><span data-stu-id="8c987-141">CA2312: Ensure NetDataContractSerializer.Binder is set before deserializing</span></span>](ca2312.md)|<span data-ttu-id="8c987-142">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-142">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-143">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-143">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-144">CA2315：请勿使用不安全的反序列化程序 ObjectStateFormatter</span><span class="sxs-lookup"><span data-stu-id="8c987-144">CA2315: Do not use insecure deserializer ObjectStateFormatter</span></span>](ca2315.md)|<span data-ttu-id="8c987-145">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-145">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-146">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-146">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-147">CA2321：请勿使用 SimpleTypeResolver 对 JavaScriptSerializer 进行反序列化</span><span class="sxs-lookup"><span data-stu-id="8c987-147">CA2321: Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</span></span>](ca2321.md)|<span data-ttu-id="8c987-148">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-148">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-149">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-149">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-150">CA2322：确保在反序列化之前没有使用 SimpleTypeResolver 初始化 JavaScriptSerializer</span><span class="sxs-lookup"><span data-stu-id="8c987-150">CA2322: Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</span></span>](ca2322.md)|<span data-ttu-id="8c987-151">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-151">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-152">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-152">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-153">CA2326：请勿使用 None 以外的 TypeNameHandling 值</span><span class="sxs-lookup"><span data-stu-id="8c987-153">CA2326: Do not use TypeNameHandling values other than None</span></span>](ca2326.md)|<span data-ttu-id="8c987-154">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-154">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-155">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-155">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-156">CA2327：不要使用不安全的 JsonSerializerSettings</span><span class="sxs-lookup"><span data-stu-id="8c987-156">CA2327: Do not use insecure JsonSerializerSettings</span></span>](ca2327.md)|<span data-ttu-id="8c987-157">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-157">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-158">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-158">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-159">CA2328：确保 JsonSerializerSettings 是安全的</span><span class="sxs-lookup"><span data-stu-id="8c987-159">CA2328: Ensure that JsonSerializerSettings are secure</span></span>](ca2328.md)|<span data-ttu-id="8c987-160">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-160">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-161">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-161">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-162">CA2329：不要使用不安全的配置反序列化 JsonSerializer</span><span class="sxs-lookup"><span data-stu-id="8c987-162">CA2329: Do not deserialize with JsonSerializer using an insecure configuration</span></span>](ca2329.md)|<span data-ttu-id="8c987-163">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-163">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-164">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-164">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-165">CA2330：在反序列化时确保 JsonSerializer 具有安全配置</span><span class="sxs-lookup"><span data-stu-id="8c987-165">CA2330: Ensure that JsonSerializer has a secure configuration when deserializing</span></span>](ca2330.md)|<span data-ttu-id="8c987-166">反序列化不受信任的数据时，不安全的反会很容易</span><span class="sxs-lookup"><span data-stu-id="8c987-166">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="8c987-167">攻击者可能会修改序列化的数据，使其包含意外类型，以注入具有恶意副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="8c987-167">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="8c987-168">CA2350:确保 DataTable.ReadXml() 的输入受信任</span><span class="sxs-lookup"><span data-stu-id="8c987-168">CA2350: Ensure DataTable.ReadXml()'s input is trusted</span></span>](ca2350.md)|<span data-ttu-id="8c987-169"><xref:System.Data.DataTable>使用不受信任的输入反序列化时，攻击者可以创建恶意输入来执行拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-169">When deserializing a <xref:System.Data.DataTable> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="8c987-170">可能存在未知的远程代码执行漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-170">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="8c987-171">CA2351:确保 DataSet.ReadXml() 的输入受信任</span><span class="sxs-lookup"><span data-stu-id="8c987-171">CA2351: Ensure DataSet.ReadXml()'s input is trusted</span></span>](ca2351.md)|<span data-ttu-id="8c987-172"><xref:System.Data.DataSet>使用不受信任的输入反序列化时，攻击者可以创建恶意输入来执行拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-172">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="8c987-173">可能存在未知的远程代码执行漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-173">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="8c987-174">CA2352:可序列化类型中的不安全 DataSet 或 DataTable 容易受到远程代码执行攻击</span><span class="sxs-lookup"><span data-stu-id="8c987-174">CA2352: Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</span></span>](ca2352.md)|<span data-ttu-id="8c987-175">标记为的类或结构 <xref:System.SerializableAttribute> 包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 字段或属性，但不具有 <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="8c987-175">A class or struct marked with <xref:System.SerializableAttribute> contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property, and doesn't have a <xref:System.CodeDom.Compiler.GeneratedCodeAttribute>.</span></span>|
|[<span data-ttu-id="8c987-176">CA2353:可序列化类型中的不安全 DataSet 或 DataTable</span><span class="sxs-lookup"><span data-stu-id="8c987-176">CA2353: Unsafe DataSet or DataTable in serializable type</span></span>](ca2353.md)|<span data-ttu-id="8c987-177">用 XML 序列化特性或数据协定特性标记的类或结构包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 字段或属性。</span><span class="sxs-lookup"><span data-stu-id="8c987-177">A class or struct marked with an XML serialization attribute or a data contract attribute contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property.</span></span>|
|[<span data-ttu-id="8c987-178">CA2354:反序列化对象图中的不安全 DataSet 或 DataTable 可能容易受到远程代码执行攻击</span><span class="sxs-lookup"><span data-stu-id="8c987-178">CA2354: Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attack</span></span>](ca2354.md)|<span data-ttu-id="8c987-179">使用序列化进行反序列化 <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> ，强制转换类型的对象图可以包括 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 。</span><span class="sxs-lookup"><span data-stu-id="8c987-179">Deserializing with an <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serialized, and the casted type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="8c987-180">CA2355:反序列化对象图中的不安全 DataSet 或 DataTable</span><span class="sxs-lookup"><span data-stu-id="8c987-180">CA2355: Unsafe DataSet or DataTable in deserialized object graph</span></span>](ca2355.md)|<span data-ttu-id="8c987-181">当强制转换或指定类型的对象图可以包含或时进行反序列化 <xref:System.Data.DataSet> <xref:System.Data.DataTable> 。</span><span class="sxs-lookup"><span data-stu-id="8c987-181">Deserializing when the casted or specified type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="8c987-182">CA2356： web 反序列化对象图中的不安全数据集或 DataTable</span><span class="sxs-lookup"><span data-stu-id="8c987-182">CA2356: Unsafe DataSet or DataTable in web deserialized object graph</span></span>](ca2356.md)|<span data-ttu-id="8c987-183">具有或的方法 <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> 具有可引用或的参数 <xref:System.Data.DataSet> <xref:System.Data.DataTable> 。</span><span class="sxs-lookup"><span data-stu-id="8c987-183">A method with a <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> or <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> has a parameter that may reference a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="8c987-184">CA2361：请确保包含 DataSet.ReadXml() 的自动生成的类没有与不受信任的数据一起使用</span><span class="sxs-lookup"><span data-stu-id="8c987-184">CA2361: Ensure autogenerated class containing DataSet.ReadXml() is not used with untrusted data</span></span>](ca2361.md)|<span data-ttu-id="8c987-185"><xref:System.Data.DataSet>使用不受信任的输入反序列化时，攻击者可以创建恶意输入来执行拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-185">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="8c987-186">可能存在未知的远程代码执行漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-186">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="8c987-187">CA2362：自动生成的可序列化类型中不安全的数据集或数据表易受远程代码执行攻击</span><span class="sxs-lookup"><span data-stu-id="8c987-187">CA2362: Unsafe DataSet or DataTable in autogenerated serializable type can be vulnerable to remote code execution attacks</span></span>](ca2362.md)|<span data-ttu-id="8c987-188">当反序列化的不受信任的输入 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 并且反序列化的对象图包含 <xref:System.Data.DataSet> 或时 <xref:System.Data.DataTable> ，攻击者可以创建恶意有效负载来执行远程代码执行攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-188">When deserializing untrusted input with <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the deserialized object graph contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>, an attacker can craft a malicious payload to perform a remote code execution attack.</span></span>|
|[<span data-ttu-id="8c987-189">CA3001：查看 SQL 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-189">CA3001: Review code for SQL injection vulnerabilities</span></span>](ca3001.md)|<span data-ttu-id="8c987-190">使用不受信任的输入和 SQL 命令时，请注意 SQL 注入攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-190">When working with untrusted input and SQL commands, be mindful of SQL injection attacks.</span></span> <span data-ttu-id="8c987-191">SQL 注入攻击可以执行恶意的 SQL 命令，从而降低应用程序的安全性和完整性。</span><span class="sxs-lookup"><span data-stu-id="8c987-191">An SQL injection attack can execute malicious SQL commands, compromising the security and integrity of your application.</span></span>|
|[<span data-ttu-id="8c987-192">CA3002：查看 XSS 漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-192">CA3002: Review code for XSS vulnerabilities</span></span>](ca3002.md)|<span data-ttu-id="8c987-193">处理 web 请求中的不受信任输入时，请注意跨站点脚本 (XSS) 攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-193">When working with untrusted input from web requests, be mindful of cross-site scripting (XSS) attacks.</span></span> <span data-ttu-id="8c987-194">XSS 攻击会将不受信任的输入注入原始 HTML 输出，使攻击者可以执行恶意脚本或恶意修改网页中的内容。</span><span class="sxs-lookup"><span data-stu-id="8c987-194">An XSS attack injects untrusted input into raw HTML output, allowing the attacker to execute malicious scripts or maliciously modify content in your web page.</span></span>|
|[<span data-ttu-id="8c987-195">CA3003:查看文件路径注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-195">CA3003: Review code for file path injection vulnerabilities</span></span>](ca3003.md)|<span data-ttu-id="8c987-196">当处理 web 请求中的不受信任输入时，请注意在指定文件路径时使用用户控制输入。</span><span class="sxs-lookup"><span data-stu-id="8c987-196">When working with untrusted input from web requests, be mindful of using user-controlled input when specifying paths to files.</span></span>|
|[<span data-ttu-id="8c987-197">CA3004：查看信息泄露漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-197">CA3004: Review code for information disclosure vulnerabilities</span></span>](ca3004.md)|<span data-ttu-id="8c987-198">泄露异常信息可让攻击者深入了解应用程序的内部机制，从而帮助攻击者找到其他漏洞来利用这些漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-198">Disclosing exception information gives attackers insight into the internals of your application, which can help attackers find other vulnerabilities to exploit.</span></span>|
|[<span data-ttu-id="8c987-199">CA3006：查看进程命令注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-199">CA3006: Review code for process command injection vulnerabilities</span></span>](ca3006.md)|<span data-ttu-id="8c987-200">使用不受信任的输入时，请注意命令注入攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-200">When working with untrusted input, be mindful of command injection attacks.</span></span> <span data-ttu-id="8c987-201">命令注入攻击可以在基础操作系统上执行恶意命令，从而危及服务器的安全和完整性。</span><span class="sxs-lookup"><span data-stu-id="8c987-201">A command injection attack can execute malicious commands on the underlying operating system, compromising the security and integrity of your server.</span></span>|
|[<span data-ttu-id="8c987-202">CA3007：查看公开重定向漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-202">CA3007: Review code for open redirect vulnerabilities</span></span>](ca3007.md)|<span data-ttu-id="8c987-203">使用不受信任的输入时，请注意开放重定向漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-203">When working with untrusted input, be mindful of open redirect vulnerabilities.</span></span> <span data-ttu-id="8c987-204">攻击者可以利用开放的重定向漏洞来使用您的网站来获得合法 URL 的外观，但将不受信任的访问者重定向到仿冒网站或其他恶意网页。</span><span class="sxs-lookup"><span data-stu-id="8c987-204">An attacker can exploit an open redirect vulnerability to use your website to give the appearance of a legitimate URL, but redirect an unsuspecting visitor to a phishing or other malicious webpage.</span></span>|
|[<span data-ttu-id="8c987-205">CA3008：查看 XPath 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-205">CA3008: Review code for XPath injection vulnerabilities</span></span>](ca3008.md)|<span data-ttu-id="8c987-206">使用不受信任的输入时，请注意 XPath 注入式攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-206">When working with untrusted input, be mindful of XPath injection attacks.</span></span> <span data-ttu-id="8c987-207">使用不受信任输入构造 XPath 查询时，攻击者可能会恶意地操作查询以返回意外的结果，并可能会泄漏所查询的 XML 的内容。</span><span class="sxs-lookup"><span data-stu-id="8c987-207">Constructing XPath queries using untrusted input may allow an attacker to maliciously manipulate the query to return an unintended result, and possibly disclose the contents of the queried XML.</span></span>|
|[<span data-ttu-id="8c987-208">CA3009：查看 XML 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-208">CA3009: Review code for XML injection vulnerabilities</span></span>](ca3009.md)|<span data-ttu-id="8c987-209">使用不受信任的输入时，请注意 XML 注入攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-209">When working with untrusted input, be mindful of XML injection attacks.</span></span>|
|[<span data-ttu-id="8c987-210">CA3010：查看 XAML 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-210">CA3010: Review code for XAML injection vulnerabilities</span></span>](ca3010.md)|<span data-ttu-id="8c987-211">使用不受信任的输入时，请注意 XAML 注入攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-211">When working with untrusted input, be mindful of XAML injection attacks.</span></span> <span data-ttu-id="8c987-212">XAML 是一种直接表示对象实例化和执行的标记语言。</span><span class="sxs-lookup"><span data-stu-id="8c987-212">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="8c987-213">这意味着在 XAML 中创建的元素可以与系统资源交互 (例如，网络访问和文件系统 IO) 。</span><span class="sxs-lookup"><span data-stu-id="8c987-213">That means elements created in XAML can interact with system resources (for example, network access and file system IO).</span></span>|
|[<span data-ttu-id="8c987-214">CA3011：查看 DLL 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-214">CA3011: Review code for DLL injection vulnerabilities</span></span>](ca3011.md)|<span data-ttu-id="8c987-215">使用不受信任的输入时，请注意加载不受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="8c987-215">When working with untrusted input, be mindful of loading untrusted code.</span></span> <span data-ttu-id="8c987-216">如果你的 web 应用程序加载不受信任的代码，攻击者可能能够将恶意 Dll 注入到你的进程中并执行恶意代码。</span><span class="sxs-lookup"><span data-stu-id="8c987-216">If your web application loads untrusted code, an attacker may be able to inject malicious DLLs into your process and execute malicious code.</span></span>|
|[<span data-ttu-id="8c987-217">CA3012：查看正则表达式注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="8c987-217">CA3012: Review code for regex injection vulnerabilities</span></span>](ca3012.md)|<span data-ttu-id="8c987-218">使用不受信任的输入时，请注意 regex 注入式攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-218">When working with untrusted input, be mindful of regex injection attacks.</span></span> <span data-ttu-id="8c987-219">攻击者可以使用 regex 注入来恶意地修改正则表达式，以使 regex 与意外结果匹配，或使 regex 消耗过多的 CPU，导致拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-219">An attacker can use regex injection to maliciously modify a regular expression, to make the regex match unintended results, or to make the regex consume excessive CPU resulting in a Denial of Service attack.</span></span>|
|[<span data-ttu-id="8c987-220">CA3061：请勿按 URL 添加架构</span><span class="sxs-lookup"><span data-stu-id="8c987-220">CA3061: Do not add schema by URL</span></span>](ca3061.md)|<span data-ttu-id="8c987-221">不要使用 Add 方法的 unsafe 重载，因为这可能会导致危险的外部引用。</span><span class="sxs-lookup"><span data-stu-id="8c987-221">Do not use the unsafe overload of the Add method because it may cause dangerous external references.</span></span>|
|[<span data-ttu-id="8c987-222">CA3075:不安全的 DTD 处理</span><span class="sxs-lookup"><span data-stu-id="8c987-222">CA3075: Insecure DTD Processing</span></span>](ca3075.md)|<span data-ttu-id="8c987-223">如果使用不安全的 DTDProcessing 实例或引用外部实体源，分析器可能会接受不受信任的输入并将敏感信息泄露给攻击者。</span><span class="sxs-lookup"><span data-stu-id="8c987-223">If you use insecure DTDProcessing instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.</span></span>|
|[<span data-ttu-id="8c987-224">CA3076:不安全的 XSLT 脚本执行</span><span class="sxs-lookup"><span data-stu-id="8c987-224">CA3076: Insecure XSLT Script Execution</span></span>](ca3076.md)|<span data-ttu-id="8c987-225">如果 (XSLT) 在 .NET 应用程序不安全地中执行可扩展样式表语言转换，则处理器可能会解析可能向攻击者泄露敏感信息的不受信任的 URI 引用，从而导致拒绝服务和跨站点攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-225">If you execute Extensible StyleSheet Language Transformations (XSLT) in .NET applications insecurely, the processor may resolve untrusted URI references that could disclose sensitive information to attackers, leading to Denial of Service and Cross-Site attacks.</span></span>|
|[<span data-ttu-id="8c987-226">CA3077:API 设计、XML 文档和 XML 文本读取器中的不安全处理</span><span class="sxs-lookup"><span data-stu-id="8c987-226">CA3077: Insecure Processing in API Design, XML Document and XML Text Reader</span></span>](ca3077.md)|<span data-ttu-id="8c987-227">当设计派生自 XMLDocument 和 XMLTextReader 的 API 时，请注意 DtdProcessing。</span><span class="sxs-lookup"><span data-stu-id="8c987-227">When designing an API derived from XMLDocument and XMLTextReader, be mindful of DtdProcessing.</span></span> <span data-ttu-id="8c987-228">当引用或解析外部实体源或设置 XML 中的不安全值时，使用不安全的 DTDProcessing 实例可能会导致信息泄露。</span><span class="sxs-lookup"><span data-stu-id="8c987-228">Using insecure DTDProcessing instances when referencing or resolving external entity sources or setting insecure values in the XML may lead to information disclosure.</span></span>|
|[<span data-ttu-id="8c987-229">CA3147:使用 ValidateAntiForgeryToken 标记谓词处理程序</span><span class="sxs-lookup"><span data-stu-id="8c987-229">CA3147: Mark verb handlers with ValidateAntiForgeryToken</span></span>](ca3147.md)|<span data-ttu-id="8c987-230">设计 ASP.NET MVC 控制器时，请注意跨站点请求伪造攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-230">When designing an ASP.NET MVC controller, be mindful of cross-site request forgery attacks.</span></span> <span data-ttu-id="8c987-231">跨站点请求伪造攻击可以将经过身份验证的用户的恶意请求发送到 ASP.NET MVC 控制器。</span><span class="sxs-lookup"><span data-stu-id="8c987-231">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET MVC controller.</span></span>|
|[<span data-ttu-id="8c987-232">CA5350:请勿使用弱加密算法</span><span class="sxs-lookup"><span data-stu-id="8c987-232">CA5350: Do Not Use Weak Cryptographic Algorithms</span></span>](ca5350.md)|<span data-ttu-id="8c987-233">出于多种原因，现今使用弱加密算法和哈希函数，但不应使用它们来保证保密性或它们所保护的数据的完整性。</span><span class="sxs-lookup"><span data-stu-id="8c987-233">Weak encryption algorithms and hashing functions are used today for a number of reasons, but they should not be used to guarantee the confidentiality or integrity of the data they protect.</span></span> <span data-ttu-id="8c987-234">当此规则在代码中找到 TripleDES、SHA1、或 RIPEMD160 算法时，此规则将触发。</span><span class="sxs-lookup"><span data-stu-id="8c987-234">This rule triggers when it finds TripleDES, SHA1, or RIPEMD160 algorithms in the code.</span></span>|
|[<span data-ttu-id="8c987-235">CA5351：不要使用损坏的加密算法</span><span class="sxs-lookup"><span data-stu-id="8c987-235">CA5351: Do Not Use Broken Cryptographic Algorithms</span></span>](ca5351.md)|<span data-ttu-id="8c987-236">损坏的加密算法不安全，强烈建议不要使用。</span><span class="sxs-lookup"><span data-stu-id="8c987-236">Broken cryptographic algorithms are not considered secure and their use should be strongly discouraged.</span></span> <span data-ttu-id="8c987-237">当此规则在代码中找到 MD5 哈希算法，或者 DES 或 RC2 加密算法时，此规则将触发。</span><span class="sxs-lookup"><span data-stu-id="8c987-237">This rule triggers when it finds the MD5 hash algorithm or either the DES or RC2 encryption algorithms in code.</span></span>|
|[<span data-ttu-id="8c987-238">CA5358：请勿使用不安全的密码模式</span><span class="sxs-lookup"><span data-stu-id="8c987-238">CA5358: Do Not Use Unsafe Cipher Modes</span></span>](ca5358.md)|<span data-ttu-id="8c987-239">请勿使用不安全的密码模式</span><span class="sxs-lookup"><span data-stu-id="8c987-239">Do Not Use Unsafe Cipher Modes</span></span>|
|[<span data-ttu-id="8c987-240">CA5359:请勿禁用证书验证</span><span class="sxs-lookup"><span data-stu-id="8c987-240">CA5359: Do not disable certificate validation</span></span>](ca5359.md)|<span data-ttu-id="8c987-241">证书可以帮助验证服务器的身份。</span><span class="sxs-lookup"><span data-stu-id="8c987-241">A certificate can help authenticate the identity of the server.</span></span> <span data-ttu-id="8c987-242">客户端应验证服务器证书，以确保将请求发送到目标服务器。</span><span class="sxs-lookup"><span data-stu-id="8c987-242">Clients should validate the server certificate to ensure requests are sent to the intended server.</span></span> <span data-ttu-id="8c987-243">如果 Servicepointmanager.servercertificatevalidationcallback 始终返回 `true` ，则任何证书将通过验证。</span><span class="sxs-lookup"><span data-stu-id="8c987-243">If the ServerCertificateValidationCallback always returns `true`, any certificate will pass validation.</span></span>|
|[<span data-ttu-id="8c987-244">CA5360:在反序列化中不要调用危险的方法</span><span class="sxs-lookup"><span data-stu-id="8c987-244">CA5360: Do not call dangerous methods in deserialization</span></span>](ca5360.md)|<span data-ttu-id="8c987-245">不受信任的反序列化是指使用不受信任的数据来滥用应用程序的逻辑，导致拒绝服务 (DoS) 攻击，甚至是在反序列化时执行任意代码时出现的漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-245">Insecure deserialization is a vulnerability that occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized.</span></span> <span data-ttu-id="8c987-246">当应用程序对其控制的不受信任的数据进行反序列化时，通常可能会有恶意用户滥用这些反序列化功能。</span><span class="sxs-lookup"><span data-stu-id="8c987-246">It's frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data that is under their control.</span></span> <span data-ttu-id="8c987-247">具体而言，就是在反序列化过程中调用危险方法。</span><span class="sxs-lookup"><span data-stu-id="8c987-247">Specifically, invoke dangerous methods in the process of deserialization.</span></span> <span data-ttu-id="8c987-248">成功的反反序列化攻击可能会允许攻击者发起攻击，如 DoS 攻击、身份验证绕过和远程代码执行。</span><span class="sxs-lookup"><span data-stu-id="8c987-248">Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</span></span>|
|[<span data-ttu-id="8c987-249">CA5361：不禁止 SChannel 使用强加密</span><span class="sxs-lookup"><span data-stu-id="8c987-249">CA5361: Do not disable SChannel use of strong crypto</span></span>](ca5361.md)|<span data-ttu-id="8c987-250">设置 `Switch.System.Net.DontEnableSchUseStrongCrypto` 为 `true` 受损传出传输层安全性 (TLS) 连接中使用的加密。</span><span class="sxs-lookup"><span data-stu-id="8c987-250">Setting `Switch.System.Net.DontEnableSchUseStrongCrypto` to `true` weakens the cryptography used in outgoing Transport Layer Security (TLS) connections.</span></span> <span data-ttu-id="8c987-251">较弱的加密可能会危及应用程序与服务器之间通信的机密性，使攻击者更容易窃听敏感数据。</span><span class="sxs-lookup"><span data-stu-id="8c987-251">Weaker cryptography can compromise the confidentiality of communication between your application and the server, making it easier for attackers to eavesdrop sensitive data.</span></span>|
|[<span data-ttu-id="8c987-252">CA5362:反序列化对象图中存在潜在引用循环</span><span class="sxs-lookup"><span data-stu-id="8c987-252">CA5362: Potential reference cycle in deserialized object graph</span></span>](ca5362.md)|<span data-ttu-id="8c987-253">如果反序列化不受信任的数据，则处理反序列化对象图的任何代码都需要处理引用循环，而不会进入无限循环。</span><span class="sxs-lookup"><span data-stu-id="8c987-253">If deserializing untrusted data, then any code processing the deserialized object graph needs to handle reference cycles without going into infinite loops.</span></span> <span data-ttu-id="8c987-254">这包括作为反序列化回调一部分的代码和在反序列化完成后处理对象图的代码。</span><span class="sxs-lookup"><span data-stu-id="8c987-254">This includes both code that's part of a deserialization callback and code that processes the object graph after deserialization completed.</span></span> <span data-ttu-id="8c987-255">否则，攻击者可能会对包含引用周期的恶意数据执行拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-255">Otherwise, an attacker could perform a Denial-of-Service attack with malicious data containing a reference cycle.</span></span>|
|[<span data-ttu-id="8c987-256">CA5363：请勿禁用请求验证</span><span class="sxs-lookup"><span data-stu-id="8c987-256">CA5363: Do not disable request validation</span></span>](ca5363.md)|<span data-ttu-id="8c987-257">请求验证是 ASP.NET 中的一项功能，用于检查 HTTP 请求并确定这些请求是否包含可能导致注入攻击（包括跨站点脚本）的潜在危险内容。</span><span class="sxs-lookup"><span data-stu-id="8c987-257">Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content that can lead to injection attacks, including cross-site-scripting.</span></span>|
|[<span data-ttu-id="8c987-258">CA5364：不使用已弃用的安全协议</span><span class="sxs-lookup"><span data-stu-id="8c987-258">CA5364: Do not use deprecated security protocols</span></span>](ca5364.md)|<span data-ttu-id="8c987-259">传输层安全 (TLS) 保护计算机之间的通信，最常见的是通过超文本传输协议安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="8c987-259">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="8c987-260">较早的 TLS 协议版本不如 TLS 1.2 和 TLS 1.3 安全，更有可能出现新的漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-260">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="8c987-261">避免旧协议版本来最大程度地降低风险。</span><span class="sxs-lookup"><span data-stu-id="8c987-261">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="8c987-262">CA5365:请勿禁用 HTTP 头检查</span><span class="sxs-lookup"><span data-stu-id="8c987-262">CA5365: Do Not Disable HTTP Header Checking</span></span>](ca5365.md)|<span data-ttu-id="8c987-263">HTTP 标头检查启用在响应标头中找到的回车符和换行符（\r 和 \n）的编码。</span><span class="sxs-lookup"><span data-stu-id="8c987-263">HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers.</span></span> <span data-ttu-id="8c987-264">这种编码有助于避免注入攻击，攻击者利用该应用程序回显了标头中包含的不受信任的数据。</span><span class="sxs-lookup"><span data-stu-id="8c987-264">This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</span></span>|
|[<span data-ttu-id="8c987-265">CA5366:将 XmlReader 用于数据集读取 XML</span><span class="sxs-lookup"><span data-stu-id="8c987-265">CA5366: Use XmlReader For DataSet Read XML</span></span>](ca5366.md)|<span data-ttu-id="8c987-266">使用 <xref:System.Data.DataSet> 读取包含不受信任数据的 XML 可能会加载危险的外部引用，应使用 <xref:System.Xml.XmlReader> 具有安全解析程序或禁用 DTD 处理的进行限制。</span><span class="sxs-lookup"><span data-stu-id="8c987-266">Using a <xref:System.Data.DataSet> to read XML with untrusted data may load dangerous external references, which should be restricted by using an <xref:System.Xml.XmlReader> with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="8c987-267">CA5367:请勿序列化具有 Pointer 字段的类型</span><span class="sxs-lookup"><span data-stu-id="8c987-267">CA5367: Do Not Serialize Types With Pointer Fields</span></span>](ca5367.md)|<span data-ttu-id="8c987-268">此规则检查是否存在具有指针字段或属性的可序列化类。</span><span class="sxs-lookup"><span data-stu-id="8c987-268">This rule checks whether there's a serializable class with a pointer field or property.</span></span> <span data-ttu-id="8c987-269">无法序列化的成员可以是指针，如使用标记的静态成员或字段 <xref:System.NonSerializedAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="8c987-269">Members that can't be serialized can be a pointer, such as static members or fields marked with <xref:System.NonSerializedAttribute>.</span></span>|
|[<span data-ttu-id="8c987-270">CA5368:针对派生自 Page 的类设置 ViewStateUserKey</span><span class="sxs-lookup"><span data-stu-id="8c987-270">CA5368: Set ViewStateUserKey For Classes Derived From Page</span></span>](ca5368.md)|<span data-ttu-id="8c987-271">设置 <xref:System.Web.UI.Page.ViewStateUserKey> 属性可帮助您阻止对应用程序的攻击，方法是允许您为个别用户分配视图状态变量的标识符，使攻击者无法使用该变量生成攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-271">Setting the <xref:System.Web.UI.Page.ViewStateUserKey> property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that attackers cannot use the variable to generate an attack.</span></span> <span data-ttu-id="8c987-272">否则，会出现跨站点请求伪造的漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-272">Otherwise, there will be vulnerabilities to cross-site request forgery.</span></span>|
|[<span data-ttu-id="8c987-273">CA5369：将 XmlReader 用于反序列化</span><span class="sxs-lookup"><span data-stu-id="8c987-273">CA5369: Use XmlReader for Deserialize</span></span>](ca5369.md)|<span data-ttu-id="8c987-274">处理不受信任的 DTD 和 XML 架构可能会启用加载危险的外部引用，这应通过使用具有安全解析程序的 XmlReader 或禁用 DTD 和 XML 内联架构处理来限制。</span><span class="sxs-lookup"><span data-stu-id="8c987-274">Processing untrusted DTD and XML schemas may enable loading dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="8c987-275">CA5370：将 XmlReader 用于验证读取器</span><span class="sxs-lookup"><span data-stu-id="8c987-275">CA5370: Use XmlReader for validating reader</span></span>](ca5370.md)|<span data-ttu-id="8c987-276">处理不受信任的 DTD 和 XML 架构可能会启用加载危险的外部引用。</span><span class="sxs-lookup"><span data-stu-id="8c987-276">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="8c987-277">可以通过将 XmlReader 与安全解析程序结合使用，或者禁用 DTD 和 XML 内联架构处理来限制这种危险加载。</span><span class="sxs-lookup"><span data-stu-id="8c987-277">This dangerous loading can be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="8c987-278">CA5371：将 XmlReader 用于架构读取</span><span class="sxs-lookup"><span data-stu-id="8c987-278">CA5371: Use XmlReader for schema read</span></span>](ca5371.md)|<span data-ttu-id="8c987-279">处理不受信任的 DTD 和 XML 架构可能会启用加载危险的外部引用。</span><span class="sxs-lookup"><span data-stu-id="8c987-279">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="8c987-280">将 XmlReader 用于安全解析程序或 DTD 和 XML 内联架构处理将会限制这种情况。</span><span class="sxs-lookup"><span data-stu-id="8c987-280">Using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled restricts this.</span></span>|
|[<span data-ttu-id="8c987-281">CA5372：将 XmlReader 用于 XPathDocument</span><span class="sxs-lookup"><span data-stu-id="8c987-281">CA5372: Use XmlReader for XPathDocument</span></span>](ca5372.md)|<span data-ttu-id="8c987-282">处理来自不受信任数据的 XML 可能会加载危险的外部引用，这可以通过使用具有安全解析程序的 XmlReader 或禁用 DTD 处理来限制。</span><span class="sxs-lookup"><span data-stu-id="8c987-282">Processing XML from untrusted data may load dangerous external references, which can be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="8c987-283">CA5373：请勿使用已过时的密钥派生功能</span><span class="sxs-lookup"><span data-stu-id="8c987-283">CA5373: Do not use obsolete key derivation function</span></span>](ca5373.md)|<span data-ttu-id="8c987-284">此规则检测弱密钥派生方法和的调用 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> `Rfc2898DeriveBytes.CryptDeriveKey` 。</span><span class="sxs-lookup"><span data-stu-id="8c987-284">This rule detects the invocation of weak key derivation methods <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> and `Rfc2898DeriveBytes.CryptDeriveKey`.</span></span> <span data-ttu-id="8c987-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> 使用弱算法 PBKDF1。</span><span class="sxs-lookup"><span data-stu-id="8c987-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> used a weak algorithm PBKDF1.</span></span>|
|[<span data-ttu-id="8c987-286">CA5374:请勿使用 XslTransform</span><span class="sxs-lookup"><span data-stu-id="8c987-286">CA5374: Do Not Use XslTransform</span></span>](ca5374.md)|<span data-ttu-id="8c987-287">此规则检查 <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 是否在代码中实例化。</span><span class="sxs-lookup"><span data-stu-id="8c987-287">This rule checks if <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is instantiated in the code.</span></span> <span data-ttu-id="8c987-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 现已过时，不应使用。</span><span class="sxs-lookup"><span data-stu-id="8c987-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is now obsolete and shouldn't be used.</span></span>|
|[<span data-ttu-id="8c987-289">CA5375:请勿使用帐户共享访问签名</span><span class="sxs-lookup"><span data-stu-id="8c987-289">CA5375: Do not use account shared access signature</span></span>](ca5375.md)|<span data-ttu-id="8c987-290">帐户 SAS 可委派对 blob 容器、表、队列以及服务 SAS 不允许的文件共享上的读取、写入和删除操作的访问权限。</span><span class="sxs-lookup"><span data-stu-id="8c987-290">An account SAS can delegate access to read, write, and delete operations on blob containers, tables, queues, and file shares that are not permitted with a service SAS.</span></span> <span data-ttu-id="8c987-291">但是，它不支持容器级别的策略，并且具有较低的灵活性和对所授予权限的控制权限。</span><span class="sxs-lookup"><span data-stu-id="8c987-291">However, it doesn't support container-level policies and has less flexibility and control over the permissions that are granted.</span></span> <span data-ttu-id="8c987-292">一旦恶意用户获得，您的存储帐户就会容易泄露。</span><span class="sxs-lookup"><span data-stu-id="8c987-292">Once malicious users get it, your storage account will be compromised easily.</span></span>|
|[<span data-ttu-id="8c987-293">CA5376:使用 SharedAccessProtocol HttpsOnly</span><span class="sxs-lookup"><span data-stu-id="8c987-293">CA5376: Use SharedAccessProtocol HttpsOnly</span></span>](ca5376.md)|<span data-ttu-id="8c987-294">SAS 是不能以纯文本形式在 HTTP 上传输的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="8c987-294">SAS is sensitive data that can't be transported in plain text on HTTP.</span></span>|
|[<span data-ttu-id="8c987-295">CA5377:使用容器级别访问策略</span><span class="sxs-lookup"><span data-stu-id="8c987-295">CA5377: Use container level access policy</span></span>](ca5377.md)|<span data-ttu-id="8c987-296">容器级别的访问策略可以随时修改或撤消。</span><span class="sxs-lookup"><span data-stu-id="8c987-296">A container-level access policy can be modified or revoked at any time.</span></span> <span data-ttu-id="8c987-297">它提供了更大的灵活性并控制授予的权限。</span><span class="sxs-lookup"><span data-stu-id="8c987-297">It provides greater flexibility and control over the permissions that are granted.</span></span>|
|[<span data-ttu-id="8c987-298">CA5378：不禁用 ServicePointManagerSecurityProtocols</span><span class="sxs-lookup"><span data-stu-id="8c987-298">CA5378: Do not disable ServicePointManagerSecurityProtocols</span></span>](ca5378.md)|<span data-ttu-id="8c987-299">设置 `DisableUsingServicePointManagerSecurityProtocols` 以 `true` 限制 Windows Communication FRAMEWORK (WCF) 传输层安全 (tls) 与使用 tls 1.0 的连接。</span><span class="sxs-lookup"><span data-stu-id="8c987-299">Setting `DisableUsingServicePointManagerSecurityProtocols` to `true` limits Windows Communication Framework's (WCF) Transport Layer Security (TLS) connections to using TLS 1.0.</span></span> <span data-ttu-id="8c987-300">TLS 版本将不推荐使用。</span><span class="sxs-lookup"><span data-stu-id="8c987-300">That version of TLS will be deprecated.</span></span>|
|[<span data-ttu-id="8c987-301">CA5379：确保密钥派生函数算法足够强</span><span class="sxs-lookup"><span data-stu-id="8c987-301">CA5379: Ensure key derivation function algorithm is sufficiently strong</span></span>](ca5379.md)|<span data-ttu-id="8c987-302"><xref:System.Security.Cryptography.Rfc2898DeriveBytes>类默认使用 <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> 算法。</span><span class="sxs-lookup"><span data-stu-id="8c987-302">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class defaults to using the <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorithm.</span></span> <span data-ttu-id="8c987-303">应指定要在具有 <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> 或更高版本的构造函数的某些重载中使用的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="8c987-303">You should specify the hash algorithm to use in some overloads of the constructor with <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> or higher.</span></span> <span data-ttu-id="8c987-304">请注意， <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> 属性仅具有 `get` 访问器，没有 `overriden` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="8c987-304">Note, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> property only has a `get` accessor and doesn't have a `overriden` modifier.</span></span>|
|[<span data-ttu-id="8c987-305">CA5380：请勿将证书添加到根存储中</span><span class="sxs-lookup"><span data-stu-id="8c987-305">CA5380: Do not add certificates to root store</span></span>](ca5380.md)|<span data-ttu-id="8c987-306">此规则检测将证书添加到 "受信任的根证书颁发机构" 证书存储中的代码。</span><span class="sxs-lookup"><span data-stu-id="8c987-306">This rule detects code that adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="8c987-307">默认情况下，"受信任的根证书颁发机构" 证书存储区配置为满足 Microsoft 根证书计划要求的一组公共 Ca。</span><span class="sxs-lookup"><span data-stu-id="8c987-307">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="8c987-308">CA5381：请确保证书未添加到根存储中</span><span class="sxs-lookup"><span data-stu-id="8c987-308">CA5381: Ensure certificates are not added to root store</span></span>](ca5381.md)|<span data-ttu-id="8c987-309">此规则检测可能会将证书添加到 "受信任的根证书颁发机构" 证书存储中的代码。</span><span class="sxs-lookup"><span data-stu-id="8c987-309">This rule detects code that potentially adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="8c987-310">默认情况下，"受信任的根证书颁发机构" 证书存储区配置了一组公共证书颁发机构 (Ca) 满足 Microsoft 根证书计划的要求。</span><span class="sxs-lookup"><span data-stu-id="8c987-310">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public certification authorities (CAs) that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="8c987-311">CA5382:在 ASP.NET Core 中使用安全 Cookie</span><span class="sxs-lookup"><span data-stu-id="8c987-311">CA5382: Use secure cookies in ASP.NET Core</span></span>](ca5382.md)|<span data-ttu-id="8c987-312">通过 HTTPS 提供的应用程序必须使用安全 cookie，这向浏览器指示，cookie 只应使用传输层安全性 (TLS) 传输。</span><span class="sxs-lookup"><span data-stu-id="8c987-312">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="8c987-313">CA5383:确保在 ASP.NET Core 中使用安全 Cookie</span><span class="sxs-lookup"><span data-stu-id="8c987-313">CA5383: Ensure use secure cookies in ASP.NET Core</span></span>](ca5383.md)|<span data-ttu-id="8c987-314">通过 HTTPS 提供的应用程序必须使用安全 cookie，这向浏览器指示，cookie 只应使用传输层安全性 (TLS) 传输。</span><span class="sxs-lookup"><span data-stu-id="8c987-314">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="8c987-315">CA5384:不使用数字签名算法(DSA)</span><span class="sxs-lookup"><span data-stu-id="8c987-315">CA5384: Do not use digital signature algorithm (DSA)</span></span>](ca5384.md)|<span data-ttu-id="8c987-316">DSA 是弱非对称加密算法。</span><span class="sxs-lookup"><span data-stu-id="8c987-316">DSA is a weak asymmetric encryption algorithm.</span></span>|
|[<span data-ttu-id="8c987-317">CA5385:设置具有足够密钥大小的 Rivest–Shamir–Adleman (RSA)算法</span><span class="sxs-lookup"><span data-stu-id="8c987-317">CA5385: Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size</span></span>](ca5385.md)|<span data-ttu-id="8c987-318">小于2048位的 RSA 密钥更容易受到暴力破解攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-318">An RSA key smaller than 2048 bits is more vulnerable to brute force attacks.</span></span>|
|[<span data-ttu-id="8c987-319">CA5386：避免对 SecurityProtocolType 值进行硬编码</span><span class="sxs-lookup"><span data-stu-id="8c987-319">CA5386: Avoid hardcoding SecurityProtocolType value</span></span>](ca5386.md)|<span data-ttu-id="8c987-320">传输层安全 (TLS) 保护计算机之间的通信，最常见的是通过超文本传输协议安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="8c987-320">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="8c987-321">协议 1.1 1.0 版本不推荐使用，而 TLS 1.2 和 TLS 1.3 是最新的。</span><span class="sxs-lookup"><span data-stu-id="8c987-321">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="8c987-322">未来，TLS 1.2 和 TLS 1.3 可能已弃用。</span><span class="sxs-lookup"><span data-stu-id="8c987-322">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="8c987-323">若要确保应用程序的安全性，请避免硬编码协议版本，并以至少 .NET Framework v 4.7.1 为目标。</span><span class="sxs-lookup"><span data-stu-id="8c987-323">To ensure that your application remains secure, avoid hardcoding a protocol version and target at least .NET Framework v4.7.1.</span></span>|
|[<span data-ttu-id="8c987-324">CA5387:请勿使用迭代计数不足的弱密钥派生功能</span><span class="sxs-lookup"><span data-stu-id="8c987-324">CA5387: Do not use weak key derivation function with insufficient iteration count</span></span>](ca5387.md)|<span data-ttu-id="8c987-325">此规则检查是否生成了的加密密钥 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> ，迭代次数小于100000。</span><span class="sxs-lookup"><span data-stu-id="8c987-325">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count of less than 100,000.</span></span> <span data-ttu-id="8c987-326">较高的迭代次数可帮助缓解字典攻击，尝试猜测生成的加密密钥。</span><span class="sxs-lookup"><span data-stu-id="8c987-326">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="8c987-327">CA5388:使用弱密钥派生功能时，请确保迭代计数足够大</span><span class="sxs-lookup"><span data-stu-id="8c987-327">CA5388: Ensure sufficient iteration count when using weak key derivation function</span></span>](ca5388.md)|<span data-ttu-id="8c987-328">此规则检查是否生成的加密密钥 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 带有小于100000的迭代次数。</span><span class="sxs-lookup"><span data-stu-id="8c987-328">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count that may be less than 100,000.</span></span> <span data-ttu-id="8c987-329">较高的迭代次数可帮助缓解字典攻击，尝试猜测生成的加密密钥。</span><span class="sxs-lookup"><span data-stu-id="8c987-329">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="8c987-330">CA5389：请勿将存档项的路径添加到目标文件系统路径中</span><span class="sxs-lookup"><span data-stu-id="8c987-330">CA5389: Do not add archive item's path to the target file system path</span></span>](ca5389.md)|<span data-ttu-id="8c987-331">文件路径可以是相对路径，并且可能会导致文件系统在预期的文件系统目标路径外进行访问，从而导致恶意配置更改并通过 "等待" 等方法执行远程代码。</span><span class="sxs-lookup"><span data-stu-id="8c987-331">File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</span></span>|
|[<span data-ttu-id="8c987-332">CA5390:请勿编码加密密钥</span><span class="sxs-lookup"><span data-stu-id="8c987-332">CA5390: Do not hard-code encryption key</span></span>](ca5390.md)|<span data-ttu-id="8c987-333">若要成功使用对称算法，密钥必须仅对发送方和接收方是已知的。</span><span class="sxs-lookup"><span data-stu-id="8c987-333">For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver.</span></span> <span data-ttu-id="8c987-334">当某个密钥是硬编码的，很容易发现它。</span><span class="sxs-lookup"><span data-stu-id="8c987-334">When a key is hard-coded, it is easily discovered.</span></span> <span data-ttu-id="8c987-335">即使已编译的二进制文件，恶意用户也可以轻松地将其提取出来。</span><span class="sxs-lookup"><span data-stu-id="8c987-335">Even with compiled binaries, it is easy for malicious users to extract it.</span></span> <span data-ttu-id="8c987-336">私钥泄露后，可以直接解密密码文本，而不会再对其进行保护。</span><span class="sxs-lookup"><span data-stu-id="8c987-336">Once the private key is compromised, the cipher text can be decrypted directly and is not protected anymore.</span></span>|
|[<span data-ttu-id="8c987-337">CA5391:在 ASP.NET Core MVC 控制器中使用防伪造令牌</span><span class="sxs-lookup"><span data-stu-id="8c987-337">CA5391: Use antiforgery tokens in ASP.NET Core MVC controllers</span></span>](ca5391.md)|<span data-ttu-id="8c987-338">处理 `POST` 、、 `PUT` `PATCH` 或 `DELETE` 请求而不验证防伪令牌可能易受到跨站点请求伪造攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-338">Handling a `POST`, `PUT`, `PATCH`, or `DELETE` request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks.</span></span> <span data-ttu-id="8c987-339">跨站点请求伪造攻击可以将经过身份验证的用户的恶意请求发送到 ASP.NET Core MVC 控制器。</span><span class="sxs-lookup"><span data-stu-id="8c987-339">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</span></span>|
|[<span data-ttu-id="8c987-340">CA5392:对 P/Invoke 使用 DefaultDllImportSearchPaths 属性</span><span class="sxs-lookup"><span data-stu-id="8c987-340">CA5392: Use DefaultDllImportSearchPaths attribute for P/Invokes</span></span>](ca5392.md)|<span data-ttu-id="8c987-341">默认情况下，使用探测的 P/Invoke 函数包含 <xref:System.Runtime.InteropServices.DllImportAttribute> 多个目录，其中包含要加载的库的当前工作目录。</span><span class="sxs-lookup"><span data-stu-id="8c987-341">By default, P/Invoke functions using <xref:System.Runtime.InteropServices.DllImportAttribute> probe a number of directories, including the current working directory for the library to load.</span></span> <span data-ttu-id="8c987-342">对于某些应用程序，这可能是一个安全问题，导致 DLL 劫持。</span><span class="sxs-lookup"><span data-stu-id="8c987-342">This can be a security issue for certain applications, leading to DLL hijacking.</span></span>|
|[<span data-ttu-id="8c987-343">CA5393:请勿使用不安全的 DllImportSearchPath 值</span><span class="sxs-lookup"><span data-stu-id="8c987-343">CA5393: Do not use unsafe DllImportSearchPath value</span></span>](ca5393.md)|<span data-ttu-id="8c987-344">默认 DLL 搜索目录和程序集目录中可能存在恶意 DLL。</span><span class="sxs-lookup"><span data-stu-id="8c987-344">There could be a malicious DLL in the default DLL search directories and assembly directories.</span></span> <span data-ttu-id="8c987-345">或者，根据应用程序的运行位置，应用程序目录中可能存在恶意的 DLL。</span><span class="sxs-lookup"><span data-stu-id="8c987-345">Or, depending on where your application is run from, there could be a malicious DLL in the application's directory.</span></span>|
|[<span data-ttu-id="8c987-346">CA5394:请勿使用不安全的随机性</span><span class="sxs-lookup"><span data-stu-id="8c987-346">CA5394: Do not use insecure randomness</span></span>](ca5394.md)|<span data-ttu-id="8c987-347">使用加密弱伪随机数生成器可以允许攻击者预测将生成的安全敏感值。</span><span class="sxs-lookup"><span data-stu-id="8c987-347">Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated.</span></span>|
|[<span data-ttu-id="8c987-348">CA5395:缺少操作方法的 HttpVerb 属性</span><span class="sxs-lookup"><span data-stu-id="8c987-348">CA5395: Miss HttpVerb attribute for action methods</span></span>](ca5395.md)|<span data-ttu-id="8c987-349">用于创建、编辑、删除或以其他方式修改数据的所有操作方法都需要通过跨站点请求伪造攻击的防伪属性进行保护。</span><span class="sxs-lookup"><span data-stu-id="8c987-349">All the action methods that create, edit, delete, or otherwise modify data needs to be protected with the antiforgery attribute from cross-site request forgery attacks.</span></span> <span data-ttu-id="8c987-350">执行 GET 操作应该是不会产生副作用的安全操作，并且不会修改您的持久数据。</span><span class="sxs-lookup"><span data-stu-id="8c987-350">Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</span></span>|
|[<span data-ttu-id="8c987-351">CA5396:将 HttpCookie 的 HttpOnly 设置为 true</span><span class="sxs-lookup"><span data-stu-id="8c987-351">CA5396: Set HttpOnly to true for HttpCookie</span></span>](ca5396.md)|<span data-ttu-id="8c987-352">作为深层防御措施，请确保将安全敏感的 HTTP cookie 标记为 HttpOnly。</span><span class="sxs-lookup"><span data-stu-id="8c987-352">As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly.</span></span> <span data-ttu-id="8c987-353">这表明 web 浏览器应禁止脚本访问 cookie。</span><span class="sxs-lookup"><span data-stu-id="8c987-353">This indicates web browsers should disallow scripts from accessing the cookies.</span></span> <span data-ttu-id="8c987-354">注入的恶意脚本是偷窃 cookie 的常见方法。</span><span class="sxs-lookup"><span data-stu-id="8c987-354">Injected malicious scripts are a common way of stealing cookies.</span></span>|
|[<span data-ttu-id="8c987-355">CA5397：不使用已弃用的 SslProtocols 值</span><span class="sxs-lookup"><span data-stu-id="8c987-355">CA5397: Do not use deprecated SslProtocols values</span></span>](ca5397.md)|<span data-ttu-id="8c987-356">传输层安全 (TLS) 保护计算机之间的通信，最常见的是通过超文本传输协议安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="8c987-356">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="8c987-357">较早的 TLS 协议版本不如 TLS 1.2 和 TLS 1.3 安全，更有可能出现新的漏洞。</span><span class="sxs-lookup"><span data-stu-id="8c987-357">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="8c987-358">避免旧协议版本来最大程度地降低风险。</span><span class="sxs-lookup"><span data-stu-id="8c987-358">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="8c987-359">CA5398：避免硬编码的 SslProtocols 值</span><span class="sxs-lookup"><span data-stu-id="8c987-359">CA5398: Avoid hardcoded SslProtocols values</span></span>](ca5398.md)|<span data-ttu-id="8c987-360">传输层安全 (TLS) 保护计算机之间的通信，最常见的是通过超文本传输协议安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="8c987-360">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="8c987-361">协议 1.1 1.0 版本不推荐使用，而 TLS 1.2 和 TLS 1.3 是最新的。</span><span class="sxs-lookup"><span data-stu-id="8c987-361">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="8c987-362">未来，TLS 1.2 和 TLS 1.3 可能已弃用。</span><span class="sxs-lookup"><span data-stu-id="8c987-362">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="8c987-363">若要确保应用程序的安全性，请避免硬编码协议版本。</span><span class="sxs-lookup"><span data-stu-id="8c987-363">To ensure that your application remains secure, avoid hardcoding a protocol version.</span></span>|
|[<span data-ttu-id="8c987-364">CA5399:绝对禁用 HttpClient 证书吊销列表检查</span><span class="sxs-lookup"><span data-stu-id="8c987-364">CA5399: Definitely disable HttpClient certificate revocation list check</span></span>](ca5399.md)|<span data-ttu-id="8c987-365">吊销的证书不再受信任。</span><span class="sxs-lookup"><span data-stu-id="8c987-365">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="8c987-366">攻击者可以使用它来传递某些恶意数据或偷窃 HTTPS 通信中的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="8c987-366">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="8c987-367">CA5400:确保未禁用 HttpClient 证书吊销列表检查</span><span class="sxs-lookup"><span data-stu-id="8c987-367">CA5400: Ensure HttpClient certificate revocation list check is not disabled</span></span>](ca5400.md)|<span data-ttu-id="8c987-368">吊销的证书不再受信任。</span><span class="sxs-lookup"><span data-stu-id="8c987-368">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="8c987-369">攻击者可以使用它来传递某些恶意数据或偷窃 HTTPS 通信中的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="8c987-369">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="8c987-370">CA5401:不要将 CreateEncryptor 与非默认 IV 结合使用</span><span class="sxs-lookup"><span data-stu-id="8c987-370">CA5401: Do not use CreateEncryptor with non-default IV</span></span>](ca5401.md)|<span data-ttu-id="8c987-371">对称加密应始终使用不可重复的初始化向量来防止字典攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-371">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="8c987-372">CA5402:将 CreateEncryptor 与默认 IV 结合使用</span><span class="sxs-lookup"><span data-stu-id="8c987-372">CA5402: Use CreateEncryptor with the default IV</span></span>](ca5402.md)|<span data-ttu-id="8c987-373">对称加密应始终使用不可重复的初始化向量来防止字典攻击。</span><span class="sxs-lookup"><span data-stu-id="8c987-373">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="8c987-374">CA5403：请勿硬编码证书</span><span class="sxs-lookup"><span data-stu-id="8c987-374">CA5403: Do not hard-code certificate</span></span>](ca5403.md)|<span data-ttu-id="8c987-375">`data` `rawData` <xref:System.Security.Cryptography.X509Certificates.X509Certificate> 或构造函数的或参数 <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> 是硬编码的。</span><span class="sxs-lookup"><span data-stu-id="8c987-375">The `data` or `rawData` parameter of a <xref:System.Security.Cryptography.X509Certificates.X509Certificate> or <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> constructor is hard-coded.</span></span>|
