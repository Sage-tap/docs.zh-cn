---
title: '设计规则 (代码分析) '
description: 了解代码分析设计规则。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 548e0eaaa6239a9b9ee6a08677cd720710bb48c2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99714126"
---
# <a name="design-rules"></a><span data-ttu-id="d7cb8-103">设计规则</span><span class="sxs-lookup"><span data-stu-id="d7cb8-103">Design rules</span></span>

<span data-ttu-id="d7cb8-104">设计规则支持遵循 [.NET Framework 设计准则](../../../standard/design-guidelines/index.md)。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-104">Design rules support adherence to the [.NET Framework design guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="d7cb8-105">本节内容</span><span class="sxs-lookup"><span data-stu-id="d7cb8-105">In this section</span></span>

| <span data-ttu-id="d7cb8-106">规则</span><span class="sxs-lookup"><span data-stu-id="d7cb8-106">Rule</span></span> | <span data-ttu-id="d7cb8-107">描述</span><span class="sxs-lookup"><span data-stu-id="d7cb8-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="d7cb8-108">CA1000:不要在泛型类型中声明静态成员</span><span class="sxs-lookup"><span data-stu-id="d7cb8-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="d7cb8-109">调用泛型类型的静态成员时，必须指定该类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="d7cb8-110">当调用不支持推理的泛型实例成员时，必须指定该成员的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="d7cb8-111">在上述两种情况下，用于指定类型自变量的语法不同，但很容易混淆。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="d7cb8-112">CA1001:具有可释放字段的类型应该是可释放的</span><span class="sxs-lookup"><span data-stu-id="d7cb8-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="d7cb8-113">类声明并实现属于 IDisposable 类型并且类不实现 IDisposable 的实例字段。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="d7cb8-114">声明 IDisposable 字段的类间接拥有非托管资源，并且应该实现 IDisposable 接口。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="d7cb8-115">CA1002:不要公开泛型列表</span><span class="sxs-lookup"><span data-stu-id="d7cb8-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="d7cb8-116">\<(T>) # A1) 的< (是为性能而不是继承而设计的泛型集合。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="d7cb8-117">因此，List 不包含任何虚拟成员。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="d7cb8-118">应改为公开针对继承设计的泛型集合。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="d7cb8-119">CA1003:使用泛型事件处理程序实例</span><span class="sxs-lookup"><span data-stu-id="d7cb8-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="d7cb8-120">类型包含一个返回 void 的委托，该委托的签名包含 (第一个对象的两个参数，第二个参数包含可分配给 EventArgs) 的类型，并且包含的程序集目标 .NET Framework 2.0。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="d7cb8-121">CA1005:避免泛型类型的参数过多</span><span class="sxs-lookup"><span data-stu-id="d7cb8-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="d7cb8-122">泛型类型包含的类型参数越多，越难以知道并记住每个类型参数各代表什么。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="d7cb8-123">通常情况下，有一种类型参数，如在列表中 \<T> ，以及在某些情况下有两个类型参数，如字典中所示 \<TKey, TValue> 。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="d7cb8-124">但是，如果存在两个以上的类型参数，则大多数用户都会感到过于困难。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="d7cb8-125">CA1008:枚举应具有零值</span><span class="sxs-lookup"><span data-stu-id="d7cb8-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="d7cb8-126">像其他值类型一样，未初始化枚举的默认值为零。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="d7cb8-127">Nonflags 特性化枚举应使用零值来定义成员，以便默认值为枚举的有效值。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="d7cb8-128">如果应用了 FlagsAttribute 特性的枚举定义值为零成员，则该成员的名称应为“None”，以指示枚举中尚未设置值。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="d7cb8-129">CA1010:集合应实现泛型接口</span><span class="sxs-lookup"><span data-stu-id="d7cb8-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="d7cb8-130">若要扩大集合的用途，应实现某个泛型集合接口。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="d7cb8-131">然后，可以使用该集合来填充泛型集合类型。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="d7cb8-132">CA1012:抽象类型不应具有构造函数</span><span class="sxs-lookup"><span data-stu-id="d7cb8-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="d7cb8-133">抽象类型的构造函数只能由派生类型调用。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="d7cb8-134">由于公共构造函数用于创建类型的实例，但无法为抽象类型创建实例，因此具有公共构造函数的抽象类在设计上是错误的。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="d7cb8-135">CA1014:用 CLSCompliantAttribute 标记程序集</span><span class="sxs-lookup"><span data-stu-id="d7cb8-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="d7cb8-136">公共语言规范 (CLS) 定义了程序集在跨编程语言使用时必须符合的命名限制、数据类型和规则。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="d7cb8-137">良好的设计规定，所有程序集都通过使用 CLSCompliantAttribute 显式指示 CLS 符合性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="d7cb8-138">如果程序集没有此特性，则该程序集即不合规。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="d7cb8-139">CA1016:用 AssemblyVersionAttribute 标记程序集</span><span class="sxs-lookup"><span data-stu-id="d7cb8-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="d7cb8-140">.NET 使用版本号来唯一标识程序集，并绑定到强名称程序集中的类型。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="d7cb8-141">版本号与版本和发行者策略一起使用。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="d7cb8-142">默认情况下，仅使用用于生成应用程序的程序集版本运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="d7cb8-143">CA1017:用 ComVisibleAttribute 标记程序集</span><span class="sxs-lookup"><span data-stu-id="d7cb8-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="d7cb8-144">ComVisibleAttribute 决定 COM 客户端如何访问托管代码。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="d7cb8-145">合理的设计指出程序集将显式指示 COM 可见性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="d7cb8-146">可以设置整个程序集的 COM 可见性，然后重写各个类型和类型成员的 COM 可见性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="d7cb8-147">如果此特性不存在，则程序集的内容对 COM 客户端可见。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="d7cb8-148">CA1018:用 AttributeUsageAttribute 标记特性</span><span class="sxs-lookup"><span data-stu-id="d7cb8-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="d7cb8-149">当定义自定义特性时，用 AttributeUsageAttribute 标记该特性，以指示源代码中可以应用自定义特性的位置。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="d7cb8-150">特性的含义和预定用法将决定它在代码中的有效位置。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="d7cb8-151">CA1019:定义特性参数的访问器</span><span class="sxs-lookup"><span data-stu-id="d7cb8-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="d7cb8-152">特性可以定义强制自变量，在对目标应用该特性时必须指定这些自变量。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="d7cb8-153">这些实参也称为位置实参，因为它们将作为位置形参提供给特性构造函数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="d7cb8-154">对于每一个强制变量，特性还必须提供一个相应的只读属性，以便可以在执行时检索该变量的值。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="d7cb8-155">特性还可以定义可选实参，可选实参也称为命名实参。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="d7cb8-156">这些变量按名称提供给特性构造函数，并且必须具有相应的读/写属性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="d7cb8-157">CA1021:避免使用 out 参数</span><span class="sxs-lookup"><span data-stu-id="d7cb8-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="d7cb8-158">通过引用（使用 out 或 ref）传递类型要求具有使用指针的经验，了解值类型和引用类型的不同之处，以及能处理具有多个返回值的方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="d7cb8-159">另外，out 和 ref 参数之间的差异没有得到广泛了解。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="d7cb8-160">CA1024:在适用处使用属性</span><span class="sxs-lookup"><span data-stu-id="d7cb8-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="d7cb8-161">公共或受保护方法的名称以“Get”开头，没有采用任何参数或返回的值不是数组。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="d7cb8-162">该方法可能很适于成为属性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="d7cb8-163">CA1027:用 FlagsAttribute 标记枚举</span><span class="sxs-lookup"><span data-stu-id="d7cb8-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="d7cb8-164">枚举是一种值类型，它定义一组相关的已命名常数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="d7cb8-165">如果可以按照有意义的方式组合一个枚举的已命名常数，则对该枚举应用 FlagsAttribute。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="d7cb8-166">CA1028:枚举存储应为 Int32</span><span class="sxs-lookup"><span data-stu-id="d7cb8-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="d7cb8-167">枚举是一种值类型，它定义一组相关的已命名常数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="d7cb8-168">默认情况下，System.Int32 数据类型用于存储常量值。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="d7cb8-169">尽管你可以更改此基础类型，但在大多数情况下不需要或建议使用此类型。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="d7cb8-170">CA1030:在适用处使用事件</span><span class="sxs-lookup"><span data-stu-id="d7cb8-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="d7cb8-171">该规则检测名称通常用于事件的方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="d7cb8-172">如果为响应明确定义的状态更改而调用一个方法，则应由事件处理程序调用该方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="d7cb8-173">调用该方法的对象应引发事件而不是直接调用该方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="d7cb8-174">CA1031:不要捕捉一般异常类型</span><span class="sxs-lookup"><span data-stu-id="d7cb8-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="d7cb8-175">不应捕捉一般异常。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-175">General exceptions should not be caught.</span></span> <span data-ttu-id="d7cb8-176">捕获更具体的异常，或者再次引发一般异常作为 catch 块中的最后一个语句。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="d7cb8-177">CA1032:实现标准异常构造函数</span><span class="sxs-lookup"><span data-stu-id="d7cb8-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="d7cb8-178">如果不能提供完整的构造函数集，要正确处理异常将变得比较困难。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="d7cb8-179">CA1033:接口方法应可由子类型调用</span><span class="sxs-lookup"><span data-stu-id="d7cb8-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="d7cb8-180">未密封的外部可见类型提供了显式实现公共接口的方法，但没有提供具有相同名称的其他外部可见方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="d7cb8-181">CA1034:嵌套类型不应是可见的</span><span class="sxs-lookup"><span data-stu-id="d7cb8-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="d7cb8-182">嵌套类型是在另一个类型的范围中声明的类型。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="d7cb8-183">嵌套类型用于封装包含类型的私有实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="d7cb8-184">如果用于此用途，则嵌套类型不应是外部可见的。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="d7cb8-185">CA1036:重写可比较类型中的方法</span><span class="sxs-lookup"><span data-stu-id="d7cb8-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="d7cb8-186">公共或受保护类型实现 System.IComparable 接口。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="d7cb8-187">它不重写 Object.Equals，也不重载表示相等、不等、小于或大于的语言特定运算符。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="d7cb8-188">CA1040:避免使用空接口</span><span class="sxs-lookup"><span data-stu-id="d7cb8-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="d7cb8-189">接口定义提供某个行为或使用协定的成员。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="d7cb8-190">接口所描述的功能可以被任何类型采用，而不管该类型出现在继承层次结构中的哪个位置。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="d7cb8-191">类型通过实现接口的成员来实现接口。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="d7cb8-192">空接口无法定义任何成员；因此，它无法定义可以实现的协定。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="d7cb8-193">CA1041:提供 ObsoleteAttribute 消息</span><span class="sxs-lookup"><span data-stu-id="d7cb8-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="d7cb8-194">用未指定其 ObsoleteAttribute.Message 属性的 System.ObsoleteAttribute 特性来标记类型或成员。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="d7cb8-195">当编译用 ObsoleteAttribute 标记的类型或成员时，将显示属性的消息属性，该属性将为用户提供有关已过时的类型或成员的信息。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="d7cb8-196">CA1043:将整型或字符串参数用于索引器</span><span class="sxs-lookup"><span data-stu-id="d7cb8-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="d7cb8-197">索引器（即索引属性）应将整型或字符串类型用于索引。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="d7cb8-198">这些类型一般用于为数据结构编制索引，并且提高库的可用性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="d7cb8-199">应仅限于在设计时无法指定特定整型或字符串类型的情况下使用 Object 类型。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="d7cb8-200">CA1044:属性不应是只写的</span><span class="sxs-lookup"><span data-stu-id="d7cb8-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="d7cb8-201">虽然可以接受且经常需要使用只读属性，但设计准则禁止使用只写属性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="d7cb8-202">这是因为允许用户设置值但又禁止该用户查看这个值不能提供任何安全性。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="d7cb8-203">而且，如果没有读访问，将无法查看共享对象的状态，使其用处受到限制。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="d7cb8-204">CA1045:不要通过引用来传递类型</span><span class="sxs-lookup"><span data-stu-id="d7cb8-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="d7cb8-205">通过引用（使用 out 或 ref）传递类型要求具有使用指针的经验，了解值类型和引用类型的不同之处，以及能处理具有多个返回值的方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="d7cb8-206">为一般用户进行设计的库架构师不应指望用户能熟练运用 out 或 ref 参数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="d7cb8-207">CA1046:不要对引用类型重载相等运算符</span><span class="sxs-lookup"><span data-stu-id="d7cb8-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="d7cb8-208">对于引用类型，相等运算符的默认实现几乎始终是正确的。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="d7cb8-209">默认情况下，仅当两个引用指向同一对象时，它们才相等。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="d7cb8-210">CA1047:不要在密封类型中声明受保护的成员</span><span class="sxs-lookup"><span data-stu-id="d7cb8-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="d7cb8-211">类型声明受保护的成员，使继承类型可以访问或重写该成员。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="d7cb8-212">按照定义，不能继承密封类型，这表示不能调用密封类型上的受保护方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="d7cb8-213">CA1050:在命名空间中声明类型</span><span class="sxs-lookup"><span data-stu-id="d7cb8-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="d7cb8-214">应在命名空间内声明类型以避免名称冲突，并作为一种在对象层次结构中组织相关类型的方式。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="d7cb8-215">CA1051:不要声明可见实例字段</span><span class="sxs-lookup"><span data-stu-id="d7cb8-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="d7cb8-216">字段的主要用途应是作为实现的详细信息。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="d7cb8-217">字段应为 private 或 internal，并应通过使用属性公开这些字段。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="d7cb8-218">CA1052:应密封静态容器类型</span><span class="sxs-lookup"><span data-stu-id="d7cb8-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="d7cb8-219">公共或受保护类型仅包含静态成员，并且不是使用密封的 (c # ) 或 NotInheritable (Visual Basic) 修饰符声明的。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="d7cb8-220">应使用 sealed 修饰符标记不希望被继承的类型，以免将其用作基类型。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="d7cb8-221">CA1053:静态容器类型不应具有构造函数</span><span class="sxs-lookup"><span data-stu-id="d7cb8-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="d7cb8-222">公共或嵌套公共类型只声明了静态成员，但具有公共或受保护的默认构造函数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="d7cb8-223">由于调用静态成员不需要类型的示例，因此没必要使用构造函数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="d7cb8-224">为安全起见，字符串重载应使用字符串自变量调用统一资源标识符 (URI) 重载。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="d7cb8-225">CA1054:URI 参数不应为字符串</span><span class="sxs-lookup"><span data-stu-id="d7cb8-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="d7cb8-226">如果某方法采用 URI 的字符串表示形式，则应提供采用 URI 类的实例的相应重载，该重载以安全的方式提供这些服务。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="d7cb8-227">CA1055:URI 返回值不应是字符串</span><span class="sxs-lookup"><span data-stu-id="d7cb8-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="d7cb8-228">此规则假定该方法返回 URI。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="d7cb8-229">URI 的字符串表示形式容易导致分析和编码错误，并且可造成安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="d7cb8-230">System.Uri 类以一种安全的方式提供这些服务。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="d7cb8-231">CA1056:URI 属性不应是字符串</span><span class="sxs-lookup"><span data-stu-id="d7cb8-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="d7cb8-232">此规则假定属性表示 URI。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="d7cb8-233">URI 的字符串表示形式容易导致分析和编码错误，并且可造成安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="d7cb8-234">System.Uri 类以一种安全的方式提供这些服务。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="d7cb8-235">CA1058:类型不应扩展某些基类型</span><span class="sxs-lookup"><span data-stu-id="d7cb8-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="d7cb8-236">外部可见的类型扩展某些基类型。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="d7cb8-237">请使用某个备选项。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="d7cb8-238">CA1060：将 P/Invoke 移动到 NativeMethods 类</span><span class="sxs-lookup"><span data-stu-id="d7cb8-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="d7cb8-239">平台调用方法，如用或方法标记的方法，这些方法是 <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> 通过在 Visual Basic 中使用 Declare 关键字定义的，访问非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="d7cb8-240">这些方法应属于 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 类。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="d7cb8-241">CA1061:不要隐藏基类方法</span><span class="sxs-lookup"><span data-stu-id="d7cb8-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="d7cb8-242">如果派生方法的参数签名只是在类型方面有所不同，而且与基方法的参数签名中的对应类型相比，这些类型的派生方式更弱，则基类型中的方法由派生类型中的同名方法隐藏。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="d7cb8-243">CA1062:验证公共方法的参数</span><span class="sxs-lookup"><span data-stu-id="d7cb8-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="d7cb8-244">对于传递给外部可见方法的所有引用自变量，都应检查其是否为 null。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="d7cb8-245">CA1063:正确实现 IDisposable</span><span class="sxs-lookup"><span data-stu-id="d7cb8-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="d7cb8-246">所有的 IDisposable 类型都应当正确实现 Dispose 模式。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="d7cb8-247">CA1064:异常应该是公共的</span><span class="sxs-lookup"><span data-stu-id="d7cb8-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="d7cb8-248">内部异常仅在其自己的内部范围内可见。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="d7cb8-249">当异常超出内部范围后，只能使用基异常来捕获该异常。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="d7cb8-250">如果内部异常继承自 <xref:System.Exception?displayProperty=fullName> 、或， <xref:System.SystemException?displayProperty=fullName> <xref:System.ApplicationException?displayProperty=fullName> 外部代码将不会有足够的信息来了解如何处理该异常。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="d7cb8-251">CA1065:不要在意外的位置引发异常</span><span class="sxs-lookup"><span data-stu-id="d7cb8-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="d7cb8-252">不应引发异常的方法引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="d7cb8-253">CA1066：重写 Equals 时实现 IEquatable</span><span class="sxs-lookup"><span data-stu-id="d7cb8-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="d7cb8-254">值类型重写 <xref:System.Object.Equals%2A> 方法，但不实现 <xref:System.IEquatable%601> 。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="d7cb8-255">CA1067：实现 IEquatable 时重写 Equals</span><span class="sxs-lookup"><span data-stu-id="d7cb8-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="d7cb8-256">类型实现 <xref:System.IEquatable%601> ，但不重写 <xref:System.Object.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="d7cb8-257">CA1068:CancellationToken 参数必须最后出现</span><span class="sxs-lookup"><span data-stu-id="d7cb8-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="d7cb8-258">方法具有一个不是最后一个参数的 CancellationToken 参数。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="d7cb8-259">CA1069:枚举不得具有重复值</span><span class="sxs-lookup"><span data-stu-id="d7cb8-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="d7cb8-260">枚举具有多个显式分配相同常数值的成员。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="d7cb8-261">CA1070:不要将事件字段声明为“虚拟”</span><span class="sxs-lookup"><span data-stu-id="d7cb8-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="d7cb8-262">[类似字段的事件](../../../csharp/event-pattern.md#defining-and-raising-field-like-events)被声明为 virtual。</span><span class="sxs-lookup"><span data-stu-id="d7cb8-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
