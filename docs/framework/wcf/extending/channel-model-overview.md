---
description: 了解详细信息：通道模型概述
title: 通道模型概述
ms.date: 03/30/2017
helpviewer_keywords:
- channel model [WCF]
ms.assetid: 07a81e11-3911-4632-90d2-cca99825b5bd
ms.openlocfilehash: 8b22c2b957eec6e3b52a84c7a30d4a17c41293e6
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99685876"
---
# <a name="channel-model-overview"></a><span data-ttu-id="0f989-103">通道模型概述</span><span class="sxs-lookup"><span data-stu-id="0f989-103">Channel Model Overview</span></span>

<span data-ttu-id="0f989-104">Windows Communication Foundation (WCF) 通道堆栈是一个分层通信堆栈，其中包含处理消息的一个或多个通道。</span><span class="sxs-lookup"><span data-stu-id="0f989-104">The Windows Communication Foundation (WCF) channel stack is a layered communication stack with one or more channels that process messages.</span></span> <span data-ttu-id="0f989-105">堆栈底部是传输通道，它负责使通道堆栈适应基础传输（例如，TCP、HTTP、SMTP 和其他类型的传输）。</span><span class="sxs-lookup"><span data-stu-id="0f989-105">At the bottom of the stack is a transport channel that is responsible for adapting the channel stack to the underlying transport (for example, TCP, HTTP, SMTP and other types of transport.).</span></span> <span data-ttu-id="0f989-106">通道为消息的发送和接收提供了一个低级编程模型。</span><span class="sxs-lookup"><span data-stu-id="0f989-106">Channels provide a low-level programming model for sending and receiving messages.</span></span> <span data-ttu-id="0f989-107">此编程模型依赖于多个接口和其他称为 WCF 通道模型的类型。</span><span class="sxs-lookup"><span data-stu-id="0f989-107">This programming model relies on several interfaces and other types collectively known as the WCF channel model.</span></span> <span data-ttu-id="0f989-108">本主题讨论通道形状、基本通道侦听器（在服务上）和通道工厂（在客户端上）的构造。</span><span class="sxs-lookup"><span data-stu-id="0f989-108">This topic discusses channel shapes, the construction of a basic channel listener (on the service) and channel factory (on the client).</span></span>  
  
## <a name="channel-stack"></a><span data-ttu-id="0f989-109">通道堆栈</span><span class="sxs-lookup"><span data-stu-id="0f989-109">Channel Stack</span></span>  

 <span data-ttu-id="0f989-110">WCF 终结点使用称为通道堆栈的通信堆栈与世界通信。</span><span class="sxs-lookup"><span data-stu-id="0f989-110">WCF endpoints communicate with the world using a communication stack called the channel stack.</span></span> <span data-ttu-id="0f989-111">下图对通道堆栈和其他通信堆栈（如 TCP/IP）进行了比较。</span><span class="sxs-lookup"><span data-stu-id="0f989-111">The following diagram compares the channel stack with other communication stacks, for example TCP/IP.</span></span>  
  
 <span data-ttu-id="0f989-112">![通道模型](./media/wcfc-channelstackhighlevelc.gif "wcfc_ChannelStackHighLevelc")</span><span class="sxs-lookup"><span data-stu-id="0f989-112">![Channel Model](./media/wcfc-channelstackhighlevelc.gif "wcfc_ChannelStackHighLevelc")</span></span>  
  
 <span data-ttu-id="0f989-113">首先说明共同点：在两种情况下，堆栈的每一层均提供该层下面一层的一些抽象，并仅向其上的一层公开该抽象。</span><span class="sxs-lookup"><span data-stu-id="0f989-113">First, the similarities: In both cases, each layer of the stack provides some abstraction of the world below that layer and exposed that abstraction only to the layer directly above it.</span></span> <span data-ttu-id="0f989-114">每一层只使用其下面一层的抽象。</span><span class="sxs-lookup"><span data-stu-id="0f989-114">Each layer uses the abstraction of only the layer directly below it.</span></span> <span data-ttu-id="0f989-115">而且在这两种情况下，两个堆栈通信时，每个层均与另一个堆栈中的相应层通信，例如，IP 层与 IP 层通信，TCP 层与 TCP 层通信，依此类推。</span><span class="sxs-lookup"><span data-stu-id="0f989-115">Also in both cases, when two stacks communicate, each layer communicates with the corresponding layer in the other stack, for example, the IP layer communicates with the IP layer and the TCP layer with the TCP layer, and so on.</span></span>  
  
 <span data-ttu-id="0f989-116">现在说明区别：TCP 堆栈旨在提供物理网络的抽象，而通道堆栈不仅提供消息传送方式（即传输）的抽象，还提供其他功能（比如消息的内容或通信所使用的协议，包括但不仅仅限于传输）的抽象。</span><span class="sxs-lookup"><span data-stu-id="0f989-116">Now, the differences: While the TCP stack was designed to provide an abstraction of the physical network, the channel stack is designed to provide an abstraction of not only how the message is delivered, that is, the transport, but also other features such as what is in the message or what protocol is used for communication, including the transport but much more than that.</span></span> <span data-ttu-id="0f989-117">例如，可靠的会话绑定元素是通道堆栈的一部分，但却不在传输下面或传输本身中。</span><span class="sxs-lookup"><span data-stu-id="0f989-117">For example, reliable session binding element is part of the channel stack but is not below the transport or the transport itself.</span></span> <span data-ttu-id="0f989-118">此抽象是通过要求堆栈中的底部通道使基础传输协议适应通道堆栈体系结构，然后依赖堆栈中更上层的通道提供通信功能（比如可靠性保证和安全）来实现的。</span><span class="sxs-lookup"><span data-stu-id="0f989-118">This abstraction is achieved by requiring the bottom channel in the stack to adapt the underlying transport protocol to the channel stack architecture and then relying on channels further up in the stack to provide communication features such as reliability guarantees and security.</span></span>  
  
 <span data-ttu-id="0f989-119">消息作为 <xref:System.ServiceModel.Channels.Message> 对象流过通信堆栈。</span><span class="sxs-lookup"><span data-stu-id="0f989-119">Messages flow through the communication stack as <xref:System.ServiceModel.Channels.Message> objects.</span></span> <span data-ttu-id="0f989-120">如上图所示，底部通道称为传输通道。</span><span class="sxs-lookup"><span data-stu-id="0f989-120">As shown in figure above, the bottom channel is called a transport channel.</span></span> <span data-ttu-id="0f989-121">它是负责与其他方之间发送和接收消息的通道。</span><span class="sxs-lookup"><span data-stu-id="0f989-121">It is the channel that is responsible for sending and receiving messages to and from other parties.</span></span> <span data-ttu-id="0f989-122">这包括负责在与用于和其他方通信的格式之间转换 <xref:System.ServiceModel.Channels.Message> 对象。</span><span class="sxs-lookup"><span data-stu-id="0f989-122">This includes the responsibility of transforming the <xref:System.ServiceModel.Channels.Message> object to and from the format used to communicate with other parties.</span></span> <span data-ttu-id="0f989-123">传输通道上面可以有任意个协议通道，每个协议通道负责提供一种通信功能（如可靠的传递保证）。</span><span class="sxs-lookup"><span data-stu-id="0f989-123">Above the transport channel there can be any number of protocol channels each responsible for providing a communication function such as reliable delivery guarantees.</span></span> <span data-ttu-id="0f989-124">协议通道对以 <xref:System.ServiceModel.Channels.Message> 对象的形式流过其中的消息执行操作。</span><span class="sxs-lookup"><span data-stu-id="0f989-124">Protocol channels operate on messages flowing through them in the form of the <xref:System.ServiceModel.Channels.Message> object.</span></span> <span data-ttu-id="0f989-125">协议通道通常会转换消息（例如，通过添加标头或加密正文），或者发送和接收协议通道自己的控制消息（例如回执确认）。</span><span class="sxs-lookup"><span data-stu-id="0f989-125">They typically either transform the message, for example, by adding headers or encrypting the body, or send and receive their own protocol control messages, for example, receipt acknowledgments.</span></span>  
  
## <a name="channel-shapes"></a><span data-ttu-id="0f989-126">通道形状</span><span class="sxs-lookup"><span data-stu-id="0f989-126">Channel Shapes</span></span>  

 <span data-ttu-id="0f989-127">每个通道均实现一个或多个接口，称为通道形状接口或通道形状。</span><span class="sxs-lookup"><span data-stu-id="0f989-127">Each channel implements one or more interfaces known as channel shape interfaces or channel shapes.</span></span> <span data-ttu-id="0f989-128">这些通道形状提供面向通信的方法（如通道实现的发送和接收或请求和答复）和通道调用的用户。</span><span class="sxs-lookup"><span data-stu-id="0f989-128">Those channel shapes provide the communication-oriented methods such as send and receive or request and reply that the channel implements and the user of the channel calls.</span></span> <span data-ttu-id="0f989-129">通道形状的基础是 <xref:System.ServiceModel.Channels.IChannel> 接口，它是一个接口，它提供一个方法，该 `GetProperty` \<T> 方法旨在用作分层机制，以访问堆栈中由通道公开的任意功能。</span><span class="sxs-lookup"><span data-stu-id="0f989-129">At the base of the channel shapes is the <xref:System.ServiceModel.Channels.IChannel> interface, which is an interface that provides a `GetProperty`\<T> method intended as a layered mechanism to access arbitrary features exposed by channels in the stack.</span></span> <span data-ttu-id="0f989-130">扩展 <xref:System.ServiceModel.Channels.IChannel> 的五种通道形状为：</span><span class="sxs-lookup"><span data-stu-id="0f989-130">The five channel shapes that extend <xref:System.ServiceModel.Channels.IChannel> are:</span></span>  
  
- <xref:System.ServiceModel.Channels.IInputChannel>  
  
- <xref:System.ServiceModel.Channels.IOutputChannel>  
  
- <xref:System.ServiceModel.Channels.IRequestChannel>  
  
- <xref:System.ServiceModel.Channels.IReplyChannel>  
  
- <xref:System.ServiceModel.Channels.IDuplexChannel>  
  
 <span data-ttu-id="0f989-131">另外，这些形状中的每个形状均有一个扩展 <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> 以支持会话的等效项。</span><span class="sxs-lookup"><span data-stu-id="0f989-131">Further, each of these shapes has an equivalent that extends <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> to support sessions.</span></span> <span data-ttu-id="0f989-132">这些是：</span><span class="sxs-lookup"><span data-stu-id="0f989-132">These are:</span></span>  
  
- <xref:System.ServiceModel.Channels.IInputSessionChannel>  
  
- <xref:System.ServiceModel.Channels.IOutputSessionChannel>  
  
- <xref:System.ServiceModel.Channels.IRequestSessionChannel>  
  
- <xref:System.ServiceModel.Channels.IReplySessionChannel>  
  
- <xref:System.ServiceModel.Channels.IDuplexSessionChannel>  
  
 <span data-ttu-id="0f989-133">在现有的传输协议支持某些基本消息交换模式后，通道形状可以实现模式化。</span><span class="sxs-lookup"><span data-stu-id="0f989-133">The channel shapes are patterned after some of the fundamental message exchange patterns supported by existing transport protocols.</span></span> <span data-ttu-id="0f989-134">例如，单向消息对应于一 <xref:System.ServiceModel.Channels.IInputChannel> / <xref:System.ServiceModel.Channels.IOutputChannel> 对，请求-答复对应于成对，双向双向通信对应于同时 <xref:System.ServiceModel.Channels.IRequestChannel> / <xref:System.ServiceModel.Channels.IReplyChannel> <xref:System.ServiceModel.Channels.IDuplexChannel> 扩展 <xref:System.ServiceModel.Channels.IInputChannel> 和 <xref:System.ServiceModel.Channels.IOutputChannel>)  (。</span><span class="sxs-lookup"><span data-stu-id="0f989-134">For example, one-way messaging corresponds to an <xref:System.ServiceModel.Channels.IInputChannel>/<xref:System.ServiceModel.Channels.IOutputChannel> pair, request-reply corresponds to <xref:System.ServiceModel.Channels.IRequestChannel>/<xref:System.ServiceModel.Channels.IReplyChannel> pairs and two-way duplex communications corresponds to <xref:System.ServiceModel.Channels.IDuplexChannel> (which extends both <xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>).</span></span>  
  
## <a name="programming-with-the-channel-stack"></a><span data-ttu-id="0f989-135">通道堆栈的编程</span><span class="sxs-lookup"><span data-stu-id="0f989-135">Programming with the Channel Stack</span></span>  

 <span data-ttu-id="0f989-136">通道堆栈通常是使用工厂模式创建的，在这种模式中，绑定创建通道堆栈。</span><span class="sxs-lookup"><span data-stu-id="0f989-136">Channel stacks are typically created using a factory pattern where a binding creates the channel stack.</span></span> <span data-ttu-id="0f989-137">在发送端，使用绑定生成 <xref:System.ServiceModel.ChannelFactory>，而后者生成通道堆栈并返回对堆栈中顶部通道的引用。</span><span class="sxs-lookup"><span data-stu-id="0f989-137">On the send side, a binding is used to build a <xref:System.ServiceModel.ChannelFactory>, which in turn builds a channel stack and returns a reference to the top channel in the stack.</span></span> <span data-ttu-id="0f989-138">之后，应用程序可以使用此通道发送消息。</span><span class="sxs-lookup"><span data-stu-id="0f989-138">The application can then use this channel to send messages.</span></span> <span data-ttu-id="0f989-139">有关详细信息，请参阅 [客户端 Channel-Level 编程](client-channel-level-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="0f989-139">For more information, see [Client Channel-Level Programming](client-channel-level-programming.md).</span></span>  
  
 <span data-ttu-id="0f989-140">在接收端，使用绑定生成 <xref:System.ServiceModel.Channels.IChannelListener>，用于侦听传入消息。</span><span class="sxs-lookup"><span data-stu-id="0f989-140">On the receive side a binding is used to build a <xref:System.ServiceModel.Channels.IChannelListener>, which listens for incoming messages.</span></span> <span data-ttu-id="0f989-141"><xref:System.ServiceModel.Channels.IChannelListener> 通过创建通道堆栈并将应用程序引用传递给顶部通道，将消息提供给侦听应用程序。</span><span class="sxs-lookup"><span data-stu-id="0f989-141">The <xref:System.ServiceModel.Channels.IChannelListener> provides messages to the listening application by creating channel stacks and handing the application reference to the top channel.</span></span> <span data-ttu-id="0f989-142">之后，应用程序使用此通道接收传入消息。</span><span class="sxs-lookup"><span data-stu-id="0f989-142">The application then uses this channel to receive incoming messages.</span></span> <span data-ttu-id="0f989-143">有关详细信息，请参阅 [服务 Channel-Level 编程](service-channel-level-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="0f989-143">For more information, see [Service Channel-Level Programming](service-channel-level-programming.md).</span></span>  
  
## <a name="the-channel-object-model"></a><span data-ttu-id="0f989-144">通道对象模型</span><span class="sxs-lookup"><span data-stu-id="0f989-144">The Channel Object Model</span></span>  

 <span data-ttu-id="0f989-145">通道对象模型是实现通道、通道侦听器和通道工厂所必需的一组核心接口。</span><span class="sxs-lookup"><span data-stu-id="0f989-145">The channel object model is the core set of interfaces required to implement channels, channel listeners and channel factories.</span></span> <span data-ttu-id="0f989-146">还提供一些基类以辅助自定义实现。</span><span class="sxs-lookup"><span data-stu-id="0f989-146">There are also some base classes provided to assist in custom implementations.</span></span>  
  
 <span data-ttu-id="0f989-147">通道侦听器负责侦听传入消息，然后通过由通道侦听器创建的通道将这些消息传送到上面的层。</span><span class="sxs-lookup"><span data-stu-id="0f989-147">Channel listeners are responsible for listening for incoming messages, then delivering them to the layer above through channels created by the channel listener.</span></span>  
  
 <span data-ttu-id="0f989-148">通道工厂负责创建通道，这些通道用于发送消息，并在通道工厂关闭时，关闭通道工厂创建的所有通道。</span><span class="sxs-lookup"><span data-stu-id="0f989-148">Channel factories are responsible for creating channels that are used for sending messages and for closing all channels they created when the channel factory is closed.</span></span>  
  
 <span data-ttu-id="0f989-149"><xref:System.ServiceModel.ICommunicationObject> 是定义所有通信对象实现的基本状态机的核心接口。</span><span class="sxs-lookup"><span data-stu-id="0f989-149"><xref:System.ServiceModel.ICommunicationObject> is the core interface that defines the basic state machine that all communication objects implement.</span></span> <span data-ttu-id="0f989-150"><xref:System.ServiceModel.Channels.CommunicationObject> 提供此核心接口的实现，其他通道类可以派生自该核心接口，而不是重新实现该接口。</span><span class="sxs-lookup"><span data-stu-id="0f989-150"><xref:System.ServiceModel.Channels.CommunicationObject> provides an implementation of this core interface that other channel classes can derive from rather than re-implementing the interface.</span></span> <span data-ttu-id="0f989-151">但这并不是必需的：自定义通道可以直接实现 <xref:System.ServiceModel.ICommunicationObject> 而不继承自 <xref:System.ServiceModel.Channels.CommunicationObject>。</span><span class="sxs-lookup"><span data-stu-id="0f989-151">However, this is not required: a custom channel can implement <xref:System.ServiceModel.ICommunicationObject> directly and not inherit from <xref:System.ServiceModel.Channels.CommunicationObject>.</span></span> <span data-ttu-id="0f989-152">图 3 中的任何类都不是通道模型的部分；它们是想要生成通道的自定义通道实施者可以使用的帮助器。</span><span class="sxs-lookup"><span data-stu-id="0f989-152">None of the classes in Figure 3 are considered part of the channel model; they are helpers available to custom channel implementers who want to build channels.</span></span>  
  
 <span data-ttu-id="0f989-153">![通道模型](./media/wcfc-wcfcchannelsigure3omumtreec.gif "wcfc_WCFCChannelsigure3OMUMTreec")</span><span class="sxs-lookup"><span data-stu-id="0f989-153">![Channel model](./media/wcfc-wcfcchannelsigure3omumtreec.gif "wcfc_WCFCChannelsigure3OMUMTreec")</span></span>  
  
 <span data-ttu-id="0f989-154">以下主题说明通道对象模型以及可帮助生成自定义通道的各个开发领域。</span><span class="sxs-lookup"><span data-stu-id="0f989-154">The following topics describe the channel object model as well as various development areas that help build custom channels.</span></span>  
  
|<span data-ttu-id="0f989-155">主题</span><span class="sxs-lookup"><span data-stu-id="0f989-155">Topic</span></span>|<span data-ttu-id="0f989-156">说明</span><span class="sxs-lookup"><span data-stu-id="0f989-156">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="0f989-157">服务：通道侦听器和通道</span><span class="sxs-lookup"><span data-stu-id="0f989-157">Service: Channel Listeners and Channels</span></span>](service-channel-listeners-and-channels.md)|<span data-ttu-id="0f989-158">说明用于侦听服务应用程序中传入通道的通道侦听器。</span><span class="sxs-lookup"><span data-stu-id="0f989-158">Describes channel listeners, which listen for incoming channels in a service application.</span></span>|  
|[<span data-ttu-id="0f989-159">客户端：通道工厂和通道</span><span class="sxs-lookup"><span data-stu-id="0f989-159">Client: Channel Factories and Channels</span></span>](client-channel-factories-and-channels.md)|<span data-ttu-id="0f989-160">说明用于创建通道以连接到服务应用程序的通道工厂。</span><span class="sxs-lookup"><span data-stu-id="0f989-160">Describes channel factories, which create channels to connect to a service application.</span></span>|  
|[<span data-ttu-id="0f989-161">了解状态更改</span><span class="sxs-lookup"><span data-stu-id="0f989-161">Understanding State Changes</span></span>](understanding-state-changes.md)|<span data-ttu-id="0f989-162">说明 <xref:System.ServiceModel.ICommunicationObject?displayProperty=nameWithType> 接口如何模拟通道中的状态变化。</span><span class="sxs-lookup"><span data-stu-id="0f989-162">Describes how the <xref:System.ServiceModel.ICommunicationObject?displayProperty=nameWithType> interface models state changes in channels.</span></span>|  
|[<span data-ttu-id="0f989-163">选择消息交换模式</span><span class="sxs-lookup"><span data-stu-id="0f989-163">Choosing a Message Exchange Pattern</span></span>](choosing-a-message-exchange-pattern.md)|<span data-ttu-id="0f989-164">说明通道可以支持的六种基本消息交换模式。</span><span class="sxs-lookup"><span data-stu-id="0f989-164">Describes the six basic message exchange patterns that channels can support.</span></span>|  
|[<span data-ttu-id="0f989-165">处理异常和错误</span><span class="sxs-lookup"><span data-stu-id="0f989-165">Handling Exceptions and Faults</span></span>](handling-exceptions-and-faults.md)|<span data-ttu-id="0f989-166">说明如何处理自定义通道中的错误和异常。</span><span class="sxs-lookup"><span data-stu-id="0f989-166">Describes how to handle faults and exceptions in custom channels.</span></span>|  
|[<span data-ttu-id="0f989-167">配置和元数据支持</span><span class="sxs-lookup"><span data-stu-id="0f989-167">Configuration and Metadata Support</span></span>](configuration-and-metadata-support.md)|<span data-ttu-id="0f989-168">说明如何支持从应用程序模型中使用自定义通道以及如何使用绑定和绑定元素导出和导入元数据。</span><span class="sxs-lookup"><span data-stu-id="0f989-168">Describes how to support the use of custom channels from the application model and how to export and import metadata using bindings and binding elements.</span></span>|
