---
title: 分布式跟踪概念 - .NET
description: .NET 分布式跟踪概念
ms.date: 03/14/2021
ms.openlocfilehash: 368cb545b9928534766e3005992a7a55571b8dcc
ms.sourcegitcommit: e16315d9f1ff355f55ff8ab84a28915be0a8e42b
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/25/2021
ms.locfileid: "105111500"
---
# <a name="net-distributed-tracing-concepts"></a><span data-ttu-id="b6b42-103">.NET 分布式跟踪概念</span><span class="sxs-lookup"><span data-stu-id="b6b42-103">.NET Distributed Tracing Concepts</span></span>

<span data-ttu-id="b6b42-104">分布式跟踪是一种诊断技术，可帮助工程师找出应用程序中的故障和性能问题，尤其是那些可能跨多个计算机或进程分布的问题。</span><span class="sxs-lookup"><span data-stu-id="b6b42-104">Distributed tracing is a diagnostic technique that helps engineers localize failures and performance issues within applications, especially those that may be distributed across multiple machines or processes.</span></span> <span data-ttu-id="b6b42-105">如需深入了解分布式跟踪的使用场景以及入门示例代码，请参阅[分布式跟踪概述](distributed-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="b6b42-105">See the [Distributed Tracing Overview](distributed-tracing.md) for general information about where distributed tracing is useful and example code to get started.</span></span>

### <a name="traces-and-activities"></a><span data-ttu-id="b6b42-106">跟踪和活动</span><span class="sxs-lookup"><span data-stu-id="b6b42-106">Traces and Activities</span></span>

<span data-ttu-id="b6b42-107">每次应用程序收到新请求时，它都可以与跟踪相关联。</span><span class="sxs-lookup"><span data-stu-id="b6b42-107">Each time a new request is received by an application it can be associated with a trace.</span></span> <span data-ttu-id="b6b42-108">在用 .NET 编写的应用程序组件中，跟踪中的工作单元由 <xref:System.Diagnostics.Activity?displayProperty=nameWithType> 实例表示，并且跟踪整体上构成了这些活动的树，可能跨越了许多不同的进程。</span><span class="sxs-lookup"><span data-stu-id="b6b42-108">In application components written in .NET, units of work in a trace are represented by instances of <xref:System.Diagnostics.Activity?displayProperty=nameWithType> and the trace as a whole forms a tree of these Activities, potentially spanning across many distinct processes.</span></span> <span data-ttu-id="b6b42-109">为新请求创建的第一个活动形成跟踪树的根，并跟踪处理请求的总体持续时间和成功/失败。</span><span class="sxs-lookup"><span data-stu-id="b6b42-109">The first Activity created for a new request forms the root of the trace tree and it tracks the overall duration and success/failure handling the request.</span></span> <span data-ttu-id="b6b42-110">可以选择创建子活动，以将工作细分为可单独跟踪的不同步骤。</span><span class="sxs-lookup"><span data-stu-id="b6b42-110">Child activities can be optionally created to sub-divide the work into different steps that can be tracked individually.</span></span>
<span data-ttu-id="b6b42-111">例如，假设某个活动跟踪了 Web 服务器中的特定入站 HTTP 请求，则可以创建子活动来跟踪完成请求所需的每个数据库查询。</span><span class="sxs-lookup"><span data-stu-id="b6b42-111">For example given an Activity that tracked a specific inbound HTTP request in a web server, child activites could be created to track each of the database queries that were necessary to complete the request.</span></span> <span data-ttu-id="b6b42-112">这样做可以单独记录每个查询的持续时间和成功情况。</span><span class="sxs-lookup"><span data-stu-id="b6b42-112">This allows the duration and success for each query to be recorded independently.</span></span>
<span data-ttu-id="b6b42-113">活动可以记录每个工作单元的其他信息，例如 <xref:System.Diagnostics.Activity.OperationName>、称为 <xref:System.Diagnostics.Activity.Tags> 的名称-值对和 <xref:System.Diagnostics.Activity.Events>。</span><span class="sxs-lookup"><span data-stu-id="b6b42-113">Activities can record other information for each unit of work such as <xref:System.Diagnostics.Activity.OperationName>, name-value pairs called <xref:System.Diagnostics.Activity.Tags>, and <xref:System.Diagnostics.Activity.Events>.</span></span> <span data-ttu-id="b6b42-114">名称标识所执行的工作类型；标记可以记录工作的描述性参数；事件是一种简单的日志记录机制，用于记录带时间戳的诊断消息。</span><span class="sxs-lookup"><span data-stu-id="b6b42-114">The name identifies the type of work being performed, tags can record descriptive parameters of the work, and events are a simple logging mechanism to record timestamped diagnostic messages.</span></span>

> [!NOTE]
> <span data-ttu-id="b6b42-115">分布式跟踪中工作单元的另一个常见的行业名称为“Span”。</span><span class="sxs-lookup"><span data-stu-id="b6b42-115">Another common industry name for units of work in a distributed trace are 'Spans'.</span></span>
> <span data-ttu-id="b6b42-116">.NET 在很多年前就采用了“Activity(活动)”这个术语，当时“Span”这个名称的概念还不为人们所了解。</span><span class="sxs-lookup"><span data-stu-id="b6b42-116">.NET adopted the term 'Activity' many years ago, before the name 'Span' was well established for this concept.</span></span>

### <a name="activity-ids"></a><span data-ttu-id="b6b42-117">活动 ID</span><span class="sxs-lookup"><span data-stu-id="b6b42-117">Activity IDs</span></span>

<span data-ttu-id="b6b42-118">使用唯一 ID 建立分布式跟踪树中活动之间的父-子关系。</span><span class="sxs-lookup"><span data-stu-id="b6b42-118">Parent-Child relationships between Activities in the distributed trace tree are established using unique IDs.</span></span> <span data-ttu-id="b6b42-119">.NET 分布式跟踪的实现支持两种 ID 方案，即 W3C 标准 [TraceContext](https://www.w3.org/TR/trace-context/)（这是 .NET 5 中的默认设置）和一个较早的名为“分层”的 .NET 约定（可用于后向兼容性）。</span><span class="sxs-lookup"><span data-stu-id="b6b42-119">.NET's implementation of distributed tracing supports two ID schemes, the W3C standard [TraceContext](https://www.w3.org/TR/trace-context/) which is the default in .NET 5 and an older .NET convention called 'Hierarchical' that is available for backwards compatibility.</span></span>
<span data-ttu-id="b6b42-120"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> 控制使用的 ID 方案。</span><span class="sxs-lookup"><span data-stu-id="b6b42-120"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> controls which ID scheme is used.</span></span> <span data-ttu-id="b6b42-121">在 W3C TraceContext 标准中，每个跟踪都分配有一个全局唯一的 16 字节跟踪 ID (<xref:System.Diagnostics.Activity.TraceId?displayProperty=nameWithType>)，且该跟踪内的每个活动都分配有唯一的 8 字节 Span ID (<xref:System.Diagnostics.Activity.SpanId?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="b6b42-121">In the W3C TraceContext standard every trace is assigned a globally unique 16 byte trace-id (<xref:System.Diagnostics.Activity.TraceId?displayProperty=nameWithType>) and every Activity within the trace is assigned a unique 8 byte span-id (<xref:System.Diagnostics.Activity.SpanId?displayProperty=nameWithType>).</span></span> <span data-ttu-id="b6b42-122">每个活动都记录跟踪 ID、其自身的 Span ID 以及其父 (<xref:System.Diagnostics.Activity.ParentSpanId?displayProperty=nameWithType>) 的 Span ID。</span><span class="sxs-lookup"><span data-stu-id="b6b42-122">Each Activity records the trace-id, its own span-id, and the span-id of its parent (<xref:System.Diagnostics.Activity.ParentSpanId?displayProperty=nameWithType>).</span></span> <span data-ttu-id="b6b42-123">由于分布式跟踪可以跟踪跨进程边界的工作，因此父活动和子活动可能不在同一进程中。</span><span class="sxs-lookup"><span data-stu-id="b6b42-123">Because distributed traces can track work across process boundaries parent and child Activities may not be in the same process.</span></span> <span data-ttu-id="b6b42-124">跟踪 ID 和父 Span ID 的组合可以在全局范围内仅标识父活动，无论该活动驻留在哪个进程中。</span><span class="sxs-lookup"><span data-stu-id="b6b42-124">The combination of a trace-id and parent span-id can uniquely identify the parent Activity globally, regardless of what process it resides in.</span></span>

<span data-ttu-id="b6b42-125"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> 控制使用哪种 ID 格式来启动新的跟踪，但默认情况下，如果将新活动添加到现有跟踪，则会使用任何父活动所使用的格式。</span><span class="sxs-lookup"><span data-stu-id="b6b42-125"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> controls which ID format is used for starting new traces, but by default adding a new Activity to an existing trace uses whatever format the parent Activity is using.</span></span>
<span data-ttu-id="b6b42-126">将 <xref:System.Diagnostics.Activity.ForceDefaultIdFormat?displayProperty=nameWithType> 设置为 true 会覆盖此行为，并使用 DefaultIdFormat 创建所有新的活动（即使父级使用其他 ID 格式也是如此）。</span><span class="sxs-lookup"><span data-stu-id="b6b42-126">Setting <xref:System.Diagnostics.Activity.ForceDefaultIdFormat?displayProperty=nameWithType> to true overrides this behavior and creates all new Activities with the DefaultIdFormat, even when the parent uses a different ID format.</span></span>

### <a name="starting-and-stopping-activities"></a><span data-ttu-id="b6b42-127">启动和停止活动</span><span class="sxs-lookup"><span data-stu-id="b6b42-127">Starting and stopping Activities</span></span>

<span data-ttu-id="b6b42-128">进程中的每个线程都有一个对应的 Activity 对象，该对象跟踪该线程上发生的工作，可通过 <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> 进行访问。</span><span class="sxs-lookup"><span data-stu-id="b6b42-128">Each thread in a process may have a corresponding Activity object that is tracking the work occuring on that thread, accessible via <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b6b42-129">当前活动会自动流过线程上的所有同步调用，以及在不同线程上处理的异步调用。</span><span class="sxs-lookup"><span data-stu-id="b6b42-129">The current activity automatically flows along all synchronous calls on a thread as well as following async calls that are processed on different threads.</span></span> <span data-ttu-id="b6b42-130">如果活动 A 是线程上的当前活动，并且代码启动新活动 B，则 B 将成为该线程上的新的当前活动。</span><span class="sxs-lookup"><span data-stu-id="b6b42-130">If Activity A is the current activity on a thread and code starts a new Activity B then B becomes the new current activity on that thread.</span></span> <span data-ttu-id="b6b42-131">默认情况下，活动 B 还会将活动 A 视为其父项。</span><span class="sxs-lookup"><span data-stu-id="b6b42-131">By default activity B will also treat Activity A as its parent.</span></span> <span data-ttu-id="b6b42-132">之后，当活动 B 停止时，活动 A 将还原为该线程上的当前活动。</span><span class="sxs-lookup"><span data-stu-id="b6b42-132">When Activity B is later stopped activity A will be restored as the current Activity on the thread.</span></span> <span data-ttu-id="b6b42-133">活动启动时，它会将当前时间捕获为 <xref:System.Diagnostics.Activity.StartTimeUtc?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b6b42-133">When an Activity is started it captures the current time as the <xref:System.Diagnostics.Activity.StartTimeUtc?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b6b42-134">停止时，会将 <xref:System.Diagnostics.Activity.Duration?displayProperty=nameWithType> 计算为当前时间与开始时间之间的差值。</span><span class="sxs-lookup"><span data-stu-id="b6b42-134">When it stops <xref:System.Diagnostics.Activity.Duration?displayProperty=nameWithType> is calculated as the difference between the current time and the start time.</span></span>

### <a name="coordinating-across-process-boundaries"></a><span data-ttu-id="b6b42-135">跨进程边界进行协调</span><span class="sxs-lookup"><span data-stu-id="b6b42-135">Coordinating across process boundaries</span></span>

<span data-ttu-id="b6b42-136">为了跟踪跨进程边界的工作，需要在网络中传输活动的父 ID，以便接收进程可以创建引用它们的活动。</span><span class="sxs-lookup"><span data-stu-id="b6b42-136">In order to track work across process boundaries Activity parent IDs need to be transmitted across the network so that the receiving process can create Activities that refer to them.</span></span> <span data-ttu-id="b6b42-137">使用 W3C TraceContext ID 格式时，.NET 还将使用[标准](https://www.w3.org/TR/trace-context/)推荐的 HTTP 标头来传输此信息。</span><span class="sxs-lookup"><span data-stu-id="b6b42-137">When using W3C TraceContext ID format .NET will also use the HTTP headers recommended by [the standard](https://www.w3.org/TR/trace-context/) to transmit this information.</span></span> <span data-ttu-id="b6b42-138">使用 <xref:System.Diagnostics.ActivityIdFormat.Hierarchical> ID 格式时，.NET 会使用自定义 request-id HTTP 标头来传输该 ID。</span><span class="sxs-lookup"><span data-stu-id="b6b42-138">When using the <xref:System.Diagnostics.ActivityIdFormat.Hierarchical> ID format .NET uses a custom request-id HTTP header to transmit the ID.</span></span> <span data-ttu-id="b6b42-139">与许多其他语言运行时不同，.NET 内置库（如 ASP.NET Web 服务器和 System.Net.Http）本机理解如何对 HTTP 消息上的活动 ID 进行解码和编码。</span><span class="sxs-lookup"><span data-stu-id="b6b42-139">Unlike many other language runtimes .NET in-box libraries such as the ASP.NET web server and System.Net.Http natively understand how to decode and encode Activity IDs on HTTP messages.</span></span> <span data-ttu-id="b6b42-140">运行时还理解如何通过同步和异步调用流式传输 ID。</span><span class="sxs-lookup"><span data-stu-id="b6b42-140">The runtime also understands how to flow the ID through sychronous and asynchronous calls.</span></span> <span data-ttu-id="b6b42-141">这意味着，接收和发出 HTTP 消息的 .NET 应用程序会自动参与到流动的分布式跟踪 ID 中，应用开发人员无需进行特殊编码，也无需依赖第三方库。</span><span class="sxs-lookup"><span data-stu-id="b6b42-141">This means that .NET applications that receive and emit HTTP messages participate in flowing distributed trace IDs automatically, with no special coding by the app developer nor 3rd party library dependencies.</span></span> <span data-ttu-id="b6b42-142">第三方库可以添加对通过非 HTTP 消息协议传输 ID 的支持，或者支持 HTTP 的自定义编码约定。</span><span class="sxs-lookup"><span data-stu-id="b6b42-142">3rd party libraries may add support for transmitting IDs over non-HTTP message protocols or supporting custom encoding conventions for HTTP.</span></span>

### <a name="collecting-traces"></a><span data-ttu-id="b6b42-143">收集跟踪</span><span class="sxs-lookup"><span data-stu-id="b6b42-143">Collecting traces</span></span>

<span data-ttu-id="b6b42-144">检测代码可以创建 <xref:System.Diagnostics.Activity> 对象作为分布式跟踪的一部分，但需将这些对象中的信息传输到集中持久性存储中并在其中进行序列化，以便以后可以对整个跟踪进行有用的查看。</span><span class="sxs-lookup"><span data-stu-id="b6b42-144">Instrumented code can create <xref:System.Diagnostics.Activity> objects as part of a distributed trace, but the information in these objects needs to be transmitted and serialized in a centralized persistant store so that the entire trace can be usefully reviewed later.</span></span> <span data-ttu-id="b6b42-145">有几个遥测收集库可以执行此任务，例如 [Application Insights](https://docs.microsoft.com/azure/azure-monitor/app/distributed-tracing)、[OpenTelemetry](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/docs/trace/getting-started/README.md) 或第三方遥测或 APM 供应商提供的库。</span><span class="sxs-lookup"><span data-stu-id="b6b42-145">There are several telemetry collection libraries that can do this task such as [Application Insights](https://docs.microsoft.com/azure/azure-monitor/app/distributed-tracing), [OpenTelemetry](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/docs/trace/getting-started/README.md), or a library provided by a 3rd party telemetry or APM vendor.</span></span> <span data-ttu-id="b6b42-146">或者，开发人员可以使用 <xref:System.Diagnostics.ActivityListener?displayProperty=nameWithType> 或 <xref:System.Diagnostics.DiagnosticListener?displayProperty=nameWithType> 创作自己的自定义活动遥测收集逻辑。</span><span class="sxs-lookup"><span data-stu-id="b6b42-146">Alternately developers can author their own custom Activity telemetry collection by using <xref:System.Diagnostics.ActivityListener?displayProperty=nameWithType> or <xref:System.Diagnostics.DiagnosticListener?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b6b42-147">ActivityListener 支持观察任何活动，无论开发人员是否对此有先验知识。</span><span class="sxs-lookup"><span data-stu-id="b6b42-147">ActivityListener supports observing any Activity regardless whether the developer has any a-priori knowledge about it.</span></span>
<span data-ttu-id="b6b42-148">因此，ActivityListener 是一种简单而灵活的常规用途解决方案。</span><span class="sxs-lookup"><span data-stu-id="b6b42-148">This makes ActivityListener a simple and flexible general purpose solution.</span></span> <span data-ttu-id="b6b42-149">与此相反，使用 DiagnosticListener 是一个更复杂的方案，该方案需要检测代码通过调用 <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> 来选择加入，而且集合库需要知道检测代码在启动时所使用的确切命名信息。</span><span class="sxs-lookup"><span data-stu-id="b6b42-149">By contrast using DiagnosticListener is a more complex scenario that requires the instrumented code to opt-in by invoking <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> and the collection library needs to know the exact naming information that the instrumented code used when starting it.</span></span> <span data-ttu-id="b6b42-150">使用 DiagnosticSource 和 DiagnosticListener，创建者和侦听器可以交换任意 .NET 对象并建立自定义的信息传递约定。</span><span class="sxs-lookup"><span data-stu-id="b6b42-150">Using DiagnosticSource and DiagnosticListener allows the creator and listener to exchange arbitrary .NET objects and establish customized information passing conventions.</span></span>

### <a name="sampling"></a><span data-ttu-id="b6b42-151">采样</span><span class="sxs-lookup"><span data-stu-id="b6b42-151">Sampling</span></span>

<span data-ttu-id="b6b42-152">为了改进高吞吐量应用程序的性能，.NET 上的分布式跟踪支持仅采样跟踪的一部分，而不是记录所有跟踪。</span><span class="sxs-lookup"><span data-stu-id="b6b42-152">For improved performance in high throughput applications, distributed tracing on .NET supports sampling only a subset of traces rather than recording all of them.</span></span> <span data-ttu-id="b6b42-153">对于使用推荐的 <xref:System.Diagnostics.ActivitySource.StartActivity%2A?displayProperty=nameWithType> API 创建的活动，遥测收集库可以使用 <xref:System.Diagnostics.ActivityListener.Sample%2A?displayProperty=nameWithType> 回调来控制采样。</span><span class="sxs-lookup"><span data-stu-id="b6b42-153">For activites created with the recommended <xref:System.Diagnostics.ActivitySource.StartActivity%2A?displayProperty=nameWithType> API, telemetry collection libraries can control sampling with the <xref:System.Diagnostics.ActivityListener.Sample%2A?displayProperty=nameWithType> callback.</span></span>
<span data-ttu-id="b6b42-154">日志记录库可以选择完全不创建活动，使用传播分布式跟踪 ID 所需的最小信息创建活动，或者用完整的诊断信息填充活动。</span><span class="sxs-lookup"><span data-stu-id="b6b42-154">The logging library can elect not to create the Activity at all, to create it with minimal information necessary to propagate distributing tracing IDs, or to populate it with complete diagnostic information.</span></span> <span data-ttu-id="b6b42-155">这些选择进行了权衡，增加了性能开销以提高诊断效用。</span><span class="sxs-lookup"><span data-stu-id="b6b42-155">These choices trade-off increasing performance overhead for increasing diagnostic utility.</span></span> <span data-ttu-id="b6b42-156">使用较旧的调用方式 <xref:System.Diagnostics.Activity.%23ctor%2A?displayProperty=nameWithType> 和 <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> 启动的活动，可以通过首先调用 <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A?displayProperty=nameWithType> 来支持 DiagnosticListener 采样。</span><span class="sxs-lookup"><span data-stu-id="b6b42-156">Activities that are started using the older pattern of invoking <xref:System.Diagnostics.Activity.%23ctor%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> may also support DiagnosticListener sampling by first calling <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A?displayProperty=nameWithType>.</span></span>
<span data-ttu-id="b6b42-157">即使在捕获完整的诊断信息时，.NET 实现也可以快速与高效的收集器耦合，同时，活动可以在新式硬件上以大约一微秒的时间创建、填充和传输。</span><span class="sxs-lookup"><span data-stu-id="b6b42-157">Even when capturing full diagnostic information the .NET implementation is designed to be fast - coupled with an efficient collector an Activity can be created, populated, and transmitted in about a microsecond on modern hardware.</span></span> <span data-ttu-id="b6b42-158">采样可以将每个未记录的活动的检测成本降低到小于 100 毫微秒。</span><span class="sxs-lookup"><span data-stu-id="b6b42-158">Sampling can reduce the instrumentation cost to less than 100 nanoseconds for each Activity that isn't recorded.</span></span>

## <a name="next-steps"></a><span data-ttu-id="b6b42-159">后续步骤</span><span class="sxs-lookup"><span data-stu-id="b6b42-159">Next steps</span></span>

<span data-ttu-id="b6b42-160">有关在 .NET 应用程序开始使用分布式跟踪的示例代码，请参见[分布式跟踪概述](distributed-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="b6b42-160">See the [Distributed Tracing Overview](distributed-tracing.md) for example code to get started using distributed tracing in .NET applications.</span></span>
