---
title: CA2016：将 CancellationToken 参数转发到采用一个该参数的方法（代码分析）
description: 了解代码分析规则 CA2016：将 CancellationToken 参数转发到采用一个该参数的方法
ms.date: 06/18/2020
ms.topic: reference
f1_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
helpviewer_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: b4945e35884f76aa28533ebab840b6a4a4cd2518
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "99751971"
---
# <a name="ca2016-forward-the-cancellationtoken-parameter-to-methods-that-take-one"></a><span data-ttu-id="27a1d-103">CA2016：将 CancellationToken 参数转发到采用一个该参数的方法</span><span class="sxs-lookup"><span data-stu-id="27a1d-103">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>

| | <span data-ttu-id="27a1d-104">值</span><span class="sxs-lookup"><span data-stu-id="27a1d-104">Value</span></span> |
|-|-|
| <span data-ttu-id="27a1d-105">**类型名称**</span><span class="sxs-lookup"><span data-stu-id="27a1d-105">**Type name**</span></span> |<span data-ttu-id="27a1d-106">ForwardCancellationTokenToInvocations</span><span class="sxs-lookup"><span data-stu-id="27a1d-106">ForwardCancellationTokenToInvocations</span></span>|
| <span data-ttu-id="27a1d-107">**规则 ID**</span><span class="sxs-lookup"><span data-stu-id="27a1d-107">**Rule ID**</span></span> |<span data-ttu-id="27a1d-108">CA2016</span><span class="sxs-lookup"><span data-stu-id="27a1d-108">CA2016</span></span>|
| <span data-ttu-id="27a1d-109">**类别**</span><span class="sxs-lookup"><span data-stu-id="27a1d-109">**Category**</span></span> |[<span data-ttu-id="27a1d-110">“性能”</span><span class="sxs-lookup"><span data-stu-id="27a1d-110">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="27a1d-111">**修复是中断修复还是非中断修复**</span><span class="sxs-lookup"><span data-stu-id="27a1d-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="27a1d-112">非中断</span><span class="sxs-lookup"><span data-stu-id="27a1d-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="27a1d-113">原因</span><span class="sxs-lookup"><span data-stu-id="27a1d-113">Cause</span></span>

<span data-ttu-id="27a1d-114">此规则查找可以接受 <xref:System.Threading.CancellationToken> 参数但不传递任何参数的方法调用，并建议将父方法的 `CancellationToken` 转发给它们。</span><span class="sxs-lookup"><span data-stu-id="27a1d-114">This rule locates method invocations that could accept a <xref:System.Threading.CancellationToken> parameter, but are not passing any, and suggests to forward the parent method's `CancellationToken` to them.</span></span>

## <a name="rule-description"></a><span data-ttu-id="27a1d-115">规则说明</span><span class="sxs-lookup"><span data-stu-id="27a1d-115">Rule description</span></span>

<span data-ttu-id="27a1d-116">此规则分析将 `CancellationToken` 作为其最后一个参数的方法定义，然后分析其主体中调用的所有方法。</span><span class="sxs-lookup"><span data-stu-id="27a1d-116">This rule analyzes method definitions that take a `CancellationToken` as their last parameter, then analyzes all methods invoked in its body.</span></span> <span data-ttu-id="27a1d-117">如果任何方法调用可以接受 `CancellationToken` 作为最后一个参数，或者具有将 `CancellationToken` 作为最后一个参数的重载，此规则将建议改用该选项，以确保将取消通知传播到可以侦听它的所有操作。</span><span class="sxs-lookup"><span data-stu-id="27a1d-117">If any of the method invocations can either accept a `CancellationToken` as the last parameter, or have an overload that takes a `CancellationToken` as the last parameter, then the rule suggests using that option instead to ensure that the cancellation notification gets propagated to all operations that can listen to it.</span></span>

> [!NOTE]
> <span data-ttu-id="27a1d-118">在 `CancellationToken` 类型可用的所有 .NET 版本中，规则 CA2016 都可用。</span><span class="sxs-lookup"><span data-stu-id="27a1d-118">Rule CA2016 is available in all .NET versions where the `CancellationToken` type is available.</span></span> <span data-ttu-id="27a1d-119">请参阅 [CancellationToken“适用于”部分](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span><span class="sxs-lookup"><span data-stu-id="27a1d-119">See [CancellationToken "Applies to" section](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="27a1d-120">如何解决冲突</span><span class="sxs-lookup"><span data-stu-id="27a1d-120">How to fix violations</span></span>

<span data-ttu-id="27a1d-121">可以手动修复，也可以选择让 Visual Studio 执行修复，方法是将鼠标悬停在方法调用旁显示的灯泡图标上，然后选择建议的更改。</span><span class="sxs-lookup"><span data-stu-id="27a1d-121">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span>

<span data-ttu-id="27a1d-122">下面的示例演示了两个建议的更改：</span><span class="sxs-lookup"><span data-stu-id="27a1d-122">The following example shows two suggested changes:</span></span>

![规则 CA2016 - 将 CancellationToken 参数转发到采用一个该参数的方法](media/ca2016-diagnose.png)

<span data-ttu-id="27a1d-124">如果不关心是否将已取消的操作通知转发给下层方法调用，则可禁止显示此规则的冲突。</span><span class="sxs-lookup"><span data-stu-id="27a1d-124">It's safe to suppress a violation of this rule if you're not concerned about forwarding the canceled operation notification to lower method invocations.</span></span> <span data-ttu-id="27a1d-125">也可以在 C# 中显式传递 `default`（在 Visual Basic 中为 `Nothing`）或 <xref:System.Threading.CancellationToken.None>，以禁止显示规则冲突。</span><span class="sxs-lookup"><span data-stu-id="27a1d-125">You can also explicitly pass `default` in C# (`Nothing` in Visual Basic) or <xref:System.Threading.CancellationToken.None> to suppress the rule violation.</span></span>

<span data-ttu-id="27a1d-126">此规则可以检测各种冲突。</span><span class="sxs-lookup"><span data-stu-id="27a1d-126">The rule can detect a variety of violations.</span></span> <span data-ttu-id="27a1d-127">下面的示例演示了此规则可检测的情况：</span><span class="sxs-lookup"><span data-stu-id="27a1d-127">The following examples show cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="27a1d-128">示例 1</span><span class="sxs-lookup"><span data-stu-id="27a1d-128">Example 1</span></span>

<span data-ttu-id="27a1d-129">此规则建议将 `c` 参数从 `MyMethod` 转发到 `MyMethodWithDefault` 调用，因为该方法定义了一个可选的令牌参数：</span><span class="sxs-lookup"><span data-stu-id="27a1d-129">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method defines an optional token parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="27a1d-130">解决方法：</span><span class="sxs-lookup"><span data-stu-id="27a1d-130">Fix:</span></span>

<span data-ttu-id="27a1d-131">转发 `c` 参数：</span><span class="sxs-lookup"><span data-stu-id="27a1d-131">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(c);
        }
```

<span data-ttu-id="27a1d-132">如果不关心是否要将取消通知转发给下层调用，可以：</span><span class="sxs-lookup"><span data-stu-id="27a1d-132">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="27a1d-133">显式传递 `default`：</span><span class="sxs-lookup"><span data-stu-id="27a1d-133">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(default);
        }
```

<span data-ttu-id="27a1d-134">或显式传递 `CancellationToken.None`：</span><span class="sxs-lookup"><span data-stu-id="27a1d-134">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(CancellationToken.None);
        }
```

### <a name="example-2"></a><span data-ttu-id="27a1d-135">示例 2</span><span class="sxs-lookup"><span data-stu-id="27a1d-135">Example 2</span></span>

<span data-ttu-id="27a1d-136">此规则建议将 `c` 参数从 `MyMethod` 转发到 `MyMethodWithDefault` 调用，因为该方法具有接受 `CancellationToken` 参数的重载：</span><span class="sxs-lookup"><span data-stu-id="27a1d-136">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method has an overload that takes a `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethodWithOverload(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="27a1d-137">解决方法：</span><span class="sxs-lookup"><span data-stu-id="27a1d-137">Fix:</span></span>

<span data-ttu-id="27a1d-138">转发 `c` 参数：</span><span class="sxs-lookup"><span data-stu-id="27a1d-138">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(c);
        }
```

<span data-ttu-id="27a1d-139">如果不关心是否要将取消通知转发给下层调用，可以：</span><span class="sxs-lookup"><span data-stu-id="27a1d-139">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="27a1d-140">显式传递 `default`：</span><span class="sxs-lookup"><span data-stu-id="27a1d-140">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(default);
        }
```

<span data-ttu-id="27a1d-141">或显式传递 `CancellationToken.None`：</span><span class="sxs-lookup"><span data-stu-id="27a1d-141">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(CancellationToken.None);
        }
```

## <a name="non-violation-examples"></a><span data-ttu-id="27a1d-142">不冲突的示例</span><span class="sxs-lookup"><span data-stu-id="27a1d-142">Non-violation examples</span></span>

<span data-ttu-id="27a1d-143">父方法中的 `CancellationToken` 参数不在最后位置：</span><span class="sxs-lookup"><span data-stu-id="27a1d-143">The `CancellationToken` parameter in the parent method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c, int lastParameter)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="27a1d-144">默认方法中的 `CancellationToken` 参数不在最后位置：</span><span class="sxs-lookup"><span data-stu-id="27a1d-144">The `CancellationToken` parameter in the default method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default, int lastParameter = 0)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="27a1d-145">重载方法中的 `CancellationToken` 参数不在最后位置：</span><span class="sxs-lookup"><span data-stu-id="27a1d-145">The `CancellationToken` parameter in the overload method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(int lastParameter)
        {
        }
        public static void MyMethodWithOverload(CancellationToken ct, int lastParameter)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="27a1d-146">父方法定义了多个 `CancellationToken` 参数：</span><span class="sxs-lookup"><span data-stu-id="27a1d-146">The parent method defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c1, CancellationToken c2)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="27a1d-147">具有默认值的方法定义了多个 `CancellationToken` 参数：</span><span class="sxs-lookup"><span data-stu-id="27a1d-147">The method with defaults defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken c1 = default, CancellationToken c2 = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="27a1d-148">方法重载定义了多个 `CancellationToken` 参数：</span><span class="sxs-lookup"><span data-stu-id="27a1d-148">The method overload defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(CancellationToken c1, CancellationToken c2)
        {
        }

        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```
