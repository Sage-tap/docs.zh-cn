---
title: 基于消息的异步通信
description: 适用于容器化 .NET 应用程序的 .NET 微服务体系结构 | 基于消息的异步通信是微服务体系结构中的一个重要概念，因为它是保持微服务彼此独立的同时使其最终同步的最佳方式。
ms.date: 01/13/2021
ms.openlocfilehash: f9d92e2640721b12d47223902712c420b06a5618
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/14/2021
ms.locfileid: "98189585"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="a130a-103">基于消息的异步通信</span><span class="sxs-lookup"><span data-stu-id="a130a-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="a130a-104">在多个微服务及其相关域模型中传播更改时，异步消息传递和事件驱动通信至关重要。</span><span class="sxs-lookup"><span data-stu-id="a130a-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="a130a-105">正如前面讨论微服务和绑定上下文 (BC) 时提到的那样，模型（用户、客户、产品、帐户等）对于不同微服务或 BC 的含义可能不同。</span><span class="sxs-lookup"><span data-stu-id="a130a-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="a130a-106">这意味着当发生更改时，需要通过某种方式来协调不同模型之间的更改。</span><span class="sxs-lookup"><span data-stu-id="a130a-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="a130a-107">其中一个解决方案就是基于异步消息传递的最终一致性和事件驱动通信。</span><span class="sxs-lookup"><span data-stu-id="a130a-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="a130a-108">使用消息传递时，各进程通过异步交换消息进行通信。</span><span class="sxs-lookup"><span data-stu-id="a130a-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="a130a-109">客户端通过向服务发送消息来向其发出命令或请求。</span><span class="sxs-lookup"><span data-stu-id="a130a-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="a130a-110">如果服务需进行回复，它会向客户端发回一条不同的消息。</span><span class="sxs-lookup"><span data-stu-id="a130a-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="a130a-111">由于这是一种基于消息的通信，因此客户端认为不会立即收到回复，甚至有可能根本就不会有回复。</span><span class="sxs-lookup"><span data-stu-id="a130a-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="a130a-112">消息由标头（标识或安全信息等元数据）和主体组成。</span><span class="sxs-lookup"><span data-stu-id="a130a-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="a130a-113">消息通常通过异步协议（如 AMQP）发送。</span><span class="sxs-lookup"><span data-stu-id="a130a-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="a130a-114">在微服务社区中，此类通信的首选基础结构是轻型消息代理，它与 SOA 中使用的大型代理和业务流程协调程序不同。</span><span class="sxs-lookup"><span data-stu-id="a130a-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="a130a-115">在轻型消息代理中，基础结构通常“很笨”，只能充当消息代理，并且包含简单的实现，例如 RabbitMQ 或云中的可缩放服务总线（如 Azure 服务总线）。</span><span class="sxs-lookup"><span data-stu-id="a130a-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="a130a-116">在此方案中，大多数“聪明”的想法仍然停留在生成和使用消息的终结点（也就是微服务）中。</span><span class="sxs-lookup"><span data-stu-id="a130a-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="a130a-117">另一个应尽量遵循的规则是，仅在内部服务之间使用异步消息传递，以及仅从客户端应用到前端服务（API 网关以及第一级微服务）使用同步通信（例如 HTTP）。</span><span class="sxs-lookup"><span data-stu-id="a130a-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="a130a-118">有两种异步消息通信：基于消息的单接收者通信和基于消息的多接收者通信。</span><span class="sxs-lookup"><span data-stu-id="a130a-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="a130a-119">以下部分提供了有关这两种通信的详细信息。</span><span class="sxs-lookup"><span data-stu-id="a130a-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="a130a-120">基于消息的单接收者通信</span><span class="sxs-lookup"><span data-stu-id="a130a-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="a130a-121">具有单个接收者的基于消息的异步通信意味着存在点到点通信，即，仅向正在从该通道读取数据的一个使用者传递消息，并且该消息仅处理一次。</span><span class="sxs-lookup"><span data-stu-id="a130a-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="a130a-122">不过也有一些特殊情况。</span><span class="sxs-lookup"><span data-stu-id="a130a-122">However, there are special situations.</span></span> <span data-ttu-id="a130a-123">例如，在试图从故障中自动恢复的云系统中，可以多次发送相同的消息。</span><span class="sxs-lookup"><span data-stu-id="a130a-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="a130a-124">由于网络或其他故障，客户端必须能够重试发送消息，并且服务器必须实现幂等操作，以便对特定消息仅处理一次。</span><span class="sxs-lookup"><span data-stu-id="a130a-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="a130a-125">基于消息的单接收者通信特别适用于将异步命令从一个微服务发送到另一个微服务，图 4-18 便阐释了这种方法。</span><span class="sxs-lookup"><span data-stu-id="a130a-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="a130a-126">一旦开始发送基于消息的通信（通过命令或事件），就应该避免将基于消息的通信与同步 HTTP 通信混合在一起。</span><span class="sxs-lookup"><span data-stu-id="a130a-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![接收异步消息的单个微服务](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="a130a-128">**图 4-18**.</span><span class="sxs-lookup"><span data-stu-id="a130a-128">**Figure 4-18**.</span></span> <span data-ttu-id="a130a-129">接收异步消息的单个微服务</span><span class="sxs-lookup"><span data-stu-id="a130a-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="a130a-130">当命令来自客户端应用程序时，它们可以作为 HTTP 同步命令实现。</span><span class="sxs-lookup"><span data-stu-id="a130a-130">When the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="a130a-131">如果需要更高的可伸缩性或者已经处于基于消息的业务流程中，使用基于消息的命令。</span><span class="sxs-lookup"><span data-stu-id="a130a-131">Use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="a130a-132">基于消息的多接收者通信</span><span class="sxs-lookup"><span data-stu-id="a130a-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="a130a-133">作为一种更灵活的方法，你可能还需要使用发布/订阅机制，以便其他订阅者微服务或外部应用程序能够收到发送者发送的通信。</span><span class="sxs-lookup"><span data-stu-id="a130a-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="a130a-134">因此，它可以帮助你遵循发送服务中的[开/闭原理](https://en.wikipedia.org/wiki/Open/closed_principle)。</span><span class="sxs-lookup"><span data-stu-id="a130a-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="a130a-135">这样一来，以后无需修改发送者服务也可添加额外的订阅者。</span><span class="sxs-lookup"><span data-stu-id="a130a-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="a130a-136">使用发布/订阅通信时，你可能会使用事件总线接口向任何订阅者发布事件。</span><span class="sxs-lookup"><span data-stu-id="a130a-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="a130a-137">事件驱动的异步通信</span><span class="sxs-lookup"><span data-stu-id="a130a-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="a130a-138">使用事件驱动的异步通信时，微服务会在其域中发生变化时发布集成事件，而另一个微服务需要知道该变化，例如产品目录微服务中的价格变化。</span><span class="sxs-lookup"><span data-stu-id="a130a-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="a130a-139">其他微服务会订阅这些事件，以便以异步方式接收它们。</span><span class="sxs-lookup"><span data-stu-id="a130a-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="a130a-140">发生这种情况时，接收者可能会更新自己的域实体，这可能会导致发布更多的集成事件。</span><span class="sxs-lookup"><span data-stu-id="a130a-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="a130a-141">通过使用事件总线实现来执行此发布/订阅系统。</span><span class="sxs-lookup"><span data-stu-id="a130a-141">This publish/subscribe system is performed by using an implementation of an event bus.</span></span> <span data-ttu-id="a130a-142">事件总线可以设计成包含 API 的抽象或接口，订阅或取消订阅事件以及发布事件时需使用该 API。</span><span class="sxs-lookup"><span data-stu-id="a130a-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="a130a-143">事件总线还可以包含一个或多个基于任意内部进程和消息传递代理的实现，例如支持异步通信和发布/订阅模型的消息传递队列或服务总线。</span><span class="sxs-lookup"><span data-stu-id="a130a-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="a130a-144">如果系统使用受集成事件驱动的最终一致性，建议让最终用户清楚这种方法。</span><span class="sxs-lookup"><span data-stu-id="a130a-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made clear to the end user.</span></span> <span data-ttu-id="a130a-145">系统不应使用模拟集成事件的方法，例如 SignalR 或客户端轮询系统。</span><span class="sxs-lookup"><span data-stu-id="a130a-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="a130a-146">最终用户和业务所有者必须显式接受系统中的最终一致性，并意识到在许多情况下，只要显式使用该方法，业务就不会有任何问题。</span><span class="sxs-lookup"><span data-stu-id="a130a-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="a130a-147">此方法很重要，因为用户可能希望立即看到一些结果，但在使用最终一致性时可能无法实现这一点。</span><span class="sxs-lookup"><span data-stu-id="a130a-147">This approach is important because users might expect to see some results immediately and this aspect might not happen with eventual consistency.</span></span>

<span data-ttu-id="a130a-148">如前面的[分布式数据管理挑战和解决方案](distributed-data-management.md)部分所述，可以使用集成事件来实现跨多个微服务的业务任务。</span><span class="sxs-lookup"><span data-stu-id="a130a-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="a130a-149">这样就可以在这些服务之间实现最终一致性。</span><span class="sxs-lookup"><span data-stu-id="a130a-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="a130a-150">最终一致事务由一组分布式操作组成。</span><span class="sxs-lookup"><span data-stu-id="a130a-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="a130a-151">在执行每个操作时，相关微服务会更新域实体，并发布另一个集成事件，以便在相同的端到端业务任务中引发下一个操作。</span><span class="sxs-lookup"><span data-stu-id="a130a-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="a130a-152">很重要的一点是，你可能想要与订阅同一事件的多个微服务进行通信。</span><span class="sxs-lookup"><span data-stu-id="a130a-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="a130a-153">为此，可以使用基于事件驱动通信的发布/订阅消息传递，如图 4-19 所示。</span><span class="sxs-lookup"><span data-stu-id="a130a-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="a130a-154">这种发布/订阅机制并不是微服务体系结构所独有的。</span><span class="sxs-lookup"><span data-stu-id="a130a-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="a130a-155">它类似于 DDD 中[界定上下文](https://martinfowler.com/bliki/BoundedContext.html)的通信方式，或者类似于在[命令和查询责任分离 (CQRS)](https://martinfowler.com/bliki/CQRS.html) 体系结构模式中将更新从写入数据库传播到读取数据库的方式。</span><span class="sxs-lookup"><span data-stu-id="a130a-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="a130a-156">其目标是在分布式系统中的多个数据源之间实现最终一致性。</span><span class="sxs-lookup"><span data-stu-id="a130a-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![显示异步事件驱动的通信的示意图。](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="a130a-158">**图 4-19**.</span><span class="sxs-lookup"><span data-stu-id="a130a-158">**Figure 4-19**.</span></span> <span data-ttu-id="a130a-159">事件驱动的异步消息通信</span><span class="sxs-lookup"><span data-stu-id="a130a-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="a130a-160">在事件驱动的异步通信中，一个微服务将事件发布到事件总线，许多微服务可以订阅它，以获取通知并对其进行操作。</span><span class="sxs-lookup"><span data-stu-id="a130a-160">In asynchronous event-driven communication, one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="a130a-161">你的实现将决定要用于基于消息的事件驱动通信的协议。</span><span class="sxs-lookup"><span data-stu-id="a130a-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="a130a-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) 有助于实现可靠的排队通信。</span><span class="sxs-lookup"><span data-stu-id="a130a-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="a130a-163">使用事件总线时，你可能希望将基于类中相关实现的抽象级别（如事件总线接口）与使用 API（来自消息代理，如 [RabbitMQ](https://www.rabbitmq.com/)，或来自服务总线，如 [Azure 服务总线及主题](/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)）的代码结合使用。</span><span class="sxs-lookup"><span data-stu-id="a130a-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="a130a-164">或者，你可能希望使用 NServiceBus、MassTransit 或 Brighter 等更高级别的服务总线来清楚地表述你的事件总线和发布/订阅系统。</span><span class="sxs-lookup"><span data-stu-id="a130a-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="a130a-165">关于生产系统消息传递技术的说明</span><span class="sxs-lookup"><span data-stu-id="a130a-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="a130a-166">可用于实现抽象事件总线的消息传递技术的级别不尽相同。</span><span class="sxs-lookup"><span data-stu-id="a130a-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="a130a-167">例如，RabbitMQ（一种消息传递代理传输）和 Azure 服务总线等产品的级别低于可在 RabbitMQ 和 Azure 服务总线之上运行的 NServiceBus、MassTransit 或 Brighter 等其他产品的级别。</span><span class="sxs-lookup"><span data-stu-id="a130a-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="a130a-168">你的选择取决于应用程序级别的丰富功能数量以及应用程序所需的现成可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="a130a-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="a130a-169">如果只是为开发环境实现事件总线概念证明，那么正如我们在 eShopOnContainers 示例中所做的那样，基于 Docker 容器上运行的 RabbitMQ 的简单实现可能就足够了。</span><span class="sxs-lookup"><span data-stu-id="a130a-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="a130a-170">但对于需要超高可伸缩性的任务关键系统和生产系统，可能需要评估 Azure 服务总线。</span><span class="sxs-lookup"><span data-stu-id="a130a-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="a130a-171">对于可简化分布式应用程序开发的高级抽象和功能，建议评估其他商用和开源服务总线，例如 NServiceBus、MassTransit 和 Brighter。</span><span class="sxs-lookup"><span data-stu-id="a130a-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="a130a-172">当然，你也可以在 RabbitMQ 和 Docker 等较低级别技术的基础上构建自己的服务总线功能。</span><span class="sxs-lookup"><span data-stu-id="a130a-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="a130a-173">但是，对于自定义企业应用程序而言，这种管道工作的成本可能太高。</span><span class="sxs-lookup"><span data-stu-id="a130a-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="a130a-174">弹性地发布到事件总线</span><span class="sxs-lookup"><span data-stu-id="a130a-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="a130a-175">在多个微服务中实现事件驱动体系结构时面临的挑战是，如何在原始微服务中以原子方式更新状态，同时将其相关集成事件弹性地发布到事件总线中（在某种程度上基于事务）。</span><span class="sxs-lookup"><span data-stu-id="a130a-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="a130a-176">下面介绍了实现此功能的几种方法，但也可能有其他方法。</span><span class="sxs-lookup"><span data-stu-id="a130a-176">The following are a few ways to accomplish this functionality, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="a130a-177">使用事务（基于 DTC）队列，如 MSMQ。</span><span class="sxs-lookup"><span data-stu-id="a130a-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="a130a-178">（不过，这是一种传统方法。）</span><span class="sxs-lookup"><span data-stu-id="a130a-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="a130a-179">使用事务日志挖掘。</span><span class="sxs-lookup"><span data-stu-id="a130a-179">Using transaction log mining.</span></span>

- <span data-ttu-id="a130a-180">使用完整[事件溯源](/azure/architecture/patterns/event-sourcing)模式。</span><span class="sxs-lookup"><span data-stu-id="a130a-180">Using full [Event Sourcing](/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="a130a-181">使用[发件箱模式](https://www.kamilgrzybek.com/design/the-outbox-pattern/)：将用作消息队列的事务数据库表作为事件创建器组件的基础，该组件将创建并发布事件。</span><span class="sxs-lookup"><span data-stu-id="a130a-181">Using the [Outbox pattern](https://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="a130a-182">使用异步通信时需要考虑的其他主题包括消息幂等性和重复消息删除。</span><span class="sxs-lookup"><span data-stu-id="a130a-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="a130a-183">这些主题将在本指南后面的[在微服务（集成事件）之间实现基于事件的通信](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md)部分中进行介绍。</span><span class="sxs-lookup"><span data-stu-id="a130a-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a130a-184">其他资源</span><span class="sxs-lookup"><span data-stu-id="a130a-184">Additional resources</span></span>

- <span data-ttu-id="a130a-185">**事件驱动的消息传递** </span><span class="sxs-lookup"><span data-stu-id="a130a-185">**Event Driven Messaging** </span></span>\
  <https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging>

- <span data-ttu-id="a130a-186">**发布/订阅通道** </span><span class="sxs-lookup"><span data-stu-id="a130a-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="a130a-187">**Udi Dahan.明确的 CQRS** </span><span class="sxs-lookup"><span data-stu-id="a130a-187">**Udi Dahan. Clarified CQRS** </span></span>\
  <https://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="a130a-188">**命令和查询责任分离 (CQRS)**  </span><span class="sxs-lookup"><span data-stu-id="a130a-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="a130a-189">**界定上下文之间的通信** </span><span class="sxs-lookup"><span data-stu-id="a130a-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="a130a-190">**最终一致性** </span><span class="sxs-lookup"><span data-stu-id="a130a-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="a130a-191">**Jimmy Bogard。重构复原能力：评估耦合度** </span><span class="sxs-lookup"><span data-stu-id="a130a-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="a130a-192">[上一页](communication-in-microservice-architecture.md)
> [下一页](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="a130a-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
