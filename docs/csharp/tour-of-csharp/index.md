---
title: C# 介绍 - C# 指南
description: 刚开始接触 C#？ 了解 C# 语言的基础知识。 从此概述开始。
ms.date: 01/28/2021
ms.openlocfilehash: b58aed5e75be8c71df295506480a2d97c22675aa
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/04/2021
ms.locfileid: "102104908"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="330c5-105">C# 语言介绍</span><span class="sxs-lookup"><span data-stu-id="330c5-105">A tour of the C# language</span></span>

<span data-ttu-id="330c5-106">C#（读作“See Sharp”）是一种新式编程语言，不仅面向对象，还类型安全。</span><span class="sxs-lookup"><span data-stu-id="330c5-106">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="330c5-107">开发人员利用 C# 能够生成在 .NET 生态系统中运行的多种安全可靠的应用程序。</span><span class="sxs-lookup"><span data-stu-id="330c5-107">C# enables developers to build many types of secure and robust applications that run in the .NET ecosystem.</span></span> <span data-ttu-id="330c5-108">C# 源于 C 语言系列，C、C++、Java 和 JavaScript 程序员很快就可以上手使用。</span><span class="sxs-lookup"><span data-stu-id="330c5-108">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="330c5-109">本教程概述了 C# 8 及更高版本中该语言的主要组件。</span><span class="sxs-lookup"><span data-stu-id="330c5-109">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="330c5-110">如果想要通过交互式示例探索语言，请尝试 [C# 简介](./tutorials/index.md)教程。</span><span class="sxs-lookup"><span data-stu-id="330c5-110">If you want to explore the language through interactive examples, try the [introduction to C#](./tutorials/index.md) tutorials.</span></span>

<span data-ttu-id="330c5-111">C# 是面向对象的、面向组件的编程语言。</span><span class="sxs-lookup"><span data-stu-id="330c5-111">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="330c5-112">C# 提供了语言构造来直接支持这些概念，让 C# 成为一种非常自然的语言，可用于创建和使用软件组件。</span><span class="sxs-lookup"><span data-stu-id="330c5-112">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="330c5-113">自诞生之日起，C# 就添加了支持新工作负载和新兴软件设计实践的功能。</span><span class="sxs-lookup"><span data-stu-id="330c5-113">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="330c5-114">多项 C# 功能有助于创建可靠且持久的应用程序。</span><span class="sxs-lookup"><span data-stu-id="330c5-114">Several C# features help create robust and durable applications.</span></span> <span data-ttu-id="330c5-115">[垃圾回收](../../standard/garbage-collection/index.md)\*_自动回收不可访问的未用对象所占用的内存。</span><span class="sxs-lookup"><span data-stu-id="330c5-115">[\***Garbage collection** _](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="330c5-116">[可以为 null 的类型](../nullable-references.md)可防范不引用已分配对象的变量。</span><span class="sxs-lookup"><span data-stu-id="330c5-116">[_*_Nullable types_*_](../nullable-references.md) guard against variables that don't refer to allocated objects.</span></span> <span data-ttu-id="330c5-117">[异常处理](../programming-guide/exceptions/index.md)提供了一种结构化且可扩展的方法来进行错误检测和恢复。</span><span class="sxs-lookup"><span data-stu-id="330c5-117">[_*_Exception handling_*_](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="330c5-118">[Lambda 表达式](../language-reference/operators/lambda-expressions.md)支持函数编程技术。</span><span class="sxs-lookup"><span data-stu-id="330c5-118">[_*_Lambda expressions_*_](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="330c5-119">[语言集成查询 (LINQ)](../linq/index.md) 语法创建一个公共模式，用于处理来自任何源的数据。</span><span class="sxs-lookup"><span data-stu-id="330c5-119">[_*_Language Integrated Query (LINQ)_*_](../linq/index.md) syntax creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="330c5-120">[异步操作](../programming-guide/concepts/async/index.md)语言支持提供用于构建分布式系统的语法。</span><span class="sxs-lookup"><span data-stu-id="330c5-120">Language support for [_*_asynchronous operations_*_](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="330c5-121">C# 有[统一类型系统](../programming-guide/types/index.md)_\*。</span><span class="sxs-lookup"><span data-stu-id="330c5-121">C# has a [_ *_unified type system_*\*](../programming-guide/types/index.md).</span></span> <span data-ttu-id="330c5-122">所有 C# 类型（包括 `int` 和 `double` 等基元类型）均继承自一个根 `object` 类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-122">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="330c5-123">所有类型共用一组通用运算。</span><span class="sxs-lookup"><span data-stu-id="330c5-123">All types share a set of common operations.</span></span> <span data-ttu-id="330c5-124">任何类型的值都可以一致地进行存储、传输和处理。</span><span class="sxs-lookup"><span data-stu-id="330c5-124">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="330c5-125">此外，C# 还支持用户定义的[引用类型](../language-reference/builtin-types/reference-types.md)和[值类型](../language-reference/builtin-types/value-types.md)。</span><span class="sxs-lookup"><span data-stu-id="330c5-125">Furthermore, C# supports both user-defined [reference types](../language-reference/builtin-types/reference-types.md) and [value types](../language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="330c5-126">C# 允许动态分配轻型结构的对象和内嵌存储。</span><span class="sxs-lookup"><span data-stu-id="330c5-126">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span> <span data-ttu-id="330c5-127">C# 支持泛型方法和类型，因此增强了类型安全性和性能。</span><span class="sxs-lookup"><span data-stu-id="330c5-127">C# supports generic methods and types, which provide increased type safety and performance.</span></span> <span data-ttu-id="330c5-128">C# 可提供迭代器，使集合类的实现者可以定义客户端代码的自定义行为。</span><span class="sxs-lookup"><span data-stu-id="330c5-128">C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.</span></span>

<span data-ttu-id="330c5-129">C# 强调版本控制，以确保程序和库以兼容方式随时间推移而变化。</span><span class="sxs-lookup"><span data-stu-id="330c5-129">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="330c5-130">C# 设计中受版本控制加强直接影响的方面包括：单独的 `virtual` 和 `override` 修饰符，关于方法重载决策的规则，以及对显式接口成员声明的支持。</span><span class="sxs-lookup"><span data-stu-id="330c5-130">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="net-architecture"></a><span data-ttu-id="330c5-131">.NET 体系结构</span><span class="sxs-lookup"><span data-stu-id="330c5-131">.NET architecture</span></span>

<span data-ttu-id="330c5-132">C# 程序在 .NET 上运行，而 .NET 是名为公共语言运行时 (CLR) 的虚执行系统和一组类库。</span><span class="sxs-lookup"><span data-stu-id="330c5-132">C# programs run on .NET, a virtual execution system called the common language runtime (CLR) and a set of class libraries.</span></span> <span data-ttu-id="330c5-133">CLR 是 Microsoft 对公共语言基础结构 (CLI) 国际标准的实现。</span><span class="sxs-lookup"><span data-stu-id="330c5-133">The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard.</span></span> <span data-ttu-id="330c5-134">CLI 是创建执行和开发环境的基础，语言和库可以在其中无缝地协同工作。</span><span class="sxs-lookup"><span data-stu-id="330c5-134">The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly.</span></span>

<span data-ttu-id="330c5-135">用 C# 编写的源代码被编译成符合 CLI 规范的[中间语言 (IL)](../../standard/managed-code.md)。</span><span class="sxs-lookup"><span data-stu-id="330c5-135">Source code written in C# is compiled into an [intermediate language (IL)](../../standard/managed-code.md) that conforms to the CLI specification.</span></span> <span data-ttu-id="330c5-136">IL 代码和资源（如位图和字符串）存储在扩展名通常为 .dll 的程序集中。</span><span class="sxs-lookup"><span data-stu-id="330c5-136">The IL code and resources, such as bitmaps and strings, are stored in an assembly, typically with an extension of *.dll*.</span></span> <span data-ttu-id="330c5-137">程序集包含一个介绍程序集的类型、版本和区域性的清单。</span><span class="sxs-lookup"><span data-stu-id="330c5-137">An assembly contains a manifest that provides information about the assembly's types, version, and culture.</span></span>

<span data-ttu-id="330c5-138">执行 C# 程序时，程序集将加载到 CLR。</span><span class="sxs-lookup"><span data-stu-id="330c5-138">When the C# program is executed, the assembly is loaded into the CLR.</span></span> <span data-ttu-id="330c5-139">CLR 会直接执行实时 (JIT) 编译，将 IL 代码转换成本机指令。</span><span class="sxs-lookup"><span data-stu-id="330c5-139">The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions.</span></span> <span data-ttu-id="330c5-140">CLR 可提供其他与自动垃圾回收、异常处理和资源管理相关的服务。</span><span class="sxs-lookup"><span data-stu-id="330c5-140">The CLR provides other services related to automatic garbage collection, exception handling, and resource management.</span></span> <span data-ttu-id="330c5-141">CLR 执行的代码有时称为“托管代码”（而不是“非托管代码”），被编译成面向特定平台的本机语言。</span><span class="sxs-lookup"><span data-stu-id="330c5-141">Code that's executed by the CLR is sometimes referred to as "managed code," in contrast to "unmanaged code," which is compiled into native machine language that targets a specific platform.</span></span>

<span data-ttu-id="330c5-142">语言互操作性是 .NET 的一项重要功能。</span><span class="sxs-lookup"><span data-stu-id="330c5-142">Language interoperability is a key feature of .NET.</span></span> <span data-ttu-id="330c5-143">C# 编译器生成的 IL 代码符合公共类型规范 (CTS)。</span><span class="sxs-lookup"><span data-stu-id="330c5-143">IL code produced by the C# compiler conforms to the Common Type Specification (CTS).</span></span> <span data-ttu-id="330c5-144">通过 C# 生成的 IL 代码可以与通过 .NET 版本的 F#、Visual Basic、C++ 或其他 20 多种与 CTS 兼容的任何语言所生成的代码进行交互。</span><span class="sxs-lookup"><span data-stu-id="330c5-144">IL code generated from C# can interact with code that was generated from the .NET versions of F#, Visual Basic, C++, or any of more than 20 other CTS-compliant languages.</span></span> <span data-ttu-id="330c5-145">一个程序集可能包含多个用不同 .NET 语言编写的模块，且类型可以相互引用，就像是用同一种语言编写的一样。</span><span class="sxs-lookup"><span data-stu-id="330c5-145">A single assembly may contain multiple modules written in different .NET languages, and the types can reference each other as if they were written in the same language.</span></span>

<span data-ttu-id="330c5-146">除了运行时服务之外，.NET 还包含大量库。</span><span class="sxs-lookup"><span data-stu-id="330c5-146">In addition to the run time services, .NET also includes extensive libraries.</span></span> <span data-ttu-id="330c5-147">这些库支持多种不同的工作负载。</span><span class="sxs-lookup"><span data-stu-id="330c5-147">These libraries support many different workloads.</span></span> <span data-ttu-id="330c5-148">它们已整理到命名空间中，这些命名空间提供各种实用功能，包括文件输入输出、字符串控制、XML 分析、Web 应用程序框架和 Windows 窗体控件。</span><span class="sxs-lookup"><span data-stu-id="330c5-148">They're organized into namespaces that provide a wide variety of useful functionality for everything from file input and output to string manipulation to XML parsing, to web application frameworks to Windows Forms controls.</span></span> <span data-ttu-id="330c5-149">典型的 C# 应用程序广泛使用 .NET 类库来处理常见的“管道”零碎工作。</span><span class="sxs-lookup"><span data-stu-id="330c5-149">The typical C# application uses the .NET class library extensively to handle common "plumbing" chores.</span></span>

<span data-ttu-id="330c5-150">有关 .NET 的详细信息，请参阅 [.NET 概述](../../core/introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="330c5-150">For more information about .NET, see [Overview of .NET](../../core/introduction.md).</span></span>

## <a name="hello-world"></a><span data-ttu-id="330c5-151">Hello world</span><span class="sxs-lookup"><span data-stu-id="330c5-151">Hello world</span></span>

<span data-ttu-id="330c5-152">“Hello, World”程序历来都用于介绍编程语言。</span><span class="sxs-lookup"><span data-stu-id="330c5-152">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="330c5-153">下面展示了此程序的 C# 代码：</span><span class="sxs-lookup"><span data-stu-id="330c5-153">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="330c5-154">“Hello, World”程序始于引用 `System` 命名空间的 `using` 指令。</span><span class="sxs-lookup"><span data-stu-id="330c5-154">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="330c5-155">命名空间提供了一种用于组织 C# 程序和库的分层方法。</span><span class="sxs-lookup"><span data-stu-id="330c5-155">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="330c5-156">命名空间包含类型和其他命名空间。例如，`System` 命名空间包含许多类型（如程序中引用的 `Console` 类）和其他许多命名空间（如 `IO` 和 `Collections`）。</span><span class="sxs-lookup"><span data-stu-id="330c5-156">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="330c5-157">借助引用给定命名空间的 `using` 指令，可以非限定的方式使用作为相应命名空间成员的类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-157">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="330c5-158">由于使用 `using` 指令，因此程序可以使用 `Console.WriteLine` 作为 `System.Console.WriteLine` 的简写。</span><span class="sxs-lookup"><span data-stu-id="330c5-158">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="330c5-159">“Hello, World”程序声明的 `Hello` 类只有一个成员，即 `Main` 方法。</span><span class="sxs-lookup"><span data-stu-id="330c5-159">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="330c5-160">`Main` 方法使用 `static` 修饰符进行声明。</span><span class="sxs-lookup"><span data-stu-id="330c5-160">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="330c5-161">实例方法可以使用关键字 `this` 引用特定的封闭对象实例，而静态方法则可以在不引用特定对象的情况下运行。</span><span class="sxs-lookup"><span data-stu-id="330c5-161">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="330c5-162">按照约定，`Main` 静态方法是 C# 程序的入口点。</span><span class="sxs-lookup"><span data-stu-id="330c5-162">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="330c5-163">程序的输出是由 `System` 命名空间中 `Console` 类的 `WriteLine` 方法生成。</span><span class="sxs-lookup"><span data-stu-id="330c5-163">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="330c5-164">此类由标准类库提供。默认情况下，编译器会自动引用标准类库。</span><span class="sxs-lookup"><span data-stu-id="330c5-164">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="330c5-165">类型和变量</span><span class="sxs-lookup"><span data-stu-id="330c5-165">Types and variables</span></span>

<span data-ttu-id="330c5-166">C# 有两种类型：*值类型* 和 *引用类型*。</span><span class="sxs-lookup"><span data-stu-id="330c5-166">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="330c5-167">值类型的变量直接包含它们的数据。</span><span class="sxs-lookup"><span data-stu-id="330c5-167">Variables of value types directly contain their data.</span></span> <span data-ttu-id="330c5-168">引用类型的变量存储对数据（称为“对象”）的引用。</span><span class="sxs-lookup"><span data-stu-id="330c5-168">Variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="330c5-169">对于引用类型，两个变量可以引用同一个对象；对一个变量执行的运算可能会影响另一个变量引用的对象。</span><span class="sxs-lookup"><span data-stu-id="330c5-169">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="330c5-170">借助值类型，每个变量都有自己的数据副本；因此，对一个变量执行的运算不会影响另一个变量（`ref` 和 `out` 参数变量除外）。</span><span class="sxs-lookup"><span data-stu-id="330c5-170">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="330c5-171">标识符为变量名称。</span><span class="sxs-lookup"><span data-stu-id="330c5-171">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="330c5-172">标识符是不包含任何空格的 unicode 字符序列。</span><span class="sxs-lookup"><span data-stu-id="330c5-172">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="330c5-173">如果标识符的前缀为 `@`，则该标识符可以是 C# 保留字。</span><span class="sxs-lookup"><span data-stu-id="330c5-173">An identifier may be a C# reserved word, if it's prefixed by `@`.</span></span> <span data-ttu-id="330c5-174">在与其他语言交互时，使用保留字作为标识符很有用。</span><span class="sxs-lookup"><span data-stu-id="330c5-174">Using a reserved word as an identifier can be useful when interacting with other languages.</span></span>

<span data-ttu-id="330c5-175">C# 的值类型进一步分为：简单类型、枚举类型、结构类型、可以为 null 的值类型和元组值类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-175">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, *nullable value types*, and *tuple value types*.</span></span> <span data-ttu-id="330c5-176">C# 引用类型又细分为类类型、接口类型、数组类型和委托类型。    </span><span class="sxs-lookup"><span data-stu-id="330c5-176">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="330c5-177">以下大纲概述了 C# 的类型系统。</span><span class="sxs-lookup"><span data-stu-id="330c5-177">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="330c5-178">值类型</span><span class="sxs-lookup"><span data-stu-id="330c5-178">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="330c5-179">简单类型</span><span class="sxs-lookup"><span data-stu-id="330c5-179">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="330c5-180">[有符号整型](../language-reference/builtin-types/integral-numeric-types.md)：`sbyte`、`short`、`int`、`long`</span><span class="sxs-lookup"><span data-stu-id="330c5-180">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="330c5-181">[无符号整型](../language-reference/builtin-types/integral-numeric-types.md)：`byte`、`ushort`、`uint`、`ulong`</span><span class="sxs-lookup"><span data-stu-id="330c5-181">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="330c5-182">[Unicode 字符](../../standard/base-types/character-encoding-introduction.md)：`char`，表示 UTF-16 代码单元</span><span class="sxs-lookup"><span data-stu-id="330c5-182">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="330c5-183">[IEEE 二进制浮点](../language-reference/builtin-types/floating-point-numeric-types.md)：`float`、`double`</span><span class="sxs-lookup"><span data-stu-id="330c5-183">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="330c5-184">[高精度十进制浮点数](../language-reference/builtin-types/floating-point-numeric-types.md)：`decimal`</span><span class="sxs-lookup"><span data-stu-id="330c5-184">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="330c5-185">布尔值：`bool`，表示布尔值（`true` 或 `false`）</span><span class="sxs-lookup"><span data-stu-id="330c5-185">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="330c5-186">枚举类型</span><span class="sxs-lookup"><span data-stu-id="330c5-186">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="330c5-187">`enum E {...}` 格式的用户定义类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-187">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="330c5-188">`enum` 类型是一种包含已命名常量的独特类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-188">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="330c5-189">每个 `enum` 类型都有一个基础类型（必须是八种整型类型之一）。</span><span class="sxs-lookup"><span data-stu-id="330c5-189">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="330c5-190">`enum` 类型的值集与基础类型的值集相同。</span><span class="sxs-lookup"><span data-stu-id="330c5-190">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="330c5-191">结构类型</span><span class="sxs-lookup"><span data-stu-id="330c5-191">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="330c5-192">格式为 `struct S {...}` 的用户定义类型</span><span class="sxs-lookup"><span data-stu-id="330c5-192">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="330c5-193">可以为 null 的值类型</span><span class="sxs-lookup"><span data-stu-id="330c5-193">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="330c5-194">值为 `null` 的其他所有值类型的扩展</span><span class="sxs-lookup"><span data-stu-id="330c5-194">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="330c5-195">元组值类型</span><span class="sxs-lookup"><span data-stu-id="330c5-195">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="330c5-196">格式为 `(T1, T2, ...)` 的用户定义类型</span><span class="sxs-lookup"><span data-stu-id="330c5-196">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="330c5-197">引用类型</span><span class="sxs-lookup"><span data-stu-id="330c5-197">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="330c5-198">类类型</span><span class="sxs-lookup"><span data-stu-id="330c5-198">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="330c5-199">其他所有类型的最终基类：`object`</span><span class="sxs-lookup"><span data-stu-id="330c5-199">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="330c5-200">[Unicode 字符串](../../standard/base-types/character-encoding-introduction.md)：`string`，表示 UTF-16 代码单元序列</span><span class="sxs-lookup"><span data-stu-id="330c5-200">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="330c5-201">格式为 `class C {...}` 的用户定义类型</span><span class="sxs-lookup"><span data-stu-id="330c5-201">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="330c5-202">接口类型</span><span class="sxs-lookup"><span data-stu-id="330c5-202">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="330c5-203">格式为 `interface I {...}` 的用户定义类型</span><span class="sxs-lookup"><span data-stu-id="330c5-203">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="330c5-204">数组类型</span><span class="sxs-lookup"><span data-stu-id="330c5-204">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="330c5-205">一维、多维和交错。</span><span class="sxs-lookup"><span data-stu-id="330c5-205">Single-dimensional, multi-dimensional, and jagged.</span></span> <span data-ttu-id="330c5-206">例如：`int[]`、`int[,]` 和 `int[][]`</span><span class="sxs-lookup"><span data-stu-id="330c5-206">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="330c5-207">委托类型</span><span class="sxs-lookup"><span data-stu-id="330c5-207">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="330c5-208">格式为 `delegate int D(...)` 的用户定义类型</span><span class="sxs-lookup"><span data-stu-id="330c5-208">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="330c5-209">C# 程序使用 *类型声明* 创建新类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-209">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="330c5-210">类型声明指定新类型的名称和成员。</span><span class="sxs-lookup"><span data-stu-id="330c5-210">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="330c5-211">用户可定义以下六种 C# 类型：类类型、结构类型、接口类型、枚举类型、委托类型和元组值类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-211">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types, and tuple value types.</span></span>

- <span data-ttu-id="330c5-212">`class` 类型定义包含数据成员（字段）和函数成员（方法、属性及其他）的数据结构。</span><span class="sxs-lookup"><span data-stu-id="330c5-212">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="330c5-213">类类型支持单一继承和多形性，即派生类可以扩展和专门针对基类的机制。</span><span class="sxs-lookup"><span data-stu-id="330c5-213">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="330c5-214">`struct` 类型定义包含数据成员和函数成员的结构，这一点与类类型相似。</span><span class="sxs-lookup"><span data-stu-id="330c5-214">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="330c5-215">不过，与类不同的是，结构是值类型，通常不需要进行堆分配。</span><span class="sxs-lookup"><span data-stu-id="330c5-215">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="330c5-216">结构类型不支持用户指定的继承，并且所有结构类型均隐式继承自类型 `object`。</span><span class="sxs-lookup"><span data-stu-id="330c5-216">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="330c5-217">`interface` 类型将协定定义为一组已命名的公共成员。</span><span class="sxs-lookup"><span data-stu-id="330c5-217">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="330c5-218">实现 `interface` 的 `class` 或 `struct` 必须提供接口成员的实现代码。</span><span class="sxs-lookup"><span data-stu-id="330c5-218">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="330c5-219">`interface` 可以继承自多个基接口，`class` 和 `struct` 可以实现多个接口。</span><span class="sxs-lookup"><span data-stu-id="330c5-219">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="330c5-220">`delegate` 类型表示引用包含特定参数列表和返回类型的方法。</span><span class="sxs-lookup"><span data-stu-id="330c5-220">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="330c5-221">通过委托，可以将方法视为可分配给变量并可作为参数传递的实体。</span><span class="sxs-lookup"><span data-stu-id="330c5-221">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="330c5-222">委托类同于函数式语言提供的函数类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-222">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="330c5-223">它们还类似于其他一些语言中存在的“函数指针”概念。</span><span class="sxs-lookup"><span data-stu-id="330c5-223">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="330c5-224">与函数指针不同，委托是面向对象且类型安全的。</span><span class="sxs-lookup"><span data-stu-id="330c5-224">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="330c5-225">`class`、`struct`、`interface` 和 `delegate` 类型全部都支持泛型，因此可以使用其他类型对它们进行参数化。</span><span class="sxs-lookup"><span data-stu-id="330c5-225">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="330c5-226">C# 支持任意类型的一维和多维数组。</span><span class="sxs-lookup"><span data-stu-id="330c5-226">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="330c5-227">与上述类型不同，数组类型无需先声明即可使用。</span><span class="sxs-lookup"><span data-stu-id="330c5-227">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="330c5-228">相反，数组类型是通过在类型名称后面添加方括号构造而成。</span><span class="sxs-lookup"><span data-stu-id="330c5-228">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="330c5-229">例如，`int[]` 是 `int` 类型的一维数组，`int[,]` 是 `int` 类型的二维数组，`int[][]` 是由 `int` 类型的一维数组或“交错”数组构成的一维数组。</span><span class="sxs-lookup"><span data-stu-id="330c5-229">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="330c5-230">可以为 null 的类型不需要单独定义。</span><span class="sxs-lookup"><span data-stu-id="330c5-230">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="330c5-231">对于所有不可以为 null 的类型 `T`，都有对应的可以为 null 的类型 `T?`，后者可以包含附加值 `null`。</span><span class="sxs-lookup"><span data-stu-id="330c5-231">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="330c5-232">例如，`int?` 是可保存任何 32 位整数或 `null` 值的类型，`string?` 是可以保存任何 `string` 或 `null` 值的类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-232">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="330c5-233">C# 采用统一的类型系统，因此任意类型的值都可视为 `object`。</span><span class="sxs-lookup"><span data-stu-id="330c5-233">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="330c5-234">每种 C# 类型都直接或间接地派生自 `object` 类类型，而 `object` 是所有类型的最终基类。</span><span class="sxs-lookup"><span data-stu-id="330c5-234">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="330c5-235">只需将值视为类型 `object`，即可将引用类型的值视为对象。</span><span class="sxs-lookup"><span data-stu-id="330c5-235">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="330c5-236">通过执行 *装箱* 和 *取消装箱操作*，可以将值类型的值视为对象。</span><span class="sxs-lookup"><span data-stu-id="330c5-236">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="330c5-237">在以下示例中，`int` 值被转换成 `object`，然后又恢复成 `int`。</span><span class="sxs-lookup"><span data-stu-id="330c5-237">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="330c5-238">将值类型的值分配给 `object` 对象引用时，会分配一个“箱”来保存此值。</span><span class="sxs-lookup"><span data-stu-id="330c5-238">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="330c5-239">该箱是引用类型的实例，此值会被复制到该箱。</span><span class="sxs-lookup"><span data-stu-id="330c5-239">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="330c5-240">相反，当 `object` 引用被显式转换成值类型时，将检查引用的 `object` 是否是具有正确值类型的箱。</span><span class="sxs-lookup"><span data-stu-id="330c5-240">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="330c5-241">如果检查成功，则会将箱中的值复制到值类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-241">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="330c5-242">C# 的统一类型系统实际上意味着“按需”将值类型视为 `object` 引用。</span><span class="sxs-lookup"><span data-stu-id="330c5-242">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="330c5-243">鉴于这种统一性，使用类型 `object` 的常规用途库可以与派生自 `object` 的所有类型结合使用，包括引用类型和值类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-243">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="330c5-244">C# 有多种 *变量*，其中包括字段、数组元素、局部变量和参数。</span><span class="sxs-lookup"><span data-stu-id="330c5-244">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="330c5-245">变量表示存储位置。</span><span class="sxs-lookup"><span data-stu-id="330c5-245">Variables represent storage locations.</span></span> <span data-ttu-id="330c5-246">每个变量都具有一种类型，用于确定可以在变量中存储哪些值，如下文所述。</span><span class="sxs-lookup"><span data-stu-id="330c5-246">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="330c5-247">不可以为 null 的值类型</span><span class="sxs-lookup"><span data-stu-id="330c5-247">Non-nullable value type</span></span>
  - <span data-ttu-id="330c5-248">具有精确类型的值</span><span class="sxs-lookup"><span data-stu-id="330c5-248">A value of that exact type</span></span>
- <span data-ttu-id="330c5-249">可以为 null 的值类型</span><span class="sxs-lookup"><span data-stu-id="330c5-249">Nullable value type</span></span>
  - <span data-ttu-id="330c5-250">`null` 值或具有精确类型的值</span><span class="sxs-lookup"><span data-stu-id="330c5-250">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="330c5-251">object</span><span class="sxs-lookup"><span data-stu-id="330c5-251">object</span></span>
  - <span data-ttu-id="330c5-252">`null` 引用、对任意引用类型的对象的引用，或对任意值类型的装箱值的引用</span><span class="sxs-lookup"><span data-stu-id="330c5-252">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="330c5-253">类类型</span><span class="sxs-lookup"><span data-stu-id="330c5-253">Class type</span></span>
  - <span data-ttu-id="330c5-254">`null` 引用、对类类型实例的引用，或对派生自类类型的类实例的引用</span><span class="sxs-lookup"><span data-stu-id="330c5-254">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="330c5-255">接口类型</span><span class="sxs-lookup"><span data-stu-id="330c5-255">Interface type</span></span>
  - <span data-ttu-id="330c5-256">`null` 引用、对实现接口类型的类类型实例的引用，或对实现接口类型的值类型的装箱值的引用</span><span class="sxs-lookup"><span data-stu-id="330c5-256">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="330c5-257">数组类型</span><span class="sxs-lookup"><span data-stu-id="330c5-257">Array type</span></span>
  - <span data-ttu-id="330c5-258">`null` 引用、对数组类型实例的引用，或对兼容的数组类型实例的引用</span><span class="sxs-lookup"><span data-stu-id="330c5-258">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="330c5-259">委托类型</span><span class="sxs-lookup"><span data-stu-id="330c5-259">Delegate type</span></span>
  - <span data-ttu-id="330c5-260">`null` 引用或对兼容的委托类型实例的引用</span><span class="sxs-lookup"><span data-stu-id="330c5-260">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="330c5-261">程序结构</span><span class="sxs-lookup"><span data-stu-id="330c5-261">Program structure</span></span>

<span data-ttu-id="330c5-262">C# 中的关键组织结构概念包括[程序](../programming-guide/inside-a-program/index.md)、[命名空间](../programming-guide/namespaces/index.md)、[类型](../programming-guide/types/index.md)、[成员](../programming-guide/classes-and-structs/members.md)和[程序集](../../standard/assembly/index.md)\*    。</span><span class="sxs-lookup"><span data-stu-id="330c5-262">The key organizational concepts in C# are [\***programs** _](../programming-guide/inside-a-program/index.md), [_*_namespaces_*_](../programming-guide/namespaces/index.md), [_*_types_*_](../programming-guide/types/index.md), [_*_members_*_](../programming-guide/classes-and-structs/members.md), and [_*_assemblies_*_](../../standard/assembly/index.md).</span></span> <span data-ttu-id="330c5-263">程序声明类型，而类型则包含成员，并被整理到命名空间中。</span><span class="sxs-lookup"><span data-stu-id="330c5-263">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="330c5-264">类型示例包括类、结构和接口。</span><span class="sxs-lookup"><span data-stu-id="330c5-264">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="330c5-265">成员示例包括字段、方法、属性和事件。</span><span class="sxs-lookup"><span data-stu-id="330c5-265">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="330c5-266">编译完的 C# 程序实际上会打包到程序集中。</span><span class="sxs-lookup"><span data-stu-id="330c5-266">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="330c5-267">程序集的文件扩展名通常为 `.exe` 或 `.dll`，具体视其分别实现的是应用程序还是库_\*\*\*而定。</span><span class="sxs-lookup"><span data-stu-id="330c5-267">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement _*_applications_*_ or _\*_libraries_\*\*, respectively.</span></span>

<span data-ttu-id="330c5-268">作为一个小示例，请考虑包含以下代码的程序集：</span><span class="sxs-lookup"><span data-stu-id="330c5-268">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="330c5-269">此类的完全限定的名称为 `Acme.Collections.Stack`。</span><span class="sxs-lookup"><span data-stu-id="330c5-269">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="330c5-270">此类包含多个成员：一个 `top` 字段、两个方法（`Push` 和 `Pop`）和一个 `Entry` 嵌套类。</span><span class="sxs-lookup"><span data-stu-id="330c5-270">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="330c5-271">`Entry` 类还包含三个成员：一个 `next` 字段、一个 `data` 字段和一个构造函数。</span><span class="sxs-lookup"><span data-stu-id="330c5-271">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="330c5-272">`Stack` 是泛型类。</span><span class="sxs-lookup"><span data-stu-id="330c5-272">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="330c5-273">它具有一个类型参数 `T`，在使用时替换为具体类型。</span><span class="sxs-lookup"><span data-stu-id="330c5-273">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="330c5-274">堆栈是一个“先进后出”(FILO) 集合。</span><span class="sxs-lookup"><span data-stu-id="330c5-274">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="330c5-275">添加到堆栈顶部的新元素。</span><span class="sxs-lookup"><span data-stu-id="330c5-275">New elements are added to the top of the stack.</span></span> <span data-ttu-id="330c5-276">删除元素时，将从堆栈顶部删除该元素。</span><span class="sxs-lookup"><span data-stu-id="330c5-276">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="330c5-277">程序集包含中间语言 (IL) 指令形式的可执行代码和元数据形式的符号信息。</span><span class="sxs-lookup"><span data-stu-id="330c5-277">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="330c5-278">执行前，.NET 公共语言运行时的实时 (JIT) 编译器会将程序集中的 IL 代码转换为特定于处理器的代码。</span><span class="sxs-lookup"><span data-stu-id="330c5-278">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="330c5-279">由于程序集是包含代码和元数据的自描述功能单元，因此无需在 C# 中使用 `#include` 指令和头文件。</span><span class="sxs-lookup"><span data-stu-id="330c5-279">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="330c5-280">只需在编译程序时引用特定的程序集，即可在 C# 程序中使用此程序集中包含的公共类型和成员。</span><span class="sxs-lookup"><span data-stu-id="330c5-280">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="330c5-281">例如，此程序使用 `acme.dll` 程序集中的 `Acme.Collections.Stack` 类：</span><span class="sxs-lookup"><span data-stu-id="330c5-281">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="330c5-282">若要编译此程序，需要引用包含前面示例中定义的堆栈类的程序集。</span><span class="sxs-lookup"><span data-stu-id="330c5-282">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="330c5-283">C# 程序可以存储在多个源文件中。</span><span class="sxs-lookup"><span data-stu-id="330c5-283">C# programs can be stored in several source files.</span></span> <span data-ttu-id="330c5-284">在编译 C# 程序时，将同时处理所有源文件，并且源文件可以自由地相互引用。</span><span class="sxs-lookup"><span data-stu-id="330c5-284">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="330c5-285">从概念上讲，就好像所有源文件在被处理之前都连接到一个大文件。</span><span class="sxs-lookup"><span data-stu-id="330c5-285">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="330c5-286">在 C# 中永远都不需要使用前向声明，因为声明顺序无关紧要（极少数例外情况除外）。</span><span class="sxs-lookup"><span data-stu-id="330c5-286">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="330c5-287">C# 并不限制源文件只能声明一种公共类型，也不要求源文件的文件名必须与其中声明的类型相匹配。</span><span class="sxs-lookup"><span data-stu-id="330c5-287">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="330c5-288">本教程中的后续文章介绍了这些组织块。</span><span class="sxs-lookup"><span data-stu-id="330c5-288">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="330c5-289">下一页</span><span class="sxs-lookup"><span data-stu-id="330c5-289">Next</span></span>](types.md)
