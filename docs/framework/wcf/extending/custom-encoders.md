---
description: 了解详细信息：自定义编码器
title: 自定义编码器
ms.date: 03/30/2017
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
ms.openlocfilehash: 12c706daf025b6ab63bd5c4e2cbb426a2ea83af1
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99735291"
---
# <a name="custom-encoders"></a><span data-ttu-id="54d57-103">自定义编码器</span><span class="sxs-lookup"><span data-stu-id="54d57-103">Custom Encoders</span></span>

<span data-ttu-id="54d57-104">本主题讨论如何创建自定义编码器。</span><span class="sxs-lookup"><span data-stu-id="54d57-104">This topic discusses how to create custom encoders.</span></span>  
  
 <span data-ttu-id="54d57-105">在 Windows Communication Foundation (WCF) ，使用 *绑定* 指定如何在终结点之间跨网络传输数据。</span><span class="sxs-lookup"><span data-stu-id="54d57-105">In Windows Communication Foundation (WCF), you use a *binding* to specify how to transfer data across a network between endpoints.</span></span> <span data-ttu-id="54d57-106">绑定由一系列 *绑定元素* 组成。</span><span class="sxs-lookup"><span data-stu-id="54d57-106">A binding is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="54d57-107">绑定包括可选的协议绑定元素，如安全性、必需的 *消息编码器* 绑定元素以及必需的传输绑定元素。</span><span class="sxs-lookup"><span data-stu-id="54d57-107">A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element.</span></span> <span data-ttu-id="54d57-108">消息编码器由消息编码绑定元素表示。</span><span class="sxs-lookup"><span data-stu-id="54d57-108">A message encoder is represented by a message encoding binding element.</span></span> <span data-ttu-id="54d57-109">WCF 中包括三个消息编码器：二进制、消息传输优化机制 (MTOM) 和文本。</span><span class="sxs-lookup"><span data-stu-id="54d57-109">Three message encoders are included in WCF: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.</span></span>  
  
 <span data-ttu-id="54d57-110">消息编码绑定元素将序列化传出 <xref:System.ServiceModel.Channels.Message> 并将其传递到传输层，或从传输层接收已序列化的消息并将其传递到协议层（如果存在），如果不存在协议层，则传递到应用程序。</span><span class="sxs-lookup"><span data-stu-id="54d57-110">A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.</span></span>  
  
 <span data-ttu-id="54d57-111">消息编码器可将 <xref:System.ServiceModel.Channels.Message> 实例与网络表示形式互相转换。</span><span class="sxs-lookup"><span data-stu-id="54d57-111">Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation.</span></span> <span data-ttu-id="54d57-112">尽管编码器被描述为位于通道堆栈的传输层之上，但它们实际上驻留在传输层中。</span><span class="sxs-lookup"><span data-stu-id="54d57-112">Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer.</span></span> <span data-ttu-id="54d57-113">传输（如 HTTP）根据传输标准的需求格式化消息。</span><span class="sxs-lookup"><span data-stu-id="54d57-113">Transports (for example HTTP) format the message according to the requirements of the transport standard.</span></span> <span data-ttu-id="54d57-114">编码器（如文本 Xml）仅对消息进行编码。</span><span class="sxs-lookup"><span data-stu-id="54d57-114">Encoders (for example Text Xml) just encode the message.</span></span>  
  
 <span data-ttu-id="54d57-115">当连接至预先存在的客户端或服务器时，您不能选择使用特定消息编码。</span><span class="sxs-lookup"><span data-stu-id="54d57-115">When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding.</span></span> <span data-ttu-id="54d57-116">但是，可以通过多个终结点访问 WCF 服务，每个终结点具有不同的消息编码器。</span><span class="sxs-lookup"><span data-stu-id="54d57-116">However, WCF services can be made accessible through multiple endpoints, each with a different message encoder.</span></span> <span data-ttu-id="54d57-117">当一个编码器不涵盖服务的全部用户时，请考虑在多个终结点上公开您的服务。</span><span class="sxs-lookup"><span data-stu-id="54d57-117">When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints.</span></span> <span data-ttu-id="54d57-118">然后，客户端应用程序即可选择最适用的终结点。</span><span class="sxs-lookup"><span data-stu-id="54d57-118">Client applications can then choose the endpoint that is best for them.</span></span> <span data-ttu-id="54d57-119">使用多个终结点使你可以将不同消息编码器的优点与其他绑定元素结合起来。</span><span class="sxs-lookup"><span data-stu-id="54d57-119">Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.</span></span>  
  
## <a name="system-provided-encoders"></a><span data-ttu-id="54d57-120">系统提供的编码器</span><span class="sxs-lookup"><span data-stu-id="54d57-120">System-Provided Encoders</span></span>  

 <span data-ttu-id="54d57-121">WCF 提供了多个系统提供的绑定，这些绑定旨在涵盖最常见的应用程序方案。</span><span class="sxs-lookup"><span data-stu-id="54d57-121">WCF provides several system-provided bindings that are designed to cover the most common application scenarios.</span></span> <span data-ttu-id="54d57-122">这些绑定中的每个绑定均由传输选项、消息编码器选项和其他选项（如安全性）组成。</span><span class="sxs-lookup"><span data-stu-id="54d57-122">Each of these bindings combine a transport, message encoder, and other options (security, for example).</span></span> <span data-ttu-id="54d57-123">本主题介绍如何扩展 WCF 中 `Text` 包含的、 `Binary` 和 `MTOM` 消息编码器，或创建你自己的自定义编码器。</span><span class="sxs-lookup"><span data-stu-id="54d57-123">This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in WCF, or create your own custom encoder.</span></span> <span data-ttu-id="54d57-124">文本消息编码器同时支持纯 XML 编码和 SOAP 编码。</span><span class="sxs-lookup"><span data-stu-id="54d57-124">The text message encoder supports both a plain XML encoding as well as SOAP encodings.</span></span> <span data-ttu-id="54d57-125">文本消息编码器的纯 XML 编码模式称为 POX（“Plain Old XML”）编码器，以便与基于文本的 SOAP 编码进行区分。</span><span class="sxs-lookup"><span data-stu-id="54d57-125">The plain XML encoding mode of the text message encoder is called the POX ("Plain Old XML") encoder to distinguish it from the text-based SOAP encoding.</span></span>  
  
 <span data-ttu-id="54d57-126">有关由系统提供的绑定提供的绑定元素组合的详细信息，请参阅 [选择传输](../feature-details/choosing-a-transport.md)中的相应部分。</span><span class="sxs-lookup"><span data-stu-id="54d57-126">For more information about the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../feature-details/choosing-a-transport.md).</span></span>  
  
## <a name="how-to-work-with-system-provided-encoders"></a><span data-ttu-id="54d57-127">如何使用系统提供的编码器</span><span class="sxs-lookup"><span data-stu-id="54d57-127">How to Work with System-Provided Encoders</span></span>  

 <span data-ttu-id="54d57-128">使用派生自 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 的类将编码添加到绑定中。</span><span class="sxs-lookup"><span data-stu-id="54d57-128">An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
 <span data-ttu-id="54d57-129">WCF 提供了以下类型的绑定元素，这些元素派生自 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 可提供给文本、二进制和消息传输优化机制 (MTOM) 编码的类：</span><span class="sxs-lookup"><span data-stu-id="54d57-129">WCF provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:</span></span>  
  
- <span data-ttu-id="54d57-130"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>：互操作性最强，但效率最低的 XML 消息编码器。</span><span class="sxs-lookup"><span data-stu-id="54d57-130"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages.</span></span> <span data-ttu-id="54d57-131">Web 服务或 Web 服务客户端通常都能理解文本 XML。</span><span class="sxs-lookup"><span data-stu-id="54d57-131">A Web service or Web service client can generally understand textual XML.</span></span> <span data-ttu-id="54d57-132">但是，将大型二进制数据块作为文本传输不是有效的传输方式。</span><span class="sxs-lookup"><span data-stu-id="54d57-132">However, transmitting large blocks of binary data as text is not efficient.</span></span>  
  
- <span data-ttu-id="54d57-133"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>：表示指定基于二进制的 XML 消息所使用的字符编码和消息版本管理的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="54d57-133"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages.</span></span> <span data-ttu-id="54d57-134">这是对编码选项最有效的，但最不具互操作性，因为它仅由 WCF 终结点支持。</span><span class="sxs-lookup"><span data-stu-id="54d57-134">This is most efficient of the encoding options, but the least interoperable, because it is only supported by WCF endpoints.</span></span>  
  
- <span data-ttu-id="54d57-135"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>：表示指定使用消息传输优化机制 (MTOM) 编码的消息所使用的字符编码和消息版本管理的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="54d57-135"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding.</span></span> <span data-ttu-id="54d57-136">MTOM 是一种用于在 WCF 消息中传输二进制数据的有效技术。</span><span class="sxs-lookup"><span data-stu-id="54d57-136">MTOM is an efficient technology for transmitting binary data in WCF messages.</span></span> <span data-ttu-id="54d57-137">MTOM 编码器力图在效率和互操作性之间取得平衡。</span><span class="sxs-lookup"><span data-stu-id="54d57-137">The MTOM encoder attempts to balance between efficiency and interoperability.</span></span> <span data-ttu-id="54d57-138">MTOM 编码以文本形式传输大多数 XML，但是会通过按原样（即不转换为文本）的方式传输来优化大型二进制数据块。</span><span class="sxs-lookup"><span data-stu-id="54d57-138">The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.</span></span>  
  
 <span data-ttu-id="54d57-139">绑定元素创建二进制、MTOM 或文本 <xref:System.ServiceModel.Channels.MessageEncoderFactory>。</span><span class="sxs-lookup"><span data-stu-id="54d57-139">The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span></span> <span data-ttu-id="54d57-140">工厂创建二进制、MTOM 或文本 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 实例。</span><span class="sxs-lookup"><span data-stu-id="54d57-140">The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory> instance.</span></span> <span data-ttu-id="54d57-141">通常，只有一个实例。</span><span class="sxs-lookup"><span data-stu-id="54d57-141">Typically, there is only a single instance.</span></span> <span data-ttu-id="54d57-142">但是如果使用会话，将为每个会话提供一个不同的编码器。</span><span class="sxs-lookup"><span data-stu-id="54d57-142">However if sessions are used, a different encoder may be provided to each session.</span></span> <span data-ttu-id="54d57-143">二进制编码器用此来调整动态字典（请参见“XML 基础结构”）。</span><span class="sxs-lookup"><span data-stu-id="54d57-143">The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).</span></span>  
  
 <span data-ttu-id="54d57-144"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> 和 <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> 方法是编码器的核心。</span><span class="sxs-lookup"><span data-stu-id="54d57-144">The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders.</span></span> <span data-ttu-id="54d57-145">这些方法的作用是从流或 <xref:System.Byte> 数组中读取消息。</span><span class="sxs-lookup"><span data-stu-id="54d57-145">The methods provide for reading a message from a stream or from a <xref:System.Byte> array.</span></span> <span data-ttu-id="54d57-146">当在缓冲模式下进行传输时，将使用字节数组。</span><span class="sxs-lookup"><span data-stu-id="54d57-146">Byte arrays are used when the transport is operating in buffered mode.</span></span> <span data-ttu-id="54d57-147">消息总是写入流中。</span><span class="sxs-lookup"><span data-stu-id="54d57-147">Messages are always written to streams.</span></span> <span data-ttu-id="54d57-148">如果传输必须缓冲消息，它将提供一个执行缓冲的流。</span><span class="sxs-lookup"><span data-stu-id="54d57-148">If the transport must buffer the message, it provides a stream that does the buffering.</span></span>  
  
 <span data-ttu-id="54d57-149">其他成员则使用支持内容、媒体类型和 <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>。</span><span class="sxs-lookup"><span data-stu-id="54d57-149">The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.</span></span> <span data-ttu-id="54d57-150">传输调用这些编码器方法来测试传入的消息是否可以使用此方法解码，或者确定传出消息是否对此编码器有效。</span><span class="sxs-lookup"><span data-stu-id="54d57-150">The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.</span></span>  
  
 <span data-ttu-id="54d57-151">这第三个编码器实现时每个都会添加与特定编码相关的属性，而且这些属性全都可以进行配置。</span><span class="sxs-lookup"><span data-stu-id="54d57-151">Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable.</span></span> <span data-ttu-id="54d57-152">这些编码器还会公开具有安全默认值的读取器配额。</span><span class="sxs-lookup"><span data-stu-id="54d57-152">The encoders also expose reader quotas that have secure defaults.</span></span> <span data-ttu-id="54d57-153">有关配额的讨论，请参见“XML 基础结构”。</span><span class="sxs-lookup"><span data-stu-id="54d57-153">See XML Infrastructure for a discussion of the quotas.</span></span>  
  
## <a name="features-of-system-provided-encoders"></a><span data-ttu-id="54d57-154">系统提供的编码器的功能</span><span class="sxs-lookup"><span data-stu-id="54d57-154">Features of System-Provided Encoders</span></span>  

 <span data-ttu-id="54d57-155">系统提供的编码器具有多种功能。</span><span class="sxs-lookup"><span data-stu-id="54d57-155">There are a number of features provided by the system-provided encoders.</span></span>  
  
### <a name="pooling"></a><span data-ttu-id="54d57-156">Pooling</span><span class="sxs-lookup"><span data-stu-id="54d57-156">Pooling</span></span>  

 <span data-ttu-id="54d57-157">每个编码器实现都会尝试生成尽可能多的池。</span><span class="sxs-lookup"><span data-stu-id="54d57-157">Each of the encoder implementations tries to pool as much as possible.</span></span> <span data-ttu-id="54d57-158">减少分配是提高托管代码性能的主要方式。</span><span class="sxs-lookup"><span data-stu-id="54d57-158">Reducing allocations is a key way to improve the performance of managed code.</span></span> <span data-ttu-id="54d57-159">为了完成此生成池操作，实现将使用 `SynchronizedPool` 类。</span><span class="sxs-lookup"><span data-stu-id="54d57-159">To accomplish this pooling, the implementations use the `SynchronizedPool` class.</span></span> <span data-ttu-id="54d57-160">C# 文件包含此类使用的其他优化的说明。</span><span class="sxs-lookup"><span data-stu-id="54d57-160">The C# file contains a description of the additional optimizations used by this class.</span></span>  
  
 <span data-ttu-id="54d57-161"><xref:System.Xml.XmlDictionaryReader> 和 <xref:System.Xml.XmlDictionaryWriter> 实例均存入池中，并重新初始化以防止对每条消息添加新的分配。</span><span class="sxs-lookup"><span data-stu-id="54d57-161"><xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> instances are pooled and reinitialized to prevent allocating new ones for each message.</span></span> <span data-ttu-id="54d57-162">对于读取器，`OnClose` 回调将在调用 `Close()` 时回收读取器。</span><span class="sxs-lookup"><span data-stu-id="54d57-162">For the readers, an `OnClose` callback reclaims the reader when `Close()` is called.</span></span> <span data-ttu-id="54d57-163">编码器也会在构造消息时回收某些已使用的消息状态对象。</span><span class="sxs-lookup"><span data-stu-id="54d57-163">The encoder also recycles some message state objects used when constructing messages.</span></span> <span data-ttu-id="54d57-164">这些池的大小可以通过派生自 `MaxReadPoolSize` 的这三个类之一的 `MaxWritePoolSize` 和 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 属性配置。</span><span class="sxs-lookup"><span data-stu-id="54d57-164">The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
### <a name="binary-encoding"></a><span data-ttu-id="54d57-165">二进制编码</span><span class="sxs-lookup"><span data-stu-id="54d57-165">Binary Encoding</span></span>  

 <span data-ttu-id="54d57-166">当二进制编码使用会话时，动态字典字符串必须与消息的接收方通信。</span><span class="sxs-lookup"><span data-stu-id="54d57-166">When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message.</span></span> <span data-ttu-id="54d57-167">这可以通过在消息之前添加动态字典字符串实现。</span><span class="sxs-lookup"><span data-stu-id="54d57-167">This is done by prefixing the message with the dynamic dictionary strings.</span></span> <span data-ttu-id="54d57-168">接收方将剥离这些字符串，然后将它们添加到会话中，再处理消息。</span><span class="sxs-lookup"><span data-stu-id="54d57-168">The receiver strips off the strings, adds them to the session, and processes the message.</span></span> <span data-ttu-id="54d57-169">要正确传递字典字符串就需要对传输进行缓冲。</span><span class="sxs-lookup"><span data-stu-id="54d57-169">Correctly passing dictionary strings requires that the transport be buffered.</span></span>  
  
 <span data-ttu-id="54d57-170">这些字符串通过内部 `AddSessionInformationToMessage` 方法附加到消息中。</span><span class="sxs-lookup"><span data-stu-id="54d57-170">The strings are appended to the message by an internal `AddSessionInformationToMessage` method.</span></span> <span data-ttu-id="54d57-171">此方法将字符串作为 UTF-8 添加到以它们的长度为前缀的消息前面。</span><span class="sxs-lookup"><span data-stu-id="54d57-171">It adds the strings as UTF-8 to the front of the message prefixed with their length.</span></span> <span data-ttu-id="54d57-172">随后，整个字典标头都将以数据长度作为前缀。</span><span class="sxs-lookup"><span data-stu-id="54d57-172">The entire dictionary header is then prefixed with the length of its data.</span></span> <span data-ttu-id="54d57-173">反向操作可通过内部 `ExtractSessionInformationFromMessage` 方法执行。</span><span class="sxs-lookup"><span data-stu-id="54d57-173">The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method.</span></span>  
  
 <span data-ttu-id="54d57-174">除了处理动态字典关键字之外，缓冲的会话消息将采用独有的方式接收。</span><span class="sxs-lookup"><span data-stu-id="54d57-174">In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way.</span></span> <span data-ttu-id="54d57-175">二进制编码器不是对文档创建一个编码器并处理该文档，而是使用内部 `MessagePatterns` 类解构二进制流。</span><span class="sxs-lookup"><span data-stu-id="54d57-175">Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream.</span></span> <span data-ttu-id="54d57-176">其思路是，大多数消息都具有一组特定的标头，这些标头在由 WCF 生成时按特定顺序显示。</span><span class="sxs-lookup"><span data-stu-id="54d57-176">The idea is that most messages have a certain set of headers that show up in a certain order when generated by WCF.</span></span> <span data-ttu-id="54d57-177">模式系统将基于它所期待的方式拆分消息。</span><span class="sxs-lookup"><span data-stu-id="54d57-177">The pattern system breaks the message apart based on what it expects.</span></span> <span data-ttu-id="54d57-178">如果成功了，它将初始化 <xref:System.ServiceModel.Channels.MessageHeaders> 对象而无需分析 XML。</span><span class="sxs-lookup"><span data-stu-id="54d57-178">If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML.</span></span> <span data-ttu-id="54d57-179">如果不成功，将转而使用标准方法。</span><span class="sxs-lookup"><span data-stu-id="54d57-179">If not, it falls back to the standard method.</span></span>  
  
### <a name="mtom-encoding"></a><span data-ttu-id="54d57-180">MTOM 编码</span><span class="sxs-lookup"><span data-stu-id="54d57-180">MTOM Encoding</span></span>  

 <span data-ttu-id="54d57-181"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> 类具有一个称为 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A> 的附加配置属性。</span><span class="sxs-lookup"><span data-stu-id="54d57-181">The <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> class has an additional configuration property called <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A>.</span></span> <span data-ttu-id="54d57-182">此属性用于设置在读取消息的过程中允许缓冲的数据量上限。</span><span class="sxs-lookup"><span data-stu-id="54d57-182">This places an upper bound on how much data it is allowed to buffer during the process of reading a message.</span></span> <span data-ttu-id="54d57-183">XML 信息集 (Infoset)，或其他 MIME 部分，可能需要进行缓冲以便将所有 MIME 部分集合到一条消息中。</span><span class="sxs-lookup"><span data-stu-id="54d57-183">The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.</span></span>  
  
 <span data-ttu-id="54d57-184">为了可以正确使用 HTTP，内部 MTOM 消息编码器类为 `GetContentType`（内部）和 `WriteMessage` 提供了一些内部 API，这些 API 是公用的，可以重写。</span><span class="sxs-lookup"><span data-stu-id="54d57-184">To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden.</span></span> <span data-ttu-id="54d57-185">必须进行更多的通信以确保 HTTP 标头中的值与 MIME 标头中的值一致。</span><span class="sxs-lookup"><span data-stu-id="54d57-185">More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.</span></span>  
  
 <span data-ttu-id="54d57-186">在内部，MTOM 消息编码器使用 WCF 的文本读取器，类似于文本编码器。</span><span class="sxs-lookup"><span data-stu-id="54d57-186">Internally, the MTOM message encoder uses WCF's text readers, and is similar to the Text encoder.</span></span> <span data-ttu-id="54d57-187">主要区别在于它可优化大型二进制块，或“二进制大型对象”(BLOB)，方法是将它们嵌入消息字节中之前不将其转换为 Base-64 编码。</span><span class="sxs-lookup"><span data-stu-id="54d57-187">The main difference is that it optimizes large chunks of binary, or "Binary Large Objects" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes.</span></span> <span data-ttu-id="54d57-188">而是将这些 BLOB 保持提取状态，并以 MIME 附件的形式进行引用。</span><span class="sxs-lookup"><span data-stu-id="54d57-188">Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.</span></span>  
  
## <a name="writing-your-own-encoder"></a><span data-ttu-id="54d57-189">编写自己的编码器</span><span class="sxs-lookup"><span data-stu-id="54d57-189">Writing your own Encoder</span></span>  

 <span data-ttu-id="54d57-190">若要实现自己的自定义消息编码器，您必须提供下列抽象基类的自定义实现：</span><span class="sxs-lookup"><span data-stu-id="54d57-190">To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:</span></span>  
  
- <xref:System.ServiceModel.Channels.MessageEncoder>  
  
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 <span data-ttu-id="54d57-191">将消息从内存中的表示形式转换为可以写入流中的表示形式封装在 <xref:System.ServiceModel.Channels.MessageEncoder> 类中，它可作为支持特定类型的 XML 编码的 XML 读取器和 XML 编写器的工厂。</span><span class="sxs-lookup"><span data-stu-id="54d57-191">Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.</span></span>  
  
- <span data-ttu-id="54d57-192">您必须重写的此类的主要方法包括：</span><span class="sxs-lookup"><span data-stu-id="54d57-192">The key methods of this class that you must override are:</span></span>  
  
- <span data-ttu-id="54d57-193"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A>，此方法采用 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 对象并将其写入 <xref:System.IO.Stream> 对象。</span><span class="sxs-lookup"><span data-stu-id="54d57-193"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> object and writes it into a <xref:System.IO.Stream> object.</span></span>  
  
- <span data-ttu-id="54d57-194"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>，此方法采用 <xref:System.IO.Stream> 对象以及最大标头大小，并返回一个 <xref:System.ServiceModel.Channels.Message> 对象。</span><span class="sxs-lookup"><span data-stu-id="54d57-194"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object.</span></span>  
  
 <span data-ttu-id="54d57-195">你写入这些方法中的代码处理标准传输协议和你自定义的编码之间的转换。</span><span class="sxs-lookup"><span data-stu-id="54d57-195">It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.</span></span>  
  
 <span data-ttu-id="54d57-196">接下来，你需要编写一条创建自定义编码器的工厂类代码。</span><span class="sxs-lookup"><span data-stu-id="54d57-196">Next you need to code a factory class that creates your custom encoder.</span></span> <span data-ttu-id="54d57-197">重写 <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> 以返回自定义 <xref:System.ServiceModel.Channels.MessageEncoder> 的实例。</span><span class="sxs-lookup"><span data-stu-id="54d57-197">Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>.</span></span>  
  
 <span data-ttu-id="54d57-198">然后通过重写 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 方法将自定义的 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> 连接至用于配置服务或客户端的绑定元素堆栈，以便返回此工厂的实例。</span><span class="sxs-lookup"><span data-stu-id="54d57-198">Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory.</span></span>  
  
 <span data-ttu-id="54d57-199">WCF 提供了两个示例，其中的示例代码演示了此过程： [自定义消息编码器：自定义文本编码器](../samples/custom-message-encoder-custom-text-encoder.md) 和 [自定义消息编码器：压缩编码器](../samples/custom-message-encoder-compression-encoder.md)。</span><span class="sxs-lookup"><span data-stu-id="54d57-199">There are two samples provided with WCF that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../samples/custom-message-encoder-compression-encoder.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="54d57-200">请参阅</span><span class="sxs-lookup"><span data-stu-id="54d57-200">See also</span></span>

- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>
- <xref:System.ServiceModel.Channels.MessageEncoder>
- [<span data-ttu-id="54d57-201">数据传输体系结构概述</span><span class="sxs-lookup"><span data-stu-id="54d57-201">Data Transfer Architectural Overview</span></span>](../feature-details/data-transfer-architectural-overview.md)
- [<span data-ttu-id="54d57-202">选择消息编码器</span><span class="sxs-lookup"><span data-stu-id="54d57-202">Choosing a Message Encoder</span></span>](../feature-details/choosing-a-message-encoder.md)
- [<span data-ttu-id="54d57-203">选择传输方式</span><span class="sxs-lookup"><span data-stu-id="54d57-203">Choosing a Transport</span></span>](../feature-details/choosing-a-transport.md)
