---
description: 了解有关在数据协定中的 XML 和 ADO.NET 类型的详细信息
title: 数据协定中的 XML 和 ADO.NET 类型
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: c83520b1be1bdf0f7985982dc498f9c12cef5722
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793306"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="a6c06-103">数据协定中的 XML 和 ADO.NET 类型</span><span class="sxs-lookup"><span data-stu-id="a6c06-103">XML and ADO.NET Types in Data Contracts</span></span>

<span data-ttu-id="a6c06-104">Windows Communication Foundation (WCF) 数据协定模型支持直接表示 XML 的特定类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-104">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="a6c06-105">当这些类型序列化为 XML 时，序列化程序将写出这些类型的 XML 内容，而不再进一步进行任何处理。</span><span class="sxs-lookup"><span data-stu-id="a6c06-105">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="a6c06-106">支持的类型为 <xref:System.Xml.XmlElement>、<xref:System.Xml.XmlNode> 的数组（但不是 `XmlNode` 类型本身）以及实现 <xref:System.Xml.Serialization.IXmlSerializable> 的类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-106">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="a6c06-107"><xref:System.Data.DataSet> 和 <xref:System.Data.DataTable> 类型以及类型化数据集通常用于数据库编程。</span><span class="sxs-lookup"><span data-stu-id="a6c06-107">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="a6c06-108">这些类型可实现 `IXmlSerializable` 接口，因此它们在数据协定模型中可序列化。</span><span class="sxs-lookup"><span data-stu-id="a6c06-108">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="a6c06-109">本主题的结尾还列出了一些有关这些类型的特殊注意事项。</span><span class="sxs-lookup"><span data-stu-id="a6c06-109">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="a6c06-110">XML 类型</span><span class="sxs-lookup"><span data-stu-id="a6c06-110">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="a6c06-111">XmlElement</span><span class="sxs-lookup"><span data-stu-id="a6c06-111">Xml Element</span></span>  

 <span data-ttu-id="a6c06-112">`XmlElement` 类型使用其 XML 内容进行序列化。</span><span class="sxs-lookup"><span data-stu-id="a6c06-112">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="a6c06-113">例如，使用以下类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-113">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="a6c06-114">它将序列化为 XML，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a6c06-114">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="a6c06-115">请注意，包装数据成员元素 `<myDataMember>` 仍然存在。</span><span class="sxs-lookup"><span data-stu-id="a6c06-115">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="a6c06-116">无法在数据协定模型中移除此元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-116">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="a6c06-117">处理此模型的序列化程序（<xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer>）可以将特殊属性发出到此包装元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-117">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="a6c06-118">这些属性包括标准 XML 架构实例“nil”属性（允许 `XmlElement` 为 `null`）和“Type”属性（允许以多元方式使用 `XmlElement`）。</span><span class="sxs-lookup"><span data-stu-id="a6c06-118">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="a6c06-119">此外，以下 XML 特性特定于 WCF： "Id"、"Ref"、"Type" 和 "Assembly"。</span><span class="sxs-lookup"><span data-stu-id="a6c06-119">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="a6c06-120">可以发出这些属性以支持与已启用的对象图保留模式或 `XmlElement` 一起使用 <xref:System.Runtime.Serialization.NetDataContractSerializer>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-120">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="a6c06-121"> (有关对象关系图保留模式的详细信息，请参阅 [序列化和反序列化](serialization-and-deserialization.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="a6c06-121">(For more information about the object graph preservation mode, see [Serialization and Deserialization](serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="a6c06-122">允许使用 `XmlElement` 的数组或集合，并且可以将它们作为任何其他数组或集合进行处理。</span><span class="sxs-lookup"><span data-stu-id="a6c06-122">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="a6c06-123">也就是说，将有一个包装元素适用于整个集合，并且数组中的每一个 `<myDataMember>` 都对应一个单独的包装元素（类似于上面示例中的 `XmlElement`）。</span><span class="sxs-lookup"><span data-stu-id="a6c06-123">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="a6c06-124">在反序列化过程中，反序列化程序将从传入的 XML 创建一个 `XmlElement`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-124">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="a6c06-125">反序列化程序还将提供一个有效的父 <xref:System.Xml.XmlDocument>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-125">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="a6c06-126">请确保被反序列化为 `XmlElement` 的 XML 片段定义了它使用的所有前缀，并且不依赖于上级元素的任何前缀定义。</span><span class="sxs-lookup"><span data-stu-id="a6c06-126">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="a6c06-127">仅在使用 `DataContractSerializer` 以访问来自不同（非 `DataContractSerializer`）源的 XML 时需要注意此事项。</span><span class="sxs-lookup"><span data-stu-id="a6c06-127">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="a6c06-128">当与一起使用时 `DataContractSerializer` ， `XmlElement` 可以将以多元方式分配给类型的数据成员 <xref:System.Object> 。</span><span class="sxs-lookup"><span data-stu-id="a6c06-128">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="a6c06-129">即使 <xref:System.Collections.IEnumerable> 实现 `XmlElement`，它也不能用作集合类型，并且无法分配给 <xref:System.Collections.IEnumerable> 数据成员。</span><span class="sxs-lookup"><span data-stu-id="a6c06-129">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="a6c06-130">与所有多态分配一样，将在 `DataContractSerializer` 生成的 XML 中发出数据协定名称，在这种情况下，它是 "" 命名空间中的 "XmlElement" http://schemas.datacontract.org/2004/07/System.Xml 。</span><span class="sxs-lookup"><span data-stu-id="a6c06-130">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="a6c06-131">使用 `NetDataContractSerializer` 时，支持任何有效的 `XmlElement` 多态分配（分配给 `Object` 或 `IEnumerable`）。</span><span class="sxs-lookup"><span data-stu-id="a6c06-131">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="a6c06-132">请勿尝试使用任何一个从 `XmlElement` 派生的类型的序列化程序，无论是否对它们进行多元方式的分配。</span><span class="sxs-lookup"><span data-stu-id="a6c06-132">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="a6c06-133">XmlNode 数组</span><span class="sxs-lookup"><span data-stu-id="a6c06-133">Array of XmlNode</span></span>  

 <span data-ttu-id="a6c06-134"><xref:System.Xml.XmlNode> 数组的用法与 `XmlElement` 的用法极其类似。</span><span class="sxs-lookup"><span data-stu-id="a6c06-134">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="a6c06-135">但 `XmlNode` 数组的用法比 `XmlElement` 的用法更灵活。</span><span class="sxs-lookup"><span data-stu-id="a6c06-135">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="a6c06-136">您可以在数据成员包装元素内写入多个元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-136">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="a6c06-137">还可以在数据成员包装元素内插入元素以外的内容，如 XML 注释。</span><span class="sxs-lookup"><span data-stu-id="a6c06-137">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="a6c06-138">最后，您可以向包装数据成员元素中插入属性。</span><span class="sxs-lookup"><span data-stu-id="a6c06-138">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="a6c06-139">所有这些操作都可以通过对 `XmlNode` 的数组填充 `XmlNode` 的特定派生类来实现，如 <xref:System.Xml.XmlAttribute>、`XmlElement` 或 <xref:System.Xml.XmlComment>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-139">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="a6c06-140">例如，使用以下类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-140">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="a6c06-141">序列化后，所生成的 XML 将类似于以下代码。</span><span class="sxs-lookup"><span data-stu-id="a6c06-141">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="a6c06-142">请注意，数据成员包装元素 `<myDataMember>` 包含一个属性、一个注释和两个元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-142">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="a6c06-143">这些是经过序列化的四个 `XmlNode` 实例。</span><span class="sxs-lookup"><span data-stu-id="a6c06-143">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="a6c06-144">产生无效 XML 的 `XmlNode` 数组无法序列化。</span><span class="sxs-lookup"><span data-stu-id="a6c06-144">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="a6c06-145">例如，两个 `XmlNode` 实例（其中一个是 `XmlElement`，另一个是 <xref:System.Xml.XmlAttribute>）的数组是无效的，因为此序列与任何有效的 XML 实例都不对应（没有附加该属性的位置）。</span><span class="sxs-lookup"><span data-stu-id="a6c06-145">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="a6c06-146">在反序列化 `XmlNode` 数组时，将创建节点并用传入 XML 的信息进行填充。</span><span class="sxs-lookup"><span data-stu-id="a6c06-146">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="a6c06-147">反序列化程序还将提供一个有效的父 <xref:System.Xml.XmlDocument>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-147">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="a6c06-148">所有节点都将反序列化，包括包装数据成员元素上的任何属性，但不包括 WCF 序列化程序所放置的属性 (如用于指示多态赋值) 的属性。</span><span class="sxs-lookup"><span data-stu-id="a6c06-148">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="a6c06-149">有关在 XML 片段中定义所有命名空间前缀的注意事项适用于反序列化 `XmlNode` 数组，它们所起的作用与在反序列化 `XmlElement` 时类似。</span><span class="sxs-lookup"><span data-stu-id="a6c06-149">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="a6c06-150">如果在启用对象图预留时使用序列化程序，则对象相等仅预留在 `XmlNode` 数组级别上，而不是各个 `XmlNode` 实例上。</span><span class="sxs-lookup"><span data-stu-id="a6c06-150">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="a6c06-151">请勿尝试序列化其中有一个或多个节点设置为 `XmlNode` 的 `null` 数组。</span><span class="sxs-lookup"><span data-stu-id="a6c06-151">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="a6c06-152">允许将整个数组成员都设置为 `null`，但是数组中包含的任何单个 `XmlNode` 除外。</span><span class="sxs-lookup"><span data-stu-id="a6c06-152">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="a6c06-153">如果整个数组成员都为 Null，则包装数据成员元素将包含一个指示该数组为 Null 的特殊属性。</span><span class="sxs-lookup"><span data-stu-id="a6c06-153">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="a6c06-154">在反序列化时，整个数组成员也将变为 Null。</span><span class="sxs-lookup"><span data-stu-id="a6c06-154">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="a6c06-155">序列化程序仅对 `XmlNode` 的常规数组进行特殊处理。</span><span class="sxs-lookup"><span data-stu-id="a6c06-155">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="a6c06-156">不会对声明为包含 `XmlNode` 的其他集合类型的数据成员，或声明为类型派生自 `XmlNode` 的数组的数据成员进行特殊处理。</span><span class="sxs-lookup"><span data-stu-id="a6c06-156">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="a6c06-157">因此，除非它们还满足其他某个序列化条件，否则一般情况下，它们都不能序列化。</span><span class="sxs-lookup"><span data-stu-id="a6c06-157">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="a6c06-158">允许使用数组或 `XmlNode` 数组的集合。</span><span class="sxs-lookup"><span data-stu-id="a6c06-158">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="a6c06-159">有一个包装元素适用于整个集合，并且外部数组或集合中的每一个 `<myDataMember>` 数组都对应一个单独的包装元素（类似于上面示例中的 `XmlNode`）。</span><span class="sxs-lookup"><span data-stu-id="a6c06-159">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="a6c06-160">使用 <xref:System.Array> 实例填充 `Object` 的 `Array` 类型的数据成员（或 `IEnumerable` 的 `XmlNode` 类型的数据成员）时，将不会导致数据成员被视为 `Array` 实例的 `XmlNode`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-160">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="a6c06-161">将分别序列化每个数组成员。</span><span class="sxs-lookup"><span data-stu-id="a6c06-161">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="a6c06-162">当与 `DataContractSerializer` 一起使用时，能够以多元方式分配 `XmlNode` 的数组，但只能分配到 `Object` 类型的数据成员。</span><span class="sxs-lookup"><span data-stu-id="a6c06-162">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="a6c06-163">即使 `IEnumerable` 数组实现 `XmlNode`，它也无法用作集合类型，并且无法分配给 `IEnumerable` 数据成员。</span><span class="sxs-lookup"><span data-stu-id="a6c06-163">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="a6c06-164">与所有多态分配一样，将在 `DataContractSerializer` 生成的 XML 中发出数据协定名称–在本例中，它是 "" 命名空间中的 "ArrayOfXmlNode" http://schemas.datacontract.org/2004/07/System.Xml 。</span><span class="sxs-lookup"><span data-stu-id="a6c06-164">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="a6c06-165">当与一起使用时 `NetDataContractSerializer` ，支持任何有效的 `XmlNode` 数组赋值。</span><span class="sxs-lookup"><span data-stu-id="a6c06-165">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="a6c06-166">架构注意事项</span><span class="sxs-lookup"><span data-stu-id="a6c06-166">Schema Considerations</span></span>  

 <span data-ttu-id="a6c06-167">有关 XML 类型的架构映射的详细信息，请参阅 [数据协定架构引用](data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="a6c06-167">For details about the schema mapping of XML types, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="a6c06-168">本节介绍重点摘要。</span><span class="sxs-lookup"><span data-stu-id="a6c06-168">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="a6c06-169">将 `XmlElement` 类型的数据成员映射到使用以下匿名类型定义的元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-169">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="a6c06-170">将 `XmlNode` 数组类型的数据成员映射到使用以下匿名类型定义的元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-170">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="a6c06-171">实现 IXmlSerializable 接口的类型</span><span class="sxs-lookup"><span data-stu-id="a6c06-171">Types Implementing the IXmlSerializable Interface</span></span>  

 <span data-ttu-id="a6c06-172">`IXmlSerializable` 完全支持实现 `DataContractSerializer` 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-172">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="a6c06-173"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 属性应始终应用于这些类型以控制它们的架构。</span><span class="sxs-lookup"><span data-stu-id="a6c06-173">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="a6c06-174">实现 `IXmlSerializable` 的类型有以下三种：表示任意内容的类型、表示单一元素的类型和旧的 <xref:System.Data.DataSet> 类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-174">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="a6c06-175">内容类型使用由 `XmlSchemaProviderAttribute` 属性指定的架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-175">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="a6c06-176">该方法不返回 `null`，并且属性 (Attribute) 上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 属性 (Property) 将保留为它的默认值 `false`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-176">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="a6c06-177">这是 `IXmlSerializable` 类型的最常见的用法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-177">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="a6c06-178">当 `IXmlSerializable` 类型必须控制其根元素名称时，使用元素类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-178">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="a6c06-179">若要将某个类型标记为元素类型，可以将 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 属性 (Attribute) 上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 属性 (Property) 设置为 `true`，或从架构提供程序方法返回 null。</span><span class="sxs-lookup"><span data-stu-id="a6c06-179">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="a6c06-180">元素类型可以具有架构提供程序方法，在 `XmlSchemaProviderAttribute` 中可以指定 null 代替方法名称。</span><span class="sxs-lookup"><span data-stu-id="a6c06-180">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="a6c06-181">但是，如果 `IsAny` 为 `true`，并且已指定了架构提供程序方法，则该方法必须返回 null。</span><span class="sxs-lookup"><span data-stu-id="a6c06-181">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
- <span data-ttu-id="a6c06-182">旧 <xref:System.Data.DataSet> 类型为没有使用 `IXmlSerializable` 特性标记的 `XmlSchemaProviderAttribute` 类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-182">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="a6c06-183">相反，它们依赖于架构生成的 <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-183">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="a6c06-184">此模式用于 `DataSet` 类型，其类型化数据集在 .NET Framework 的早期版本中派生了一个类，但现在它已过时，并且只有旧版本才支持它。</span><span class="sxs-lookup"><span data-stu-id="a6c06-184">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="a6c06-185">不要依赖于此模式，并始终将 `XmlSchemaProviderAttribute` 应用于 `IXmlSerializable` 类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-185">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="a6c06-186">IXmlSerializable 内容类型</span><span class="sxs-lookup"><span data-stu-id="a6c06-186">IXmlSerializable Content Types</span></span>  

 <span data-ttu-id="a6c06-187">如果正在序列化实现 `IXmlSerializable` 的类型的数据成员，且该类型为前面定义的内容类型，则序列化程序将编写该数据成员的包装元素，并将控制权传递给 <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-187">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="a6c06-188"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 实现可以编写任何 XML，包括将属性添加到包装元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-188">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="a6c06-189">`WriteXml` 完成后，序列化程序将关闭该元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-189">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="a6c06-190">如果正在反序列化实现 `IXmlSerializable` 的类型的数据成员，且该类型为前面定义的内容类型，则反序列化程序会将 XML 读取器放置在该数据成员的包装元素上，并将控制权传递给 <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-190">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="a6c06-191">该方法必须读取整个元素，包括起始和结束标记。</span><span class="sxs-lookup"><span data-stu-id="a6c06-191">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="a6c06-192">请确保你的 `ReadXml` 代码可处理元素为空的情况。</span><span class="sxs-lookup"><span data-stu-id="a6c06-192">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="a6c06-193">此外，您的 `ReadXml` 实现也不应该依赖于以特殊方式进行命名的包装元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-193">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="a6c06-194">序列化程序所选的名称可以不同。</span><span class="sxs-lookup"><span data-stu-id="a6c06-194">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="a6c06-195">允许以多元方式分配 `IXmlSerializable` 内容类型，例如，分配给 <xref:System.Object> 类型的数据成员。</span><span class="sxs-lookup"><span data-stu-id="a6c06-195">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="a6c06-196">还允许类型实例为 null。</span><span class="sxs-lookup"><span data-stu-id="a6c06-196">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="a6c06-197">最后，可以在启用对象图保留的情况下使用 `IXmlSerializable` 类型，以及和 <xref:System.Runtime.Serialization.NetDataContractSerializer> 一起使用。</span><span class="sxs-lookup"><span data-stu-id="a6c06-197">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="a6c06-198">所有这些功能都要求 WCF 序列化程序将某些属性附加到包装元素中， ( "nil" 和 "type"，在 XML 架构实例命名空间中，将 "Id"、"Ref"、"Type" 和 "Assembly" 附加到 WCF 特定的命名空间) 。</span><span class="sxs-lookup"><span data-stu-id="a6c06-198">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="a6c06-199">实现 ReadXml 时要忽略的属性</span><span class="sxs-lookup"><span data-stu-id="a6c06-199">Attributes to Ignore when Implementing ReadXml</span></span>  

 <span data-ttu-id="a6c06-200">在将控制权传递给 `ReadXml` 代码之前，反序列化程序将检查 XML 元素、检测这些特殊的 XML 属性，以及对它们进行操作。</span><span class="sxs-lookup"><span data-stu-id="a6c06-200">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="a6c06-201">例如，如果“nil”为 `true`，则将反序列化一个 Null 值，并且不调用 `ReadXml`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-201">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="a6c06-202">如果检测到多态性，则将反序列化该元素的内容，就好像该元素为其他类型一样。</span><span class="sxs-lookup"><span data-stu-id="a6c06-202">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="a6c06-203">调用以多元方式分配的类型的 `ReadXml` 实现。</span><span class="sxs-lookup"><span data-stu-id="a6c06-203">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="a6c06-204">在任何情况下，`ReadXml` 实现都应忽略这些特殊属性，因为它们均由反序列化程序处理。</span><span class="sxs-lookup"><span data-stu-id="a6c06-204">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="a6c06-205">IXmlSerializable 内容类型的架构注意事项</span><span class="sxs-lookup"><span data-stu-id="a6c06-205">Schema Considerations for IXmlSerializable Content Types</span></span>  

 <span data-ttu-id="a6c06-206">导出 `IXmlSerializable` 内容类型的架构时，将调用架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-206">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="a6c06-207">并将 <xref:System.Xml.Schema.XmlSchemaSet> 传递给架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-207">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="a6c06-208">该方法可以将任何有效架构添加到架构集中。</span><span class="sxs-lookup"><span data-stu-id="a6c06-208">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="a6c06-209">该架构集将包含发生架构导出时已知的架构。</span><span class="sxs-lookup"><span data-stu-id="a6c06-209">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="a6c06-210">当架构提供程序方法必须将项添加到架构集中时，它必须确定该集中是否已存在具有适当命名空间的 <xref:System.Xml.Schema.XmlSchema>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-210">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="a6c06-211">如果已存在，则架构提供程序方法必须将新项添加到现有 `XmlSchema` 中。</span><span class="sxs-lookup"><span data-stu-id="a6c06-211">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="a6c06-212">否则，它必须创建一个新的 `XmlSchema` 实例。</span><span class="sxs-lookup"><span data-stu-id="a6c06-212">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="a6c06-213">如果使用的是 `IXmlSerializable` 类型数组，这是非常重要的。</span><span class="sxs-lookup"><span data-stu-id="a6c06-213">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="a6c06-214">例如，如果您有一个 `IXmlSerializable` 类型，且已作为命名空间“B”中的类型“A”导出，则在调用架构提供程序方法时，架构集可能已包含保存“ArrayOfA”类型的“B”架构。</span><span class="sxs-lookup"><span data-stu-id="a6c06-214">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="a6c06-215">除了将类型添加到 <xref:System.Xml.Schema.XmlSchemaSet>，内容类型的架构提供程序方法必须返回非空值。</span><span class="sxs-lookup"><span data-stu-id="a6c06-215">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="a6c06-216">它可能返回 <xref:System.Xml.XmlQualifiedName>，指定用于给定 `IXmlSerializable` 类型的架构类型名称。</span><span class="sxs-lookup"><span data-stu-id="a6c06-216">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="a6c06-217">此限定名称也将用作数据协定名称和该类型的命名空间。</span><span class="sxs-lookup"><span data-stu-id="a6c06-217">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="a6c06-218">返回架构提供程序方法时允许立即返回架构集中不存在的类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-218">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="a6c06-219">但是，导出所有相关类型（调用 <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> 方法中有关 <xref:System.Runtime.Serialization.XsdDataContractExporter> 的所有相关类型并访问 <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> 属性）时，该类型应该存在于架构集中。</span><span class="sxs-lookup"><span data-stu-id="a6c06-219">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="a6c06-220">在进行所有相关的 `Schemas` 调用之前访问 `Export` 属性可能会导致 <xref:System.Xml.Schema.XmlSchemaException>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-220">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="a6c06-221">有关导出过程的详细信息，请参阅 [从类导出架构](exporting-schemas-from-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="a6c06-221">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="a6c06-222">架构提供程序方法也可以返回要使用的 <xref:System.Xml.Schema.XmlSchemaType>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-222">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="a6c06-223">该类型可能是匿名的，也可能不是。</span><span class="sxs-lookup"><span data-stu-id="a6c06-223">The type may or may not be anonymous.</span></span> <span data-ttu-id="a6c06-224">如果它是匿名的，则每次将 `IXmlSerializable` 类型用作数据成员时，`IXmlSerializable` 类型的架构都将作为匿名类型导出。</span><span class="sxs-lookup"><span data-stu-id="a6c06-224">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="a6c06-225">`IXmlSerializable` 类型仍具有数据协定名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="a6c06-225">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="a6c06-226"> (根据[数据协定名称](data-contract-names.md)中所述确定此项，但 <xref:System.Runtime.Serialization.DataContractAttribute> 不能使用该特性自定义该名称。 ) 如果不是匿名的，则它必须是中的类型之一。 `XmlSchemaSet`</span><span class="sxs-lookup"><span data-stu-id="a6c06-226">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="a6c06-227">这种情况相当于返回该类型的 `XmlQualifiedName`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-227">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="a6c06-228">另外，还将导出该类型的全局元素声明。</span><span class="sxs-lookup"><span data-stu-id="a6c06-228">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="a6c06-229">如果该类型没有应用于它的 <xref:System.Xml.Serialization.XmlRootAttribute> 属性 (Attribute)，则该元素将具有与数据协定相同的名称和命名空间，且它的“nillable”属性 (property) 将为 true。</span><span class="sxs-lookup"><span data-stu-id="a6c06-229">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="a6c06-230">唯一的例外情况是架构命名空间 ( " http://www.w3.org/2001/XMLSchema " ) –如果该类型的数据协定在此命名空间中，则对应的全局元素位于空白命名空间中，因为禁止将新元素添加到架构命名空间。</span><span class="sxs-lookup"><span data-stu-id="a6c06-230">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="a6c06-231">如果该类型具有应用于它的 `XmlRootAttribute` 属性 (Attribute)，则将使用以下属性 (Property) 导出全局元素声明：<xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>、<xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> 和 <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>。</span><span class="sxs-lookup"><span data-stu-id="a6c06-231">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="a6c06-232">应用 `XmlRootAttribute` 的默认值为数据协定名称、空白命名空间和值为 true 的“nillable”。</span><span class="sxs-lookup"><span data-stu-id="a6c06-232">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="a6c06-233">同样的全局元素声明规则也适用于旧数据集类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-233">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="a6c06-234">请注意，`XmlRootAttribute` 无法重写通过自定义代码添加的全局元素声明，无论是使用构架提供程序方法添加到 `XmlSchemaSet` 中的，还是通过旧数据集类型的 `GetSchema` 添加的。</span><span class="sxs-lookup"><span data-stu-id="a6c06-234">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="a6c06-235">IXmlSerializable 元素类型</span><span class="sxs-lookup"><span data-stu-id="a6c06-235">IXmlSerializable Element Types</span></span>  

 <span data-ttu-id="a6c06-236">`IXmlSerializable` 元素类型将 `IsAny` 属性设为 `true`，或使它们的架构提供程序方法返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-236">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="a6c06-237">序列化和反序列化元素类型与序列化和反序列化内容类型极其相似。</span><span class="sxs-lookup"><span data-stu-id="a6c06-237">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="a6c06-238">但是，也有一些重要的区别：</span><span class="sxs-lookup"><span data-stu-id="a6c06-238">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="a6c06-239">`WriteXml` 实现应只写入一个元素（当然，该元素可包含多个子元素）。</span><span class="sxs-lookup"><span data-stu-id="a6c06-239">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="a6c06-240">它不应是此单个元素、多个同级元素或混合内容以外的写属性。</span><span class="sxs-lookup"><span data-stu-id="a6c06-240">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="a6c06-241">该元素可能为空。</span><span class="sxs-lookup"><span data-stu-id="a6c06-241">The element may be empty.</span></span>  
  
- <span data-ttu-id="a6c06-242">`ReadXml` 实现不应读取包装元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-242">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="a6c06-243">它应读取 `WriteXml` 生成的那一个元素。</span><span class="sxs-lookup"><span data-stu-id="a6c06-243">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="a6c06-244">定期序列化元素类型时（例如，作为数据协定中的数据成员），序列化程序将在调用 `WriteXml` 之前输出包装元素，如同处理内容类型一样。</span><span class="sxs-lookup"><span data-stu-id="a6c06-244">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="a6c06-245">然而，在顶层序列化元素类型时，序列化程序通常根本不输出 `WriteXml` 写入的元素周围的包装元素，除非在 `DataContractSerializer` 或 `NetDataContractSerializer` 构造函数中构造序列化程序时显式指定了根名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="a6c06-245">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="a6c06-246">有关详细信息，请参阅 [序列化和反序列](serialization-and-deserialization.md)化。</span><span class="sxs-lookup"><span data-stu-id="a6c06-246">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="a6c06-247">如果在构造期间没有指定根名称和命名空间的情况下在顶层序列化元素类型，则 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 实质上不执行任何操作，且 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> 将调用 `WriteXml`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-247">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="a6c06-248">在此模式下，正在序列化的对象不能为 null，也不能多元分配。</span><span class="sxs-lookup"><span data-stu-id="a6c06-248">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="a6c06-249">另外，不能启用对象图保留，也不能使用 `NetDataContractSerializer`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-249">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="a6c06-250">如果在构造时没有指定根名称和命名空间的情况下在顶级反序列化某一元素类型，则在找到任何元素的开头时，<xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> 将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="a6c06-250">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="a6c06-251"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 参数设置为 `verifyObjectName` 的 `true` 在行为上与实际读取该对象前 `IsStartObject` 的行为相同。</span><span class="sxs-lookup"><span data-stu-id="a6c06-251"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="a6c06-252">然后，`ReadObject` 将控制传递到 `ReadXml` 方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-252">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="a6c06-253">如上节所述，元素类型的导出架构与 `XmlElement` 类型的导出架构相同，只是架构提供程序方法可以像处理内容类型那样将任何其他架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> 中。</span><span class="sxs-lookup"><span data-stu-id="a6c06-253">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="a6c06-254">不允许使用元素类型的 `XmlRootAttribute` 属性，也从不为这些类型发出全局元素声明。</span><span class="sxs-lookup"><span data-stu-id="a6c06-254">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="a6c06-255">与 XmlSerializer 的区别</span><span class="sxs-lookup"><span data-stu-id="a6c06-255">Differences from the XmlSerializer</span></span>  

 <span data-ttu-id="a6c06-256">`IXmlSerializable` 接口以及 `XmlSchemaProviderAttribute` 和 `XmlRootAttribute` 属性也都可以由 <xref:System.Xml.Serialization.XmlSerializer> 理解。</span><span class="sxs-lookup"><span data-stu-id="a6c06-256">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="a6c06-257">但是，在数据协定模型中处理它们的方法有一些不同。</span><span class="sxs-lookup"><span data-stu-id="a6c06-257">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="a6c06-258">主要的区别总结如下：</span><span class="sxs-lookup"><span data-stu-id="a6c06-258">The important differences are summarized in the following:</span></span>  
  
- <span data-ttu-id="a6c06-259">架构提供程序方法在 `XmlSerializer` 中必须公开为可用的，但在数据协定模型中无需如此。</span><span class="sxs-lookup"><span data-stu-id="a6c06-259">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
- <span data-ttu-id="a6c06-260">如果 `IsAny` 在数据协定模型中为 true，但在 `XmlSerializer` 中不为 true，则调用架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-260">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="a6c06-261">如果内容或旧数据集类型中没有 `XmlRootAttribute` 属性，则 `XmlSerializer` 将在空白命名空间中导出全局元素声明。</span><span class="sxs-lookup"><span data-stu-id="a6c06-261">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="a6c06-262">如前面所述，在数据协定模型中，使用的命名空间通常是数据协定命名空间。</span><span class="sxs-lookup"><span data-stu-id="a6c06-262">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="a6c06-263">创建与这两种序列化技术一起使用的类型时，请注意这些区别。</span><span class="sxs-lookup"><span data-stu-id="a6c06-263">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="a6c06-264">导入 IXmlSerializable 架构</span><span class="sxs-lookup"><span data-stu-id="a6c06-264">Importing IXmlSerializable Schema</span></span>  

 <span data-ttu-id="a6c06-265">导入从 `IXmlSerializable` 类型生成的架构时，有以下几种可能：</span><span class="sxs-lookup"><span data-stu-id="a6c06-265">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="a6c06-266">生成的架构可能是有效的数据协定架构，如 [数据协定架构引用](data-contract-schema-reference.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="a6c06-266">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="a6c06-267">在此情况下，架构可以正常导入，并且将生成常规数据协定类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-267">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="a6c06-268">生成的架构可能不是有效的数据协定架构。</span><span class="sxs-lookup"><span data-stu-id="a6c06-268">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="a6c06-269">例如，您的架构提供程序方法可能生成包含 XML 属性的架构，而数据协定模型不支持 XML 属性。</span><span class="sxs-lookup"><span data-stu-id="a6c06-269">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="a6c06-270">在此情况下，您可以将架构作为 `IXmlSerializable` 类型导入。</span><span class="sxs-lookup"><span data-stu-id="a6c06-270">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="a6c06-271">默认情况下，此导入模式不处于启用状态，但可以轻松启用–例如，通过 `/importXmlTypes` 命令行开关转到 [)  ( ](../servicemodel-metadata-utility-tool-svcutil-exe.md)"带</span><span class="sxs-lookup"><span data-stu-id="a6c06-271">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="a6c06-272">[导入架构以生成类中对](importing-schema-to-generate-classes.md)此进行了详细介绍。</span><span class="sxs-lookup"><span data-stu-id="a6c06-272">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="a6c06-273">请注意，您必须直接处理您的类型实例的 XML。</span><span class="sxs-lookup"><span data-stu-id="a6c06-273">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="a6c06-274">您也可以考虑使用其他支持各种架构的不同序列化技术 – 请参见有关使用 `XmlSerializer` 的主题。</span><span class="sxs-lookup"><span data-stu-id="a6c06-274">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="a6c06-275">您可能希望重新使用代理中的现有 `IXmlSerializable` 类型，而不生成新的类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-275">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="a6c06-276">在此情况下，“导入架构以生成类型”主题中介绍的引用类型功能可用于指示要重新使用的类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-276">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="a6c06-277">这对应于在 svcutil.exe 上使用 `/reference` 开关，以指定包含要重新使用的类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="a6c06-277">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="a6c06-278">在数据协定中表示任意 XML</span><span class="sxs-lookup"><span data-stu-id="a6c06-278">Representing Arbitrary XML in Data Contracts</span></span>  

 <span data-ttu-id="a6c06-279">`XmlElement`、`XmlNode` 数组和 `IXmlSerializable` 类型，允许您将插入任意 XML 插入数据协定模型中。</span><span class="sxs-lookup"><span data-stu-id="a6c06-279">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="a6c06-280">`DataContractSerializer` 和 `NetDataContractSerializer` 将此 XML 内容传递到所使用的 XML 编写器，而不会干扰此过程。</span><span class="sxs-lookup"><span data-stu-id="a6c06-280">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="a6c06-281">但是，XML 编写器可能对它们编写的 XML 强制执行一些限制。</span><span class="sxs-lookup"><span data-stu-id="a6c06-281">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="a6c06-282">具体而言，以下是一些重要示例：</span><span class="sxs-lookup"><span data-stu-id="a6c06-282">Specifically, here are some important examples:</span></span>  
  
- <span data-ttu-id="a6c06-283">XML 编写器通常不允许 XML 文档声明 (例如， \<?xml version=’1.0’ ?> 在编写另一个文档的过程中) 。</span><span class="sxs-lookup"><span data-stu-id="a6c06-283">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="a6c06-284">您不能使用完整的 XML 文档并将其作为 `Array` 数据成员的 `XmlNode` 进行序列化。</span><span class="sxs-lookup"><span data-stu-id="a6c06-284">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="a6c06-285">要执行此操作，您必须提取出文档声明或使用自己的编码方案表示它。</span><span class="sxs-lookup"><span data-stu-id="a6c06-285">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
- <span data-ttu-id="a6c06-286">使用 WCF 拒绝 XML 处理指令提供的所有 XML 编写器 (\<? … ?>) 和文档类型定义 (\<! … >) ，因为 SOAP 消息中不允许使用它们。</span><span class="sxs-lookup"><span data-stu-id="a6c06-286">All of the XML writers supplied with WCF reject XML processing instructions (\<? … ?>) and document type definitions (\<! … >), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="a6c06-287">同样，您可以使用自己的编码机制避免此限制。</span><span class="sxs-lookup"><span data-stu-id="a6c06-287">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="a6c06-288">如果您必须要在生成的 XML 中包含这些内容，则可以编写一个自定义编码器，以使用支持这些内容的 XML 编写器。</span><span class="sxs-lookup"><span data-stu-id="a6c06-288">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
- <span data-ttu-id="a6c06-289">在实现 `WriteXml` 时，避免对 XML 编写器调用 <xref:System.Xml.XmlWriter.WriteRaw%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-289">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="a6c06-290">WCF 使用各种 XML 编码 (包括二进制) ，因此很难或不可能使用 `WriteRaw` 此类结果，从而可在任何编码中使用结果。</span><span class="sxs-lookup"><span data-stu-id="a6c06-290">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
- <span data-ttu-id="a6c06-291">实现时 `WriteXml` ，请避免使用 <xref:System.Xml.XmlWriter.WriteEntityRef%2A> <xref:System.Xml.XmlWriter.WriteNmToken%2A> WCF 附带的 XML 编写器不支持的和方法。</span><span class="sxs-lookup"><span data-stu-id="a6c06-291">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="a6c06-292">使用数据集、类型化数据集和数据表</span><span class="sxs-lookup"><span data-stu-id="a6c06-292">Using DataSet, Typed DataSet and DataTable</span></span>  

 <span data-ttu-id="a6c06-293">数据协定模型中完全支持使用这些类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-293">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="a6c06-294">使用这些类型时，请考虑以下事项：</span><span class="sxs-lookup"><span data-stu-id="a6c06-294">When using these types, consider the following points:</span></span>  
  
- <span data-ttu-id="a6c06-295">这些类型的架构 (尤其是 <xref:System.Data.DataSet> 其类型化的派生类) 可能无法与某些非 WCF 平台互操作，也可能会在与这些平台一起使用时导致可用性差。</span><span class="sxs-lookup"><span data-stu-id="a6c06-295">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="a6c06-296">另外，使用 `DataSet` 类型可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="a6c06-296">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="a6c06-297">最后，这可能会增加将来升级应用程序版本的难度。</span><span class="sxs-lookup"><span data-stu-id="a6c06-297">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="a6c06-298">考虑使用显式定义的数据协定类型代替协定中的 `DataSet` 类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-298">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
- <span data-ttu-id="a6c06-299">导入 `DataSet` 或 `DataTable` 架构时，引用这些类型很重要。</span><span class="sxs-lookup"><span data-stu-id="a6c06-299">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="a6c06-300">使用 Svcutil.exe 命令行工具，可以通过将 System.Data.dll 程序集名称传递给开关来完成此操作 `/reference` 。</span><span class="sxs-lookup"><span data-stu-id="a6c06-300">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="a6c06-301">如果导入类型化数据集架构，则必须引用类型化数据集的类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-301">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="a6c06-302">在 Svcutil.exe 中，将类型化数据集的程序集的位置传递到 `/reference` 开关。</span><span class="sxs-lookup"><span data-stu-id="a6c06-302">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="a6c06-303">有关引用类型的详细信息，请参阅 [导入架构以生成类](importing-schema-to-generate-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="a6c06-303">For more information about referencing types, see the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="a6c06-304">对数据协定模型中类型化数据集的支持是有限的。</span><span class="sxs-lookup"><span data-stu-id="a6c06-304">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="a6c06-305">类型化数据集可以序列化和反序列化，并可导出其架构。</span><span class="sxs-lookup"><span data-stu-id="a6c06-305">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="a6c06-306">但是，数据协定架构导入无法从该架构生成新的类型化数据集类型，因为它只能重新使用现有的类型化数据集类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-306">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="a6c06-307">通过对 Svcutil.exe 使用 `/r` 开关，可以指向现有类型化数据集。</span><span class="sxs-lookup"><span data-stu-id="a6c06-307">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="a6c06-308">如果尝试在不使用 `/r` 开关的情况下对使用类型化数据集的服务使用 Svcutil.exe，则会自动选择替代序列化程序 (XmlSerializer)。</span><span class="sxs-lookup"><span data-stu-id="a6c06-308">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="a6c06-309">如果必须使用 DataContractSerializer 且必须从架构生成数据集，则可使用以下过程：生成类型化数据集类型（通过将 Xsd.exe 工具与 `/d` 开关结合起来用于服务）、编译类型，然后在 Svcutil.exe 上使用 `/r` 开关来指向这些类型。</span><span class="sxs-lookup"><span data-stu-id="a6c06-309">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a6c06-310">请参阅</span><span class="sxs-lookup"><span data-stu-id="a6c06-310">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.IXmlSerializable>
- [<span data-ttu-id="a6c06-311">使用数据协定</span><span class="sxs-lookup"><span data-stu-id="a6c06-311">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="a6c06-312">数据协定序列化程序支持的类型</span><span class="sxs-lookup"><span data-stu-id="a6c06-312">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
