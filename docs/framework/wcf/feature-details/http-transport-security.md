---
description: 了解更多： HTTP 传输安全
title: HTTP 传输安全
ms.date: 03/30/2017
ms.assetid: d3439262-c58e-4d30-9f2b-a160170582bb
ms.openlocfilehash: 946fe1066005d66c853ee3ce79c82099306264b0
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99734056"
---
# <a name="http-transport-security"></a><span data-ttu-id="81039-103">HTTP 传输安全</span><span class="sxs-lookup"><span data-stu-id="81039-103">HTTP Transport Security</span></span>

<span data-ttu-id="81039-104">如果使用 HTTP 作为传输，则由安全套接字层 (SSL) 实现提供安全。</span><span class="sxs-lookup"><span data-stu-id="81039-104">When using HTTP as the transport, security is provided by a Secure Sockets Layer (SSL) implementation.</span></span> <span data-ttu-id="81039-105">SSL 广泛用于 Internet 中，以便向客户端证明服务的身份，并且随后向通道提供保密性（加密）。</span><span class="sxs-lookup"><span data-stu-id="81039-105">SSL is widely used on the Internet to authenticate a service to a client, and then to provide confidentiality (encryption) to the channel.</span></span> <span data-ttu-id="81039-106">本主题说明 SSL 如何工作，以及如何在 Windows Communication Foundation (WCF) 中实现它。</span><span class="sxs-lookup"><span data-stu-id="81039-106">This topic explains how SSL works and how it is implemented in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="basic-ssl"></a><span data-ttu-id="81039-107">基本 SSL</span><span class="sxs-lookup"><span data-stu-id="81039-107">Basic SSL</span></span>  

 <span data-ttu-id="81039-108">SSL 的工作方式可以通过一个典型方案得到最好的说明，在本示例中，该方案为银行的网站。</span><span class="sxs-lookup"><span data-stu-id="81039-108">How SSL works is best explained through a typical scenario, in this case, a bank's Web site.</span></span> <span data-ttu-id="81039-109">该网站允许客户使用用户名和密码登录。</span><span class="sxs-lookup"><span data-stu-id="81039-109">The site allows a customer to log on with a user name and password.</span></span> <span data-ttu-id="81039-110">在经过身份验证之后，用户可以执行事务，例如查看帐户余额、支付帐单以及将钱从一个帐户转到其他帐户。</span><span class="sxs-lookup"><span data-stu-id="81039-110">After being authenticated, the user can perform transactions, such as view account balances, pay bills, and move money from one account to another.</span></span>  
  
 <span data-ttu-id="81039-111">当用户首次访问该站点时，SSL 机制会开始一系列协商（称为 *握手*），用户的客户端 (在本例中为 Internet Explorer) 。</span><span class="sxs-lookup"><span data-stu-id="81039-111">When a user first visits the site, the SSL mechanism begins a series of negotiations, called a *handshake*, with the user's client (in this case, Internet Explorer).</span></span> <span data-ttu-id="81039-112">SSL 首先向客户证明银行网站的身份。</span><span class="sxs-lookup"><span data-stu-id="81039-112">SSL first authenticates the bank site to the customer.</span></span> <span data-ttu-id="81039-113">这一步骤是必需的，因为客户首先必须知道他们正在与真实网站进行通信，而不是与一个试图引诱他们键入自己的用户名和密码的诈骗网站进行通信。</span><span class="sxs-lookup"><span data-stu-id="81039-113">This is an essential step because customers must first know that they are communicating with the actual site, and not a spoof that tries to lure them into typing in their user name and password.</span></span> <span data-ttu-id="81039-114">SSL 通过使用由受信任的颁发机构（例如 VeriSign）提供的 SSL 证书来执行此身份验证。</span><span class="sxs-lookup"><span data-stu-id="81039-114">SSL does this authentication by using an SSL certificate provided by a trusted authority, such as VeriSign.</span></span> <span data-ttu-id="81039-115">其逻辑如下：VeriSign 担保该银行网站的身份是真实的。</span><span class="sxs-lookup"><span data-stu-id="81039-115">The logic goes like this: VeriSign vouches for the identity of the bank site.</span></span> <span data-ttu-id="81039-116">由于 Internet Explorer 信任 VeriSign，因此也信任该网站。</span><span class="sxs-lookup"><span data-stu-id="81039-116">Because Internet Explorer trusts VeriSign, the site is trusted.</span></span> <span data-ttu-id="81039-117">如果您希望向 VeriSign 进行核实，可以通过单击 VeriSign 徽标执行此操作。</span><span class="sxs-lookup"><span data-stu-id="81039-117">If you want to check with VeriSign, you can do so as well by clicking on the VeriSign logo.</span></span> <span data-ttu-id="81039-118">这将显示一份含有到期日期以及接受方（银行网站）的真实性声明。</span><span class="sxs-lookup"><span data-stu-id="81039-118">That presents a statement of authenticity with its expiration date and who it is issued to (the bank site).</span></span>  
  
 <span data-ttu-id="81039-119">若要启动一个安全会话，客户端向服务器发送一个等效于“你好”的项，连同一个它可以用来签名、生成哈希以及进行加密和解密的加密算法列表。</span><span class="sxs-lookup"><span data-stu-id="81039-119">To initiate a secure session, the client sends the equivalent of a "hello" to the server along with a list of cryptographic algorithms it can use to sign, generate hashes, and encrypt and decrypt with.</span></span> <span data-ttu-id="81039-120">作为响应，该网站发送回一个确认以及它对算法套件之一的选择。</span><span class="sxs-lookup"><span data-stu-id="81039-120">In response, the site sends back an acknowledgment and its choice of one of the algorithms suites.</span></span> <span data-ttu-id="81039-121">在该初次握手期间，双方都发送和接收 Nonce。</span><span class="sxs-lookup"><span data-stu-id="81039-121">During this initial handshake, both parties send and receive nonces.</span></span> <span data-ttu-id="81039-122">*Nonce* 是随机生成的数据片段，与站点的公钥结合使用，用于创建哈希。</span><span class="sxs-lookup"><span data-stu-id="81039-122">A *nonce* is a randomly generated piece of data that is used, in combination with the site's public key, to create a hash.</span></span> <span data-ttu-id="81039-123">*哈希* 是使用标准算法（如 SHA1）从两个数字派生的新编号。</span><span class="sxs-lookup"><span data-stu-id="81039-123">A *hash* is a new number that is derived from the two numbers using a standard algorithm, such as SHA1.</span></span> <span data-ttu-id="81039-124"> (客户端和站点还交换消息以同意要使用的哈希算法。 ) 哈希是唯一的，仅用于客户端与站点之间的会话对消息进行加密和解密。</span><span class="sxs-lookup"><span data-stu-id="81039-124">(The client and the site also exchange messages to agree which hash algorithm to use.) The hash is unique and is used only for the session between the client and the site to encrypt and decrypt messages.</span></span> <span data-ttu-id="81039-125">客户端和服务都具有原始 Nonce 和证书的公钥，所以通信两端可以生成同一个哈希。</span><span class="sxs-lookup"><span data-stu-id="81039-125">Both client and service have the original nonce and the certificate's public key, so both sides can generate the same hash.</span></span> <span data-ttu-id="81039-126">因此，客户端可以通过以下方式验证服务所发送的哈希：(a) 使用商定的算法根据数据计算哈希；并 (b) 将计算出的哈希与服务所发送的哈希进行比较。如果二者匹配，则客户端可以确信该哈希未遭篡改。</span><span class="sxs-lookup"><span data-stu-id="81039-126">Therefore, the client validates the hash sent by the service by (a) using the agreed upon algorithm to calculate the hash from the data, and (b) comparing it to the hash sent by the service; if the two match, then the client has assurance that the hash has not been tampered with.</span></span> <span data-ttu-id="81039-127">客户端随后可以将此哈希用作密钥，以便对同时包含另一个新哈希的消息进行加密。</span><span class="sxs-lookup"><span data-stu-id="81039-127">The client can then use this hash as a key to encrypt a message that contains yet another new hash.</span></span> <span data-ttu-id="81039-128">服务可以使用此哈希对消息进行解密，并重新获得倒数第二个哈希。</span><span class="sxs-lookup"><span data-stu-id="81039-128">The service can decrypt the message using the hash, and recover this second-to-final hash.</span></span> <span data-ttu-id="81039-129">这样，通信双方就都获知累积的信息（Nonce、公钥和其他数据），并且可以创建最后一个哈希（也称主密钥）。</span><span class="sxs-lookup"><span data-stu-id="81039-129">The accumulated information (nonces, public key, and other data) is now known to both sides, and a final hash (or master key) can be created.</span></span> <span data-ttu-id="81039-130">这个最终的密钥使用倒数第二个哈希加密后发送。</span><span class="sxs-lookup"><span data-stu-id="81039-130">This final key is sent encrypted using the next-to-last hash.</span></span> <span data-ttu-id="81039-131">然后，使用主密钥对会话的其余部分的消息进行加密和解密。</span><span class="sxs-lookup"><span data-stu-id="81039-131">The master key is then used to encrypt and decrypt messages for the rest of the session.</span></span> <span data-ttu-id="81039-132">因为客户端和服务都使用相同的密钥，所以这也称为 *会话密钥*。</span><span class="sxs-lookup"><span data-stu-id="81039-132">Because both client and service use the same key, this is also called a *session key*.</span></span>  
  
 <span data-ttu-id="81039-133">会话密钥还被描述为对称密钥，或“共享秘密”。</span><span class="sxs-lookup"><span data-stu-id="81039-133">The session key is also characterized as a symmetric key, or a "shared secret."</span></span> <span data-ttu-id="81039-134">具有对称密钥很重要，因为它减少了事务双方所需执行的计算量。</span><span class="sxs-lookup"><span data-stu-id="81039-134">Having a symmetric key is important because it reduces the computation required by both sides of the transaction.</span></span> <span data-ttu-id="81039-135">如果每个消息都要求对 Nonce 和哈希进行新的交换，那么性能将会下降。</span><span class="sxs-lookup"><span data-stu-id="81039-135">If every message demanded a new exchange of nonces and hashes, performance would deteriorate.</span></span> <span data-ttu-id="81039-136">因此，SSL 的最终目标是使用允许消息在通信双方之间自由流动的对称密钥，同时具有更高程度的安全和效率。</span><span class="sxs-lookup"><span data-stu-id="81039-136">Therefore, the ultimate goal of SSL is to use a symmetric key that allows messages to flow freely between the two sides with a greater degree of security and efficiency.</span></span>  
  
 <span data-ttu-id="81039-137">因为协议可能因网站而异，所以前面的描述只是所发生过程的简化版本。</span><span class="sxs-lookup"><span data-stu-id="81039-137">The previous description is a simplified version of what happens, because the protocol may vary from site to site.</span></span> <span data-ttu-id="81039-138">还有一种可能，就是客户端和网站都在握手期间生成在算法上相结合的 Nonce，以增加数据交换过程的复杂性，从而为该过程提供更多的保护。</span><span class="sxs-lookup"><span data-stu-id="81039-138">It is also possible that both the client and the site both generate nonces that are algorithmically combined during the handshake to add more complexity, and therefore protection, to the process of exchanging data.</span></span>  
  
### <a name="certificates-and-public-key-infrastructure"></a><span data-ttu-id="81039-139">证书和公钥基础结构</span><span class="sxs-lookup"><span data-stu-id="81039-139">Certificates and Public Key Infrastructure</span></span>  

 <span data-ttu-id="81039-140">在握手期间，服务还将其 SSL 证书发送到客户端。</span><span class="sxs-lookup"><span data-stu-id="81039-140">During the handshake, the service also sends its SSL certificate to the client.</span></span> <span data-ttu-id="81039-141">该证书包含一些信息，例如证书的到期日期、颁发机构以及网站的统一资源标识符 (URI)。</span><span class="sxs-lookup"><span data-stu-id="81039-141">The certificate contains information, such as its expiration date, issuing authority, and the site's Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="81039-142">客户端将该 URI 与它原来联系的 URI 进行比较，以确保二者匹配，并且对日期和颁发机构进行检查。</span><span class="sxs-lookup"><span data-stu-id="81039-142">The client compares the URI to the URI it had originally contacted to ensure a match, and also checks the date and issuing authority.</span></span>  
  
 <span data-ttu-id="81039-143">每个证书都有两个密钥：一个私钥和一个公钥，这两个密钥称为 *交换密钥对*。</span><span class="sxs-lookup"><span data-stu-id="81039-143">Every certificate has two keys, a private key and a public key, and the two are known as an *exchange key pair*.</span></span> <span data-ttu-id="81039-144">简言之，只有证书的所有者知道私钥，而公钥则可以从证书中读取。</span><span class="sxs-lookup"><span data-stu-id="81039-144">In brief, the private key is known only to the owner of the certificate while the public key is readable from the certificate.</span></span> <span data-ttu-id="81039-145">这两个密钥都可用来加密和解密摘要、哈希或其他密钥，但它们只能用于相反的操作。</span><span class="sxs-lookup"><span data-stu-id="81039-145">Either key can be used to encrypt or decrypt a digest, hash, or other key, but only as contrary operations.</span></span> <span data-ttu-id="81039-146">例如，如果客户端使用公钥加密，则只有网站可以使用私钥对消息进行解密。</span><span class="sxs-lookup"><span data-stu-id="81039-146">For example, if the client encrypts with the public key, only the site can decrypt the message using the private key.</span></span> <span data-ttu-id="81039-147">同样，如果网站使用私钥加密，则客户端可以使用公钥解密。</span><span class="sxs-lookup"><span data-stu-id="81039-147">Similarly, if the site encrypts with the private key, the client can decrypt with the public key.</span></span> <span data-ttu-id="81039-148">这可以使客户端确信只与私钥的拥有者交换消息，因为只有使用私钥加密的消息才可以使用公钥进行解密。</span><span class="sxs-lookup"><span data-stu-id="81039-148">This provides assurance to the client that the messages are being exchanged only with the possessor of the private key because only messages encrypted with the private key can be decrypted with the public key.</span></span> <span data-ttu-id="81039-149">而网站可以确信它正在与已经使用公钥加密的客户端交换消息。</span><span class="sxs-lookup"><span data-stu-id="81039-149">The site is assured that it is exchanging messages with a client that has encrypted using the public key.</span></span> <span data-ttu-id="81039-150">然而，这种交换仅对初次握手是安全的，因此在创建实际的对称密钥时要复杂得多。</span><span class="sxs-lookup"><span data-stu-id="81039-150">This exchange is secure only for an initial handshake, however, which is why much more is done to create the actual symmetric key.</span></span> <span data-ttu-id="81039-151">尽管如此，所有通信都依赖于服务具有有效的 SSL 证书。</span><span class="sxs-lookup"><span data-stu-id="81039-151">Nevertheless, all communications depend on the service having a valid SSL certificate.</span></span>  
  
## <a name="implementing-ssl-with-wcf"></a><span data-ttu-id="81039-152">使用 WCF 实现 SSL</span><span class="sxs-lookup"><span data-stu-id="81039-152">Implementing SSL with WCF</span></span>  

 <span data-ttu-id="81039-153">HTTP 传输安全 (或 SSL) 是与 WCF 的外部提供的。</span><span class="sxs-lookup"><span data-stu-id="81039-153">HTTP transport security (or SSL) is provided externally to WCF.</span></span> <span data-ttu-id="81039-154">可以使用两种方式之一来实现 SSL；决定因素是承载应用程序的方式：</span><span class="sxs-lookup"><span data-stu-id="81039-154">You can implement SSL in one of two ways; the deciding factor is how your application is hosted:</span></span>  
  
- <span data-ttu-id="81039-155">如果使用 Internet Information Services (IIS) 作为 WCF 主机，请使用 IIS 基础结构来设置 SSL 服务。</span><span class="sxs-lookup"><span data-stu-id="81039-155">If you are using Internet Information Services (IIS) as your WCF host, use the IIS infrastructure to set up an SSL service.</span></span>  
  
- <span data-ttu-id="81039-156">如果要创建自承载的 WCF 应用程序，可以使用 HttpCfg.exe 工具将 SSL 证书绑定到该地址。</span><span class="sxs-lookup"><span data-stu-id="81039-156">If you are creating a self-hosted WCF application, you can bind an SSL certificate to the address using the HttpCfg.exe tool.</span></span>  
  
### <a name="using-iis-for-transport-security"></a><span data-ttu-id="81039-157">使用 IIS 实现传输安全</span><span class="sxs-lookup"><span data-stu-id="81039-157">Using IIS for Transport Security</span></span>  
  
#### <a name="iis-70"></a><span data-ttu-id="81039-158">IIS 7.0</span><span class="sxs-lookup"><span data-stu-id="81039-158">IIS 7.0</span></span>  

 <span data-ttu-id="81039-159">若要将 IIS 7.0 设置为使用 SSL) 的安全主机 (，请参阅 [在 IIS 7.0 中配置安全套接字层](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc771438(v=ws.10))。</span><span class="sxs-lookup"><span data-stu-id="81039-159">To set up IIS 7.0 as a secure host (using SSL), see [Configuring Secure Sockets Layer in IIS 7.0](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc771438(v=ws.10)).</span></span>  
  
<span data-ttu-id="81039-160">若要配置用于 IIS 7.0 的证书，请参阅 [在 iis 7.0 中配置服务器证书](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732230(v=ws.10))。</span><span class="sxs-lookup"><span data-stu-id="81039-160">To configure certificates for use with IIS 7.0, see [Configuring Server Certificates in IIS 7.0](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732230(v=ws.10)).</span></span>  
  
#### <a name="iis-60"></a><span data-ttu-id="81039-161">IIS 6.0</span><span class="sxs-lookup"><span data-stu-id="81039-161">IIS 6.0</span></span>  

 <span data-ttu-id="81039-162">若要将 IIS 6.0 设置为使用 SSL) 的安全主机 (，请参阅 [配置安全套接字层](/previous-versions/windows/it-pro/windows-server-2003/cc736992(v=ws.10))。</span><span class="sxs-lookup"><span data-stu-id="81039-162">To set up IIS 6.0 as a secure host (using SSL), see [Configuring Secure Sockets Layer](/previous-versions/windows/it-pro/windows-server-2003/cc736992(v=ws.10)).</span></span>  
  
 <span data-ttu-id="81039-163">若要配置用于 IIS 6.0 的证书，请参阅 [Certificates_IIS_SP1_Ops](/previous-versions/windows/it-pro/windows-server-2003/cc757474(v=ws.10))。</span><span class="sxs-lookup"><span data-stu-id="81039-163">To configure certificates for use with IIS 6.0, see [Certificates_IIS_SP1_Ops](/previous-versions/windows/it-pro/windows-server-2003/cc757474(v=ws.10)).</span></span>  
  
### <a name="using-httpcfg-for-ssl"></a><span data-ttu-id="81039-164">将 HttpCfg 用于 SSL</span><span class="sxs-lookup"><span data-stu-id="81039-164">Using HttpCfg for SSL</span></span>  

 <span data-ttu-id="81039-165">如果要创建自承载的 WCF 应用程序，请使用 [HttpCfg.exe](/windows/win32/http/httpcfg-exe) 工具。</span><span class="sxs-lookup"><span data-stu-id="81039-165">If you're creating a self-hosted WCF application, use the [HttpCfg.exe](/windows/win32/http/httpcfg-exe) tool.</span></span>
  
 <span data-ttu-id="81039-166">有关使用 HttpCfg.exe 工具设置 x.509 证书的端口的详细信息，请参阅 [如何：使用 SSL 证书配置端口](how-to-configure-a-port-with-an-ssl-certificate.md)。</span><span class="sxs-lookup"><span data-stu-id="81039-166">For more information about using the HttpCfg.exe tool to set up a port with an X.509 certificate, see [How to: Configure a Port with an SSL Certificate](how-to-configure-a-port-with-an-ssl-certificate.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="81039-167">请参阅</span><span class="sxs-lookup"><span data-stu-id="81039-167">See also</span></span>

- [<span data-ttu-id="81039-168">传输安全</span><span class="sxs-lookup"><span data-stu-id="81039-168">Transport Security</span></span>](transport-security.md)
- [<span data-ttu-id="81039-169">消息安全</span><span class="sxs-lookup"><span data-stu-id="81039-169">Message Security</span></span>](message-security-in-wcf.md)
