---
title: 构建基于微服务的容器化应用程序
description: 构建基于微服务的容器化应用程序并不简单，不应掉以轻心。 了解本章的核心概念。
ms.date: 01/13/2021
ms.openlocfilehash: b31c560fefa0928cefef2fdb92d6cfdbac084c57
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/23/2021
ms.locfileid: "104873141"
---
# <a name="architecting-container-and-microservice-based-applications"></a><span data-ttu-id="0e0fe-104">构建基于微服务的容器化应用程序</span><span class="sxs-lookup"><span data-stu-id="0e0fe-104">Architecting container and microservice-based applications</span></span>

<span data-ttu-id="0e0fe-105">微服务提供很多优点，但也会引起新的巨大挑战。创建基于微服务的应用程序时，微服务体系结构模式是基础支柱。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-105">*Microservices offer great benefits but also raise huge new challenges. Microservice architecture patterns are fundamental pillars when creating a microservice-based application.*</span></span>

<span data-ttu-id="0e0fe-106">本指南前面部分介绍了有关容器和 Docker 的基本概念。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-106">Earlier in this guide, you learned basic concepts about containers and Docker.</span></span> <span data-ttu-id="0e0fe-107">要开始使用容器，至少要了解这些基本信息。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-107">That information was the minimum you needed to get started with containers.</span></span> <span data-ttu-id="0e0fe-108">虽然容器是微服务运行的基础，并且非常适合用于微服务，但它们并非是微服务体系结构所必需的。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-108">Even though containers are enablers of, and a great fit for microservices, they aren't mandatory for a microservice architecture.</span></span> <span data-ttu-id="0e0fe-109">此体系结构部分中的许多体系结构概念都适用于没有容器的情况。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-109">Many architectural concepts in this architecture section could be applied without containers.</span></span> <span data-ttu-id="0e0fe-110">然而，由于已介绍容器的重要性，本指南将重点介绍两者交叉部分。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-110">However, this guide focuses on the intersection of both due to the already introduced importance of containers.</span></span>

<span data-ttu-id="0e0fe-111">企业应用程序可能会很复杂，它们通常由多个服务组成，而不是基于单个服务的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-111">Enterprise applications can be complex and are often composed of multiple services instead of a single service-based application.</span></span> <span data-ttu-id="0e0fe-112">对于这些情况，需要了解其他体系结构方法，如微服务和某些域驱动设计 (DDD) 模式以及容器业务流程的概念。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-112">For those cases, you need to understand other architectural approaches, such as the microservices and certain Domain-Driven Design (DDD) patterns plus container orchestration concepts.</span></span> <span data-ttu-id="0e0fe-113">请注意，本章节不仅介绍容器上的微服务，还介绍任何容器化应用程序。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-113">Note that this chapter describes not just microservices on containers, but any containerized application, as well.</span></span>

## <a name="container-design-principles"></a><span data-ttu-id="0e0fe-114">容器设计原则</span><span class="sxs-lookup"><span data-stu-id="0e0fe-114">Container design principles</span></span>

<span data-ttu-id="0e0fe-115">在容器模型中，容器映像实例表示单个进程。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-115">In the container model, a container image instance represents a single process.</span></span> <span data-ttu-id="0e0fe-116">将容器映像定义为进程边界，可以创建可用于对进程进行缩放或批处理的基元。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-116">By defining a container image as a process boundary, you can create primitives that can be used to scale or batch the process.</span></span>

<span data-ttu-id="0e0fe-117">设计容器映像时，可在 Dockerfile 中看到[入口点](https://docs.docker.com/engine/reference/builder/#entrypoint)定义。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-117">When you design a container image, you'll see an [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) definition in the Dockerfile.</span></span> <span data-ttu-id="0e0fe-118">此定义定义了一个进程，其生命周期控制容器的生命周期。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-118">This definition defines the process whose lifetime controls the lifetime of the container.</span></span> <span data-ttu-id="0e0fe-119">该进程完成，则容器的生命周期结束。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-119">When the process completes, the container lifecycle ends.</span></span> <span data-ttu-id="0e0fe-120">容器可以表示 Web 服务器等长时间运行的进程，但也可表示批处理作业等生存期较短的进程，这些进程以前可能已实现为 Azure [WebJobs](https://github.com/Azure/azure-webjobs-sdk/wiki)。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-120">Containers might represent long-running processes like web servers, but can also represent short-lived processes like batch jobs, which formerly might have been implemented as Azure [WebJobs](https://github.com/Azure/azure-webjobs-sdk/wiki).</span></span>

<span data-ttu-id="0e0fe-121">如果进程失败，则容器结束，Orchestrator 接管。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-121">If the process fails, the container ends, and the orchestrator takes over.</span></span> <span data-ttu-id="0e0fe-122">如果 Orchestrator 已配置为使五个实例保持运行，而其中一个实例失败，则 Orchestrator 会创建另一个容器实例，来替换失败的进程。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-122">If the orchestrator was configured to keep five instances running and one fails, the orchestrator will create another container instance to replace the failed process.</span></span> <span data-ttu-id="0e0fe-123">在批处理作业中，使用参数启动该进程。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-123">In a batch job, the process is started with parameters.</span></span> <span data-ttu-id="0e0fe-124">进程完成，则工作完成。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-124">When the process completes, the work is complete.</span></span> <span data-ttu-id="0e0fe-125">本指南接下来将深入介绍业务流程协调程序。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-125">This guidance drills-down on orchestrators, later on.</span></span>

<span data-ttu-id="0e0fe-126">某些情况下，可能需要在单个容器中运行多个进程。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-126">You might find a scenario where you want multiple processes running in a single container.</span></span> <span data-ttu-id="0e0fe-127">对于这种情况，因为每个容器只有一个入口点，所以在可根据需要启动任意数目的程序的容器中运行脚本。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-127">For that scenario, since there can be only one entry point per container, you could run a script within the container that launches as many programs as needed.</span></span> <span data-ttu-id="0e0fe-128">例如，可以使用 [Supervisor](http://supervisord.org/) 或类似的工具处理在单个容器内启动多个进程的情况。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-128">For example, you can use [Supervisor](http://supervisord.org/) or a similar tool to take care of launching multiple processes inside a single container.</span></span> <span data-ttu-id="0e0fe-129">尽管可以找到用于在每个容器中承载多个进程的体系结构，但这种方法并不常见。</span><span class="sxs-lookup"><span data-stu-id="0e0fe-129">However, even though you can find architectures that hold multiple processes per container, that approach isn't very common.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0e0fe-130">[上一页](../net-core-net-framework-containers/official-net-docker-images.md)
>[下一页](containerize-monolithic-applications.md)</span><span class="sxs-lookup"><span data-stu-id="0e0fe-130">[Previous](../net-core-net-framework-containers/official-net-docker-images.md)
[Next](containerize-monolithic-applications.md)</span></span>
