---
title: .NET Core 自包含应用部署的运行时前滚。
description: 了解自包含部署的 dotnet publish 更改。
author: KathleenDollard
ms.date: 05/31/2018
ms.openlocfilehash: 6bc578c63b28f51f1dd98e3e7e56fbe2c7a3e7cf
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505903"
---
# <a name="self-contained-deployment-runtime-roll-forward"></a><span data-ttu-id="7ee28-103">自包含部署运行时前滚</span><span class="sxs-lookup"><span data-stu-id="7ee28-103">Self-contained deployment runtime roll forward</span></span>

<span data-ttu-id="7ee28-104">.NET Core [自包含应用程序部署](index.md)包括 .NET Core 库和 .NET Core 运行时。</span><span class="sxs-lookup"><span data-stu-id="7ee28-104">.NET Core [self-contained application deployments](index.md) include both the .NET Core libraries and the .NET Core runtime.</span></span> <span data-ttu-id="7ee28-105">从 .NET Core 2.1 SDK（版本 2.1.300）开始，自包含应用程序部署[在计算机上发布最高版本的修补程序运行时](https://github.com/dotnet/designs/blob/main/accepted/2018/self-contained-roll-forward.md)。</span><span class="sxs-lookup"><span data-stu-id="7ee28-105">Starting in .NET Core 2.1 SDK (version 2.1.300), a self-contained application deployment [publishes the highest patch runtime on your machine](https://github.com/dotnet/designs/blob/main/accepted/2018/self-contained-roll-forward.md).</span></span> <span data-ttu-id="7ee28-106">默认情况下，自包含部署的 [`dotnet publish`](../tools/dotnet-publish.md) 选择作为发布计算机上 SDK 一部分而安装的最新版本。</span><span class="sxs-lookup"><span data-stu-id="7ee28-106">By default, [`dotnet publish`](../tools/dotnet-publish.md) for a self-contained deployment selects the latest version installed as part of the SDK on the publishing machine.</span></span> <span data-ttu-id="7ee28-107">这让部署的应用程序在 `publish` 期间能与安全修补程序（以及其他修补程序）配合运行。</span><span class="sxs-lookup"><span data-stu-id="7ee28-107">This enables your deployed application to run with security fixes (and other fixes) available during `publish`.</span></span> <span data-ttu-id="7ee28-108">若要获取新的修补程序，需要重新发布应用程序。</span><span class="sxs-lookup"><span data-stu-id="7ee28-108">The application must be republished to obtain a new patch.</span></span> <span data-ttu-id="7ee28-109">自包含应用程序是通过在 `dotnet publish` 命令上指定 `-r <RID>` 创建的，或是通过在项目文件 (csproj / vbproj) 或命令行中指定[运行时标识符 (RID)](../rid-catalog.md) 创建的。</span><span class="sxs-lookup"><span data-stu-id="7ee28-109">Self-contained applications are created by specifying `-r <RID>` on the `dotnet publish` command or by specifying the [runtime identifier (RID)](../rid-catalog.md) in the project file (csproj / vbproj) or on the command line.</span></span>

## <a name="patch-version-roll-forward-overview"></a><span data-ttu-id="7ee28-110">修补程序版本前滚概述</span><span class="sxs-lookup"><span data-stu-id="7ee28-110">Patch version roll forward overview</span></span>

<span data-ttu-id="7ee28-111">[`restore`](../tools/dotnet-restore.md)、[`build`](../tools/dotnet-build.md) 和 [`publish`](../tools/dotnet-publish.md) 是可以单独运行的 `dotnet` 命令。</span><span class="sxs-lookup"><span data-stu-id="7ee28-111">[`restore`](../tools/dotnet-restore.md), [`build`](../tools/dotnet-build.md) and [`publish`](../tools/dotnet-publish.md) are `dotnet` commands that can run separately.</span></span> <span data-ttu-id="7ee28-112">运行时选择属于 `restore` 操作，而不是 `publish` 或 `build` 操作。</span><span class="sxs-lookup"><span data-stu-id="7ee28-112">The runtime choice is part of the `restore` operation, not `publish` or `build`.</span></span> <span data-ttu-id="7ee28-113">如果调用 `publish`，则会选择最新的修补程序版本。</span><span class="sxs-lookup"><span data-stu-id="7ee28-113">If you call `publish`, the latest patch version will be chosen.</span></span> <span data-ttu-id="7ee28-114">如果调用带有 `--no-restore` 参数的 `publish`，则可能不会获取所需的修补程序版本，因为没有先使用新的自包含应用程序发布策略执行 `restore`。</span><span class="sxs-lookup"><span data-stu-id="7ee28-114">If you call `publish` with the `--no-restore` argument, then you may not get the desired patch version because a prior `restore` may not have been executed with the new self-contained application publishing policy.</span></span> <span data-ttu-id="7ee28-115">在这种情况下，会出现生成错误，并显示以下类似文本：</span><span class="sxs-lookup"><span data-stu-id="7ee28-115">In this case, a build error is generated with text similar to the following:</span></span>

  <span data-ttu-id="7ee28-116">“已使用 Microsoft.NETCore.App 版本 2.0.0 还原该项目，但是按照当前设置，将改为使用版本 2.0.6。</span><span class="sxs-lookup"><span data-stu-id="7ee28-116">"The project was restored using Microsoft.NETCore.App version 2.0.0, but with current settings, version 2.0.6 would be used instead.</span></span> <span data-ttu-id="7ee28-117">若要解决此问题，请确保将相同的设置用于 restore 和后续操作，例如 build 或 publish。</span><span class="sxs-lookup"><span data-stu-id="7ee28-117">To resolve this issue, make sure the same settings are used for restore and for subsequent operations such as build or publish.</span></span> <span data-ttu-id="7ee28-118">如果在 build 或 publish 期间设置了 RuntimeIdentifier 属性，而没有在 restore 过程中设置，通常就会出现此问题。”</span><span class="sxs-lookup"><span data-stu-id="7ee28-118">Typically this issue can occur if the RuntimeIdentifier property is set during build or publish but not during restore."</span></span>

> [!NOTE]
> <span data-ttu-id="7ee28-119">`restore` 和 `build` 可以作为另一个命令（例如 `publish`）的组成部分隐式运行。</span><span class="sxs-lookup"><span data-stu-id="7ee28-119">`restore` and `build` can be run implicitly as part of another command, like `publish`.</span></span> <span data-ttu-id="7ee28-120">当作为另一个命令的组成部分隐式运行时，它们会带有附加的上下文，以便生成正确的项目。</span><span class="sxs-lookup"><span data-stu-id="7ee28-120">When run implicitly as part of another command, they are provided with additional context so that the right artifacts are produced.</span></span> <span data-ttu-id="7ee28-121">如果使用某个运行时（例如 `dotnet publish -r linux-x64`）执行 `publish`，隐式的 `restore` 会还原 linux-x64 运行时的包。</span><span class="sxs-lookup"><span data-stu-id="7ee28-121">When you `publish` with a runtime (for example, `dotnet publish -r linux-x64`), the implicit `restore` restores packages for the linux-x64 runtime.</span></span> <span data-ttu-id="7ee28-122">如果显示调用 `restore`，则默认情况下它不会还原运行时包，因为没有上下文。</span><span class="sxs-lookup"><span data-stu-id="7ee28-122">If you call `restore` explicitly, it does not restore runtime packages by default, because it doesn't have that context.</span></span>

## <a name="how-to-avoid-restore-during-publish"></a><span data-ttu-id="7ee28-123">如何避免在 publish 过程中 restore</span><span class="sxs-lookup"><span data-stu-id="7ee28-123">How to avoid restore during publish</span></span>

<span data-ttu-id="7ee28-124">你可能在进行 `publish` 操作时不需要运行 `restore`。</span><span class="sxs-lookup"><span data-stu-id="7ee28-124">Running `restore` as part of the `publish` operation may be undesirable for your scenario.</span></span> <span data-ttu-id="7ee28-125">在创建自包含应用程序时，若要避免在 `publish` 过程中进行 `restore`，请执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="7ee28-125">To avoid `restore` during `publish` while creating self-contained applications, do the following:</span></span>

- <span data-ttu-id="7ee28-126">将 `RuntimeIdentifiers` 属性设为一个分号分隔的列表，其中包含所有要发布的 [RID](../rid-catalog.md)。</span><span class="sxs-lookup"><span data-stu-id="7ee28-126">Set the `RuntimeIdentifiers` property to a semicolon-separated list of all the [RIDs](../rid-catalog.md) to be published.</span></span>
- <span data-ttu-id="7ee28-127">将 `TargetLatestRuntimePatch` 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="7ee28-127">Set the `TargetLatestRuntimePatch` property to `true`.</span></span>

## <a name="no-restore-argument-with-dotnet-publish-options"></a><span data-ttu-id="7ee28-128">使用 dotnet publish 选项的 no-restore 参数</span><span class="sxs-lookup"><span data-stu-id="7ee28-128">No-restore argument with dotnet publish options</span></span>

<span data-ttu-id="7ee28-129">如果要使用同样的项目文件创建自包含应用程序和[依赖框架的应用程序](index.md)，并且想通过 `dotnet publish` 使用 `--no-restore` 参数，请选择以下各项之一：</span><span class="sxs-lookup"><span data-stu-id="7ee28-129">If you want to create both self-contained applications and [framework-dependent applications](index.md) with the same project file, and you want to use the `--no-restore` argument with `dotnet publish`, then choose one of the following:</span></span>

1. <span data-ttu-id="7ee28-130">首选依赖框架的行为。</span><span class="sxs-lookup"><span data-stu-id="7ee28-130">Prefer the framework-dependent behavior.</span></span> <span data-ttu-id="7ee28-131">如果是依赖框架的应用程序，则此选项为默认行为。</span><span class="sxs-lookup"><span data-stu-id="7ee28-131">If the application is framework-dependent, this is the default behavior.</span></span> <span data-ttu-id="7ee28-132">如果是自包含应用程序，并且能使用未带修补程序的 2.1.0 本地运行时，请在项目文件中将 `TargetLatestRuntimePatch` 设为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7ee28-132">If the application is self-contained, and can use an unpatched 2.1.0 local runtime, set the `TargetLatestRuntimePatch` to `false` in the project file.</span></span>

2. <span data-ttu-id="7ee28-133">首选自包含行为。</span><span class="sxs-lookup"><span data-stu-id="7ee28-133">Prefer the self-contained behavior.</span></span> <span data-ttu-id="7ee28-134">如果是自包含应用程序，则此选项为默认行为。</span><span class="sxs-lookup"><span data-stu-id="7ee28-134">If the application is self-contained, this is the default behavior.</span></span> <span data-ttu-id="7ee28-135">如果是依赖框架的应用程序，且需要安装最新版本的修补程序，请在项目文件中将 `TargetLatestRuntimePatch` 设为 `true`。</span><span class="sxs-lookup"><span data-stu-id="7ee28-135">If the application is framework-dependent, and requires the latest patch installed, set `TargetLatestRuntimePatch` to `true` in the project file.</span></span>

3. <span data-ttu-id="7ee28-136">通过在项目文件中将 `RuntimeFrameworkVersion` 设为特定的修补程序版本，可对运行时框架版本进行显式控制。</span><span class="sxs-lookup"><span data-stu-id="7ee28-136">Take explicit control of the runtime framework version by setting `RuntimeFrameworkVersion` to the specific patch version in the project file.</span></span>
