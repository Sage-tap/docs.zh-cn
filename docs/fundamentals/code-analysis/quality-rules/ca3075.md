---
title: 'CA3075：不安全的 DTD 处理 (代码分析) '
description: 了解代码分析规则 CA3075：不安全的 DTD 处理
ms.date: 03/18/2019
ms.topic: reference
author: gewarren
ms.author: gewarren
ms.openlocfilehash: d58619ad8583a7329cd799bb3f52583d79ebb4cc
ms.sourcegitcommit: 4df8e005c074ceb1f978f007b222fe253be2baf3
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/04/2021
ms.locfileid: "99542508"
---
# <a name="ca3075-insecure-dtd-processing"></a><span data-ttu-id="0f6c2-103">CA3075:不安全的 DTD 处理</span><span class="sxs-lookup"><span data-stu-id="0f6c2-103">CA3075: Insecure DTD Processing</span></span>

| | <span data-ttu-id="0f6c2-104">值</span><span class="sxs-lookup"><span data-stu-id="0f6c2-104">Value</span></span> |
|-|-|
| <span data-ttu-id="0f6c2-105">**规则 ID**</span><span class="sxs-lookup"><span data-stu-id="0f6c2-105">**Rule ID**</span></span> |<span data-ttu-id="0f6c2-106">CA3075</span><span class="sxs-lookup"><span data-stu-id="0f6c2-106">CA3075</span></span>|
| <span data-ttu-id="0f6c2-107">**类别**</span><span class="sxs-lookup"><span data-stu-id="0f6c2-107">**Category**</span></span> |[<span data-ttu-id="0f6c2-108">Microsoft.Security</span><span class="sxs-lookup"><span data-stu-id="0f6c2-108">Microsoft.Security</span></span>](security-warnings.md)|
| <span data-ttu-id="0f6c2-109">**修复是中断或非中断**</span><span class="sxs-lookup"><span data-stu-id="0f6c2-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="0f6c2-110">不间断</span><span class="sxs-lookup"><span data-stu-id="0f6c2-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="0f6c2-111">原因</span><span class="sxs-lookup"><span data-stu-id="0f6c2-111">Cause</span></span>

<span data-ttu-id="0f6c2-112">如果使用不安全的 <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 实例或引用外部实体源，分析器可能会接受不受信任的输入并将敏感信息泄露给攻击者。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-112">If you use insecure <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.</span></span>

## <a name="rule-description"></a><span data-ttu-id="0f6c2-113">规则说明</span><span class="sxs-lookup"><span data-stu-id="0f6c2-113">Rule description</span></span>

<span data-ttu-id="0f6c2-114">XML 分析器可以通过两种方式确定文档有效性， *文档类型定义 (DTD)* 是其中一种（根据  [万维网联合会 (W3C) 可扩展标记语言 (XML) 1.0](https://www.w3.org/TR/2008/REC-xml-20081126/)的定义）。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-114">A *Document Type Definition (DTD)* is one of two ways an XML parser can determine the validity of a document, as defined by the  [World Wide Web Consortium (W3C) Extensible Markup Language (XML) 1.0](https://www.w3.org/TR/2008/REC-xml-20081126/).</span></span> <span data-ttu-id="0f6c2-115">此规则查找接受不受信任数据的属性和实例，警告开发人员潜在的 [信息泄漏](../../../framework/wcf/feature-details/information-disclosure.md) 威胁或 [拒绝服务 (DoS) ](../../../framework/wcf/feature-details/denial-of-service.md) 攻击。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-115">This rule seeks properties and instances where untrusted data is accepted to warn developers about potential [Information Disclosure](../../../framework/wcf/feature-details/information-disclosure.md) threats or [Denial of Service (DoS)](../../../framework/wcf/feature-details/denial-of-service.md) attacks.</span></span> <span data-ttu-id="0f6c2-116">在以下情况下触发此规则：</span><span class="sxs-lookup"><span data-stu-id="0f6c2-116">This rule triggers when:</span></span>

- <span data-ttu-id="0f6c2-117">在 <xref:System.Xml.XmlReader> 实例上启用了 DtdProcessing，它使用 <xref:System.Xml.XmlUrlResolver>解析外部 XML 实体。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-117">DtdProcessing is enabled on the <xref:System.Xml.XmlReader> instance, which resolves external XML entities using <xref:System.Xml.XmlUrlResolver>.</span></span>

- <span data-ttu-id="0f6c2-118">设置了 XML 中的 <xref:System.Xml.XmlNode.InnerXml%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-118">The <xref:System.Xml.XmlNode.InnerXml%2A> property in the XML is set.</span></span>

- <span data-ttu-id="0f6c2-119"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 属性设置为 Parse。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-119"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> property is set to Parse.</span></span>

- <span data-ttu-id="0f6c2-120">使用而不是处理不受信任的输入 <xref:System.Xml.XmlResolver> <xref:System.Xml.XmlSecureResolver> 。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-120">Untrusted input is processed using <xref:System.Xml.XmlResolver> instead of <xref:System.Xml.XmlSecureResolver>.</span></span>

- <span data-ttu-id="0f6c2-121"><xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>使用不安全的 <xref:System.Xml.XmlReaderSettings> 实例或根本不使用任何实例调用方法。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-121">The <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> method is invoked with an insecure <xref:System.Xml.XmlReaderSettings> instance or no instance at all.</span></span>

- <span data-ttu-id="0f6c2-122"><xref:System.Xml.XmlReader> 是用不安全的默认设置或值创建的。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-122"><xref:System.Xml.XmlReader> is created with insecure default settings or values.</span></span>

<span data-ttu-id="0f6c2-123">在上述每种情况下，结果均相同：来自文件系统或来自处理 XML 的计算机的网络共享的内容将公开给攻击者，或者 DTD 处理可以用作 DoS 向量。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-123">In each of these cases, the outcome is the same: the contents from either the file system or network shares from the machine where the XML is processed will be exposed to the attacker, or DTD processing can be used as a DoS vector.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="0f6c2-124">如何解决冲突</span><span class="sxs-lookup"><span data-stu-id="0f6c2-124">How to fix violations</span></span>

- <span data-ttu-id="0f6c2-125">正确捕获并处理所有 XmlTextReader 异常，以避免路径信息泄漏。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-125">Catch and process all XmlTextReader exceptions properly to avoid path information disclosure.</span></span>

- <span data-ttu-id="0f6c2-126">使用 <xref:System.Xml.XmlSecureResolver> 来限制 XmlTextReader 可以访问的资源。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-126">Use the <xref:System.Xml.XmlSecureResolver> to restrict the resources that the XmlTextReader can access.</span></span>

- <span data-ttu-id="0f6c2-127">通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlResolver> null **，不允许** 打开任何外部资源。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-127">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlResolver> property to **null**.</span></span>

- <span data-ttu-id="0f6c2-128">确保 <xref:System.Data.DataViewManager.DataViewSettingCollectionString%2A?displayProperty=nameWithType> 从受信任的源中分配了该属性。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-128">Ensure that the <xref:System.Data.DataViewManager.DataViewSettingCollectionString%2A?displayProperty=nameWithType> property is assigned from a trusted source.</span></span>

### <a name="net-framework-35-and-earlier"></a><span data-ttu-id="0f6c2-129">.NET Framework 3.5 及更早版本</span><span class="sxs-lookup"><span data-stu-id="0f6c2-129">.NET Framework 3.5 and earlier</span></span>

- <span data-ttu-id="0f6c2-130">如果要处理不受信任的源，请将属性设置 <xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A> 为 **true**，以禁用 DTD 处理。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-130">Disable DTD processing if you are dealing with untrusted sources by setting the <xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A> property to **true**.</span></span>

- <span data-ttu-id="0f6c2-131">XmlTextReader 类具有完全信任继承要求。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-131">XmlTextReader class has a full trust inheritance demand.</span></span>

### <a name="net-framework-4-and-later"></a><span data-ttu-id="0f6c2-132">.NET Framework 4 及更高版本</span><span class="sxs-lookup"><span data-stu-id="0f6c2-132">.NET Framework 4 and later</span></span>

- <span data-ttu-id="0f6c2-133">如果要处理不受信任的源，请将属性设置 <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> 为 **禁止** 或 **忽略**，以避免启用 DtdProcessing。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-133">Avoid enabling DtdProcessing if you're dealing with untrusted sources by setting the <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> property to **Prohibit** or **Ignore**.</span></span>

- <span data-ttu-id="0f6c2-134">确保在所有 InnerXml 用例中 load () 方法均采用 XmlReader 实例。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-134">Ensure that the Load() method takes an XmlReader instance in all InnerXml cases.</span></span>

> [!NOTE]
> <span data-ttu-id="0f6c2-135">此规则可能会针对某些有效 XmlSecureResolver 实例进行误报。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-135">This rule might report false positives on some valid XmlSecureResolver instances.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="0f6c2-136">何时禁止显示警告</span><span class="sxs-lookup"><span data-stu-id="0f6c2-136">When to suppress warnings</span></span>

<span data-ttu-id="0f6c2-137">除非确信已知道输入是来自受信任的源，否则请勿禁止显示此警告的规则。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-137">Unless you're sure that the input is known to be from a trusted source, do not suppress a rule from this warning.</span></span>

## <a name="pseudo-code-examples"></a><span data-ttu-id="0f6c2-138">伪代码示例</span><span class="sxs-lookup"><span data-stu-id="0f6c2-138">Pseudo-code examples</span></span>

### <a name="violation-1"></a><span data-ttu-id="0f6c2-139">冲突1</span><span class="sxs-lookup"><span data-stu-id="0f6c2-139">Violation 1</span></span>

```csharp
using System.IO;
using System.Xml.Schema;

class TestClass
{
    public XmlSchema Test
    {
        get
        {
            var src = "";
            TextReader tr = new StreamReader(src);
            XmlSchema schema = XmlSchema.Read(tr, null); // warn
            return schema;
        }
    }
}
```

### <a name="solution-1"></a><span data-ttu-id="0f6c2-140">解决方案 1</span><span class="sxs-lookup"><span data-stu-id="0f6c2-140">Solution 1</span></span>

```csharp
using System.IO;
using System.Xml;
using System.Xml.Schema;

class TestClass
{
    public XmlSchema Test
    {
        get
        {
            var src = "";
            TextReader tr = new StreamReader(src);
            XmlReader reader = XmlReader.Create(tr, new XmlReaderSettings() { XmlResolver = null });
            XmlSchema schema = XmlSchema.Read(reader , null);
            return schema;
        }
    }
}
```

### <a name="violation-2"></a><span data-ttu-id="0f6c2-141">冲突2</span><span class="sxs-lookup"><span data-stu-id="0f6c2-141">Violation 2</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public XmlReaderSettings settings = new XmlReaderSettings();
        public void TestMethod(string path)
        {
            var reader = XmlReader.Create(path, settings);  // warn
        }
    }
}
```

### <a name="solution-2"></a><span data-ttu-id="0f6c2-142">解决方案 2</span><span class="sxs-lookup"><span data-stu-id="0f6c2-142">Solution 2</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public XmlReaderSettings settings = new XmlReaderSettings()
        {
            DtdProcessing = DtdProcessing.Prohibit
        };

        public void TestMethod(string path)
        {
            var reader = XmlReader.Create(path, settings);
        }
    }
}
```

### <a name="violation-3"></a><span data-ttu-id="0f6c2-143">冲突3</span><span class="sxs-lookup"><span data-stu-id="0f6c2-143">Violation 3</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class DoNotUseSetInnerXml
    {
        public void TestMethod(string xml)
        {
            XmlDocument doc = new XmlDocument() { XmlResolver = null };
            doc.InnerXml = xml; // warn
        }
    }
}
```

```csharp
using System.Xml;

namespace TestNamespace
{
    public class DoNotUseLoadXml
    {
        public void TestMethod(string xml)
        {
            XmlDocument doc = new XmlDocument(){ XmlResolver = null };
            doc.LoadXml(xml); // warn
        }
    }
}
```

### <a name="solution-3"></a><span data-ttu-id="0f6c2-144">解决方法 3</span><span class="sxs-lookup"><span data-stu-id="0f6c2-144">Solution 3</span></span>

```csharp
using System.Xml;

public static void TestMethod(string xml)
{
    XmlDocument doc = new XmlDocument() { XmlResolver = null };
    System.IO.StringReader sreader = new System.IO.StringReader(xml);
    XmlReader reader = XmlReader.Create(sreader, new XmlReaderSettings() { XmlResolver = null });
    doc.Load(reader);
}
```

### <a name="violation-4"></a><span data-ttu-id="0f6c2-145">冲突4</span><span class="sxs-lookup"><span data-stu-id="0f6c2-145">Violation 4</span></span>

```csharp
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace TestNamespace
{
    public class UseXmlReaderForDeserialize
    {
        public void TestMethod(Stream stream)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(UseXmlReaderForDeserialize));
            serializer.Deserialize(stream); // warn
        }
    }
}
```

### <a name="solution-4"></a><span data-ttu-id="0f6c2-146">解决方法 4</span><span class="sxs-lookup"><span data-stu-id="0f6c2-146">Solution 4</span></span>

```csharp
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace TestNamespace
{
    public class UseXmlReaderForDeserialize
    {
        public void TestMethod(Stream stream)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(UseXmlReaderForDeserialize));
            XmlReader reader = XmlReader.Create(stream, new XmlReaderSettings() { XmlResolver = null });
            serializer.Deserialize(reader );
        }
    }
}
```

### <a name="violation-5"></a><span data-ttu-id="0f6c2-147">冲突5</span><span class="sxs-lookup"><span data-stu-id="0f6c2-147">Violation 5</span></span>

```csharp
using System.Xml;
using System.Xml.XPath;

namespace TestNamespace
{
    public class UseXmlReaderForXPathDocument
    {
        public void TestMethod(string path)
        {
            XPathDocument doc = new XPathDocument(path); // warn
        }
    }
}
```

### <a name="solution-5"></a><span data-ttu-id="0f6c2-148">解决方案5</span><span class="sxs-lookup"><span data-stu-id="0f6c2-148">Solution 5</span></span>

```csharp
using System.Xml;
using System.Xml.XPath;

namespace TestNamespace
{
    public class UseXmlReaderForXPathDocument
    {
        public void TestMethod(string path)
        {
            XmlReader reader = XmlReader.Create(path, new XmlReaderSettings() { XmlResolver = null });
            XPathDocument doc = new XPathDocument(reader);
        }
    }
}
```

### <a name="violation-6"></a><span data-ttu-id="0f6c2-149">冲突6</span><span class="sxs-lookup"><span data-stu-id="0f6c2-149">Violation 6</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    class TestClass
    {
        public XmlDocument doc = new XmlDocument() { XmlResolver = new XmlUrlResolver() };
    }
}
```

### <a name="solution-6"></a><span data-ttu-id="0f6c2-150">解决方案6</span><span class="sxs-lookup"><span data-stu-id="0f6c2-150">Solution 6</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    class TestClass
    {
        public XmlDocument doc = new XmlDocument() { XmlResolver = null }; // or set to a XmlSecureResolver instance
    }
}
```

### <a name="violation-7"></a><span data-ttu-id="0f6c2-151">冲突7</span><span class="sxs-lookup"><span data-stu-id="0f6c2-151">Violation 7</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    class TestClass
    {
        private static void TestMethod()
        {
            var reader = XmlTextReader.Create(""doc.xml""); //warn
        }
    }
}
```

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public void TestMethod(string path)
        {
            try {
                XmlTextReader reader = new XmlTextReader(path); // warn
            }
            catch { throw ; }
            finally {}
        }
    }
}
```

### <a name="solution-7"></a><span data-ttu-id="0f6c2-152">解决方案7</span><span class="sxs-lookup"><span data-stu-id="0f6c2-152">Solution 7</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public void TestMethod(string path)
        {
            XmlReaderSettings settings = new XmlReaderSettings() { XmlResolver = null };
            XmlReader reader = XmlReader.Create(path, settings);
        }
    }
}
```

> [!NOTE]
> <span data-ttu-id="0f6c2-153">尽管 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 是创建实例的建议方法 <xref:System.Xml.XmlReader> ，但与之间存在行为差异 <xref:System.Xml.XmlTextReader> 。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-153">Although <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> is the recommended way to create an <xref:System.Xml.XmlReader> instance, there are behavior differences from <xref:System.Xml.XmlTextReader>.</span></span> <span data-ttu-id="0f6c2-154"><xref:System.Xml.XmlReader>从 <xref:System.Xml.XmlReader.Create%2A> 规范化 `\r\n` 到 `\n` XML 值的，同时 <xref:System.Xml.XmlTextReader> 保留 `\r\n` 序列。</span><span class="sxs-lookup"><span data-stu-id="0f6c2-154">An <xref:System.Xml.XmlReader> from <xref:System.Xml.XmlReader.Create%2A> normalizes `\r\n` to `\n` in XML values, while <xref:System.Xml.XmlTextReader> preserves the `\r\n` sequence.</span></span>
