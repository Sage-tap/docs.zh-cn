---
title: 为什么使用新式桌面应用程序
description: 了解现下的 Windows 窗体、WPF 和 UWP 等桌面技术。
ms.date: 12/29/2020
ms.openlocfilehash: 8489e41c973bb472a23bca38e9374c36e4cdd366
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "98615888"
---
# <a name="why-modern-desktop-applications"></a>为什么使用新式桌面应用程序

## <a name="introduction"></a>简介

### <a name="a-story-of-one-company"></a>一个公司的故事

早在 2000 年初，有一家跨国公司就开始开发分布式桌面解决方案，以实现公司不同分支机构之间的信息交换，并对集中单元执行优化操作。 他们选择了一个名为 Windows 窗体（又称 WinForms）的全新框架来进行应用程序开发。 经过多年的努力，该项目已经发展成一个具有几十万行代码的成熟、经过良好测试且久经考验的应用程序。 时光荏苒，.NET Framework 2.0 不再是炙手可热的新技术。 正在开发这个应用程序的开发人员面临着一个两难的局面。 他们希望在开发中使用最新的技术堆栈，并让应用程序看上去更现代化。 同时又不想放弃历经 15 年精心打磨出来的产品，从头开始重写整个应用程序。

### <a name="your-story"></a>你的故事

你可能发现自己也陷入了这样的境地，你拥有成熟的 Windows 窗体或 Windows Presentation Foundation (WPF) 应用程序，这些应用程序多年来已经证明其可靠性。 你可能想继续使用这些应用程序很多年。 但与此同时，由于这些应用程序是在一段时间前编写的，它们可能缺少某些功能，比如现代化的外观、性能、与新设备和平台功能的集成等等，因此给人一种“旧技术”的感觉。 作为开发人员，你可能还会遇到另一个问题。 当你在旧的 .NET Framework 版本上工作，并维护前段时间编写的应用程序时，你可能会觉得自己没有学到新的技术，在培养现代技术技能上有所缺失。 如果你正在经历这些 - 这本书就是为你而写！

## <a name="desktop-applications-nowadays"></a>现在的桌面应用程序

在 Internet 兴起之前，桌面应用程序是生成软件系统的主要方法。 开发人员可以选择任何编程语言，如 COBOL、Fortran、VB6 或 C++。 但无论他们开发的是小工具还是复杂的分布式体系结构，这些都是桌面应用程序。

后来，Internet 技术开始冲击开发界，以易于部署、简化的分发过程等优势赢得了更多工程师的青睐。 Web 应用程序一旦部署到生产环境中，所有用户都能获得自动更新，这对软件的敏捷性产生了巨大影响。

然而，Internet 基础结构、底层协议以及 HTTP 和 HTML 等标准不适合生成复杂的应用程序。 事实上，当时的主要开发工作只瞄准了一个目标：让 Web 应用程序拥有与桌面应用程序一样的功能，比如快速数据输入和状态管理。

即使 Web 和移动应用程序以令人难以置信的速度发展，但对于某些任务来说，桌面应用程序在效率和性能方面仍然占据第一的位置。 这就解释了为什么有数以百万计的开发人员在使用 WPF 和 WinForms 生成项目，而且这些应用程序的数量还在不断增加。

下面列出了在开发中选择桌面应用程序的一些原因：

- 桌面应用可以与用户电脑更好地交互。
- 桌面应用程序进行复杂计算的性能远高于 Web 应用程序的性能。
- Web 应用程序也可以在客户端运行自定义逻辑，但是要难得多。
- 在桌面应用程序中使用多线程处理更简单、更高效。
- 设计用户界面 (UI) 的学习曲线并不陡峭。 WinForms 使用简便，这要归功于 Windows 窗体设计器的拖放体验。
- 可以轻松开始编码和测试算法，既不需要设置服务器基础结构，也不需要关心连接问题、防火墙和浏览器兼容性。
- 与 Web 调试相比，桌面调试功能更强大。
- 轻松访问硬件设备，例如摄像头、蓝牙或读卡器。
- 由于这项技术已经出现一段时间了，因此开发桌面应用程序时不仅有知识库可用，还有许多这方面的专家。

正如你所看到的那样，针对桌面进行开发从许多方面来说都是不错的选择。 技术成熟且久经考验，开发周期快，调试功能强大，可以说，桌面应用的复杂度较低，更容易上手。

从 1995 年推出的 Win32 到 2016 年发布的通用 Windows 平台 (UWP)，Microsoft 多年来提供了许多 UI 桌面技术。

![Microsoft 桌面技术](./media/why-modern-applications/microsoft-desktop-technologies.png)

Telerik 在 2016 年 4 月发布的一项调查表明，生成 Windows 桌面应用最受欢迎的技术是 Windows 窗体、WPF 和 UWP。

![Telerik 调查显示，Windows 窗体、WPF 和 UWP 是最受欢迎的桌面技术](./media/why-modern-applications/telerik-survey.png)

你可以使用 C# 和 Visual Basic 在其中任何一项技术中进行开发，不过，先让我们进一步了解这些技术。

### <a name="windows-forms"></a>Windows 窗体

Windows 窗体最初发布于 2002 年，是一个托管框架，也是构建于 Windows 图形设备接口 (GDI) 引擎之上的最早、最常用的桌面技术。 它为在 Visual Studio 中开发用户界面提供了流畅的拖放体验。  与此同时，Windows 窗体依靠 Visual Studio 设计器作为开发 UI 的主要方式，因此通过代码创建视觉组件并不轻松。

下表总结了 Windows 窗体的主要特征：

- 技术成熟，拥有大量代码示例和文档。
- 功能强大且高效的设计器。 “通过代码”设计 UI 不是很方便。
- 学习起来简单直观，这要归功于设计器的拖放体验。
- 在任何 Windows 版本上均受支持。
- 在 .NET Core 3.0 和更高版本上受支持。

### <a name="wpf"></a>WPF

基于 XAML 语言规范的 WPF 支持将 UI 和代码明确分离。 XAML 提供模板化、样式化和绑定等功能，适合生成大型应用程序。 和 Windows 窗体一样，它也是一个托管框架，但采用了可重用的模块化设计。

以下是 WPF 的主要特征：

- 成熟的技术。
- 提供设计器，但开发人员通常更喜欢使用声明性 XAML 通过代码创建设计。
- 学习曲线比 Windows 窗体更陡峭。
- 在任何 Windows 版本上均受支持。
- 在 .NET Core 3.0 和更高版本上受支持。

### <a name="uwp"></a>UWP

UWP 不仅仅是一个像 WPF 和 Windows 窗体这样的演示框架，它本身也是一个平台。 此平台具有：

- 自己的 API 集（Windows 运行时 API）。
- 新的部署系统 (MSIX)
- 新式应用程序生命周期模型（用于低电池消耗）。
- 新的资源管理系统（基于 PRI 文件）。

此平台旨在支持各种外形规格的各种输入系统（如墨迹、触摸、游戏手柄、鼠标、键盘、凝视等），同时考虑到性能和低电池消耗。 基于这些原因，Windows 10 操作系统的外壳使用了 UWP 平台的一部分。

![UWP 结构](./media/why-modern-applications/uwp-structure.png)

UWP 像 WPF 一样，包含一个基于 XAML 的演示框架，但是它有一些重要区别，比如：

- 应用程序在应用容器中执行。 应用容器控制 UWP 应用可以访问哪些资源。
- 仅在 Windows 10 上受支持。
- 可以通过 Microsoft Store 部署应用，以方便部署。
- 设计为 Windows 运行时 API 的一部分。
- 包含大量丰富的内置控件，以及通过每几个月更新一次的 Microsoft UI 库 NuGet 包（WinUI 库）提供的附加控件。

## <a name="a-tale-of-two-platforms"></a>两个平台的故事

在过去的 20 年里，当 UI 桌面技术不断发展，并沿着从 Windows 窗体到 UWP 的道路前进时，硬件也从采用小型 CRT 显示器的重量级电脑装置，发展到高 DPI 显示器，以及采用触摸、墨迹等各种数据输入技术的轻量级平板电脑和手机。 这些变化衍生了两个不同的概念：桌面应用程序和新式应用程序。 新式应用程序考虑了各种设备外形规格、各种输入和输出方法，并在沙盒化执行模型上运行时使用新式桌面功能。 （传统）桌面应用程序则需要一个包含高密度控件的可靠 UI，这些控件最好使用鼠标和键盘来操作。

下表描述了这两个概念之间的差异：

|   | 新式应用程序 | 桌面应用程序 |
| --- | --- | --- |
| 安全性 | 执行受控，基础稳固&amp;。 采用全新设计，旨在尊重用户隐私，管理电池寿命，并专注于保护设备安全。  | 用户和管理员级别的安全性&amp;。 对注册表和硬盘文件夹具有本机访问权限。 |
| 部署 | 安装和更新由平台管理。   | MSI、自定义安装程序和更新&amp;。 一直以来都是让开发人员和 IT 经理头疼的问题。  |
| 分发 | 可信分发和已签名的包&amp;。 从可信源进行分发，绝不从 Web 分发。  | Web、SCCM 和自定义分发&amp;。 无法控制安装的内容，影响整个计算机。   |
| UI | 新式 UI。 各种输入机制，墨迹、触摸、游戏手柄、键盘、鼠标等。  | Windows 窗体、WPF、MFC。 设计为使用鼠标和键盘来操控密集型 UI，旨在从桌面获得最大生产力。  |
| 数据 | 包含见解的云优先数据。 云中的可靠来源。 从见解中了解你的应用发生了什么，以及它的性能如何。  | 本地数据。 传统桌面应用程序通常需要一些本地数据。  |
| 设计 | 设计为可重用。 可在前端和后端的不同平台之间重复使用，在尽可能多的地方运行资产。  | 仅适用于 Windows 桌面  |

为了履行为开发人员提供最佳应用程序生成工具的承诺，Microsoft 投入了大量精力，将这些概念（甚至可以说平台）更紧密地结合到一起，让开发人员能够鱼和熊掌兼得。 为此，Microsoft 在这两个平台之间进行了双向努力。

![新式应用程序和桌面应用程序之间的双向努力](./media/why-modern-applications/bidirectional-effort.png)

1. 将桌面应用程序方案迁移到新式应用程序平台。 传统的桌面开发仍然很受欢迎，因为它能很好地解决某些情况。 将这些常见的桌面方案引入新式桌面平台，让平台充分发挥作用，是很有意义的。

    ![将桌面应用程序方案迁移到新式应用程序平台](./media/why-modern-applications/desktop-to-modern.png)

1. 将新式应用程序功能迁移到桌面应用程序。 对于需要一种方法来利用新式功能而又无需从头开始重写的现有桌面应用，将新式应用程序平台的功能推送到桌面应用程序中。

    ![将新式应用程序功能迁移到桌面应用程序](./media/why-modern-applications/modern-to-desktop.png)

本书将重点介绍第二部分，并展示如何实现现有桌面应用程序的现代化。

## <a name="paths-to-modernization"></a>通往现代化之路

本指南的结构反映了实现现代化的三个不同轴心：新式功能、部署和安装。

### <a name="modern-features"></a>新式功能

假设你有一个可正常运行的 Windows 窗体应用程序，公司销售代表用它来填写客户订单。 现在来了一个新需求，即，让客户能够使用触笔签署订单。 墨迹书写是当今操作系统和技术中的原生功能，但在开发该应用时，它还不可用。

此路径将展示如何在现有桌面开发中利用新式桌面功能。

### <a name="deployment"></a>部署

新式开发周期旨在针对每个用户灵活地部署应用程序的新版本。 由于 Windows 窗体和 WPF 应用程序基于计算机上必须安装的特定 .NET Framework 版本，因此在没有 IT 人员干预的情况下，它们无法利用新版 .NET Framework 的功能，而这可能会对运行在同一台计算机上的其他应用产生副作用。 这限制了开发人员的创新步伐，迫使他们停留在过时的 .NET Framework 版本上。

自 .NET Core 3.0 推出以来，你可以利用一种新方法，即，并行部署多个版本的 .NET，并指定每个应用程序应面向的 .NET 版本。 这样，你就可以在一个应用程序中使用最新功能，同时确信自己不会中断任何其他应用程序。

### <a name="installation"></a>安装

桌面应用程序总是需要完成某种安装过程，然后用户才能开始使用。 这就牵涉到了一系列技术，从 MSI 和 ClickOnce 到自定义安装程序甚至 XCOPY 部署。 这些方法中的任何一种都涉及一些微妙的问题，因为应用程序需要通过某种方式来访问计算机上的共享资源。 安装过程有时需要访问注册表来插入或更新新的键值，有时需要更新主应用程序引用的共享 DLL。 这种行为让用户头疼不已，并且产生了这样的看法：一旦安装了某个应用程序，即使事后卸载，你的计算机也无法恢复如初。

在本书中，我们将介绍一种使用 MSIX 安装应用程序的新方法，它可以解决前面所述的问题。 你将了解如何轻松设置应用程序的打包、安装和更新。

>[!div class="step-by-step"]
>[上一页](index.md)
>[下一页](whats-new-dotnet.md)
