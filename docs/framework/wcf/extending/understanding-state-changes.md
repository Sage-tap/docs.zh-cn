---
description: 了解详细信息：了解状态更改
title: 了解状态更改
ms.date: 03/30/2017
ms.assetid: a79ed2aa-e49a-47a8-845a-c9f436ec9987
ms.openlocfilehash: e537a7421ffa8ab924e4e9e4ab841343245534b2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99644003"
---
# <a name="understanding-state-changes"></a><span data-ttu-id="c7a48-103">了解状态更改</span><span class="sxs-lookup"><span data-stu-id="c7a48-103">Understanding State Changes</span></span>

<span data-ttu-id="c7a48-104">本节讨论的内容包括通道具有的状态和转换、用于结构通道状态的类型以及实现它们的方式。</span><span class="sxs-lookup"><span data-stu-id="c7a48-104">This topic discusses the states and transitions that channels have, the types used to structure channel states, and how to implement them.</span></span>  
  
## <a name="state-machines-and-channels"></a><span data-ttu-id="c7a48-105">状态机和通道</span><span class="sxs-lookup"><span data-stu-id="c7a48-105">State Machines and Channels</span></span>  

 <span data-ttu-id="c7a48-106">处理通信的对象（例如套接字）通常提供一个状态机，其状态转换与分配网络资源、生成或接受连接、关闭连接以及终止通信有关。</span><span class="sxs-lookup"><span data-stu-id="c7a48-106">Objects that deal with communication, for example sockets, usually present a state machine whose state transitions relate to allocating network resources, making or accepting connections, closing connections and terminating communication.</span></span> <span data-ttu-id="c7a48-107">通道状态机提供通信对象状态的统一模型，用于抽象该对象的基础实现。</span><span class="sxs-lookup"><span data-stu-id="c7a48-107">The channel state machine provides a uniform model of the states of a communication object that abstracts the underlying implementation of that object.</span></span> <span data-ttu-id="c7a48-108"><xref:System.ServiceModel.ICommunicationObject> 接口提供一组状态、状态转换方法和状态转换事件。</span><span class="sxs-lookup"><span data-stu-id="c7a48-108">The <xref:System.ServiceModel.ICommunicationObject> interface provides a set of states, state transition methods and state transition events.</span></span> <span data-ttu-id="c7a48-109">所有通道、通道工厂和通道侦听器都实现通道状态机。</span><span class="sxs-lookup"><span data-stu-id="c7a48-109">All channels, channel factories and channel listeners implement the channel state machine.</span></span>  
  
 <span data-ttu-id="c7a48-110">Closed、Closing、Faulted、Opened 和 Opening 事件在发生状态转换后向外部观察者发出信号。</span><span class="sxs-lookup"><span data-stu-id="c7a48-110">The events Closed, Closing, Faulted, Opened and Opening signal an external observer after a state transition occurs.</span></span>  
  
 <span data-ttu-id="c7a48-111">Abort、Close 和 Open 方法（以及它们的异步等效方法）产生状态转换。</span><span class="sxs-lookup"><span data-stu-id="c7a48-111">The methods Abort, Close, and Open (and their asynchronous equivalents) cause state transitions.</span></span>  
  
 <span data-ttu-id="c7a48-112">状态属性返回如 <xref:System.ServiceModel.CommunicationState> 所定义的当前状态：</span><span class="sxs-lookup"><span data-stu-id="c7a48-112">The state property returns the current state as defined by <xref:System.ServiceModel.CommunicationState>:</span></span>  
  
## <a name="icommunicationobject-communicationobject-and-states-and-state-transition"></a><span data-ttu-id="c7a48-113">ICommunicationObject、CommunicationObject 和状态及状态转换</span><span class="sxs-lookup"><span data-stu-id="c7a48-113">ICommunicationObject, CommunicationObject, and States and State Transition</span></span>  

 <span data-ttu-id="c7a48-114"><xref:System.ServiceModel.ICommunicationObject> 的初始状态是“已创建”，此时可以配置它的各种属性。</span><span class="sxs-lookup"><span data-stu-id="c7a48-114">An <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state where its various properties can be configured.</span></span> <span data-ttu-id="c7a48-115">一旦处于“已打开”状态，对象就可用于发送和接收消息，但它的属性将视为不可变。</span><span class="sxs-lookup"><span data-stu-id="c7a48-115">Once in the Opened state, the object is usable for sending and receiving messages but its properties are considered immutable.</span></span> <span data-ttu-id="c7a48-116">一旦处在“正在关闭”状态，对象就不能再处理新的发送或接收请求，但在到达“关闭”超时前有可能完成现有的请求。</span><span class="sxs-lookup"><span data-stu-id="c7a48-116">Once in the Closing state, the object can no longer process new send or receive requests, but existing requests have a chance to complete until the Close timeout is reached.</span></span>  <span data-ttu-id="c7a48-117">如果发生不可恢复的错误，则对象将转换到“出错”状态，此时可以检查该对象以获取有关错误的信息，该对象最终将关闭。</span><span class="sxs-lookup"><span data-stu-id="c7a48-117">If an unrecoverable error occurs, the object transitions to the Faulted state where it can be inspected for information about the error and ultimately closed.</span></span> <span data-ttu-id="c7a48-118">处于“已关闭”状态时，该对象实质上已到达状态机的终点。</span><span class="sxs-lookup"><span data-stu-id="c7a48-118">When in the Closed state the object has essentially reached the end of the state machine.</span></span> <span data-ttu-id="c7a48-119">对象一旦从一个状态转换到下一个状态，它将不会返回至前一状态。</span><span class="sxs-lookup"><span data-stu-id="c7a48-119">Once an object transitions from one state to the next, it does not go back to a previous state.</span></span>  
  
 <span data-ttu-id="c7a48-120">下面的关系图演示 <xref:System.ServiceModel.ICommunicationObject> 状态和状态转换。</span><span class="sxs-lookup"><span data-stu-id="c7a48-120">The following diagram shows the <xref:System.ServiceModel.ICommunicationObject> states and state transitions.</span></span> <span data-ttu-id="c7a48-121">通过调用以下三种方法之一可导致状态转换：Abort、Open 或 Close。</span><span class="sxs-lookup"><span data-stu-id="c7a48-121">State transitions can be caused by calling one of the three methods: Abort, Open, or Close.</span></span> <span data-ttu-id="c7a48-122">通过调用其他特定于实现的方法也会导致状态转换。</span><span class="sxs-lookup"><span data-stu-id="c7a48-122">They could also be caused by calling other implementation-specific methods.</span></span> <span data-ttu-id="c7a48-123">转换至“出错”状态可能是因为在打开通信对象过程中或在打开通信对象之后发生了错误。</span><span class="sxs-lookup"><span data-stu-id="c7a48-123">Transitioning to the Faulted state could happen as a result of errors while opening or after having opened the communication object.</span></span>  
  
 <span data-ttu-id="c7a48-124">每个 <xref:System.ServiceModel.ICommunicationObject> 的初始状态都是“已创建”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-124">Every <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state.</span></span> <span data-ttu-id="c7a48-125">在此状态下，应用程序可以通过设置对象的属性来配置对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-125">In this state, an application can configure the object by setting its properties.</span></span> <span data-ttu-id="c7a48-126">一旦对象所处的状态不是“已创建”，它将被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="c7a48-126">Once an object is in a state other than Created, it is considered immutable.</span></span>  
  
 ![通道状态转换的数据流关系图。](./media/understanding-state-changes/channel-state-transitions.gif)  
<span data-ttu-id="c7a48-128">图 1.</span><span class="sxs-lookup"><span data-stu-id="c7a48-128">Figure 1.</span></span> <span data-ttu-id="c7a48-129">ICommunicationObject 状态机。</span><span class="sxs-lookup"><span data-stu-id="c7a48-129">The ICommunicationObject State Machine.</span></span>  
  
 <span data-ttu-id="c7a48-130">Windows Communication Foundation (WCF) 提供一个名为的抽象基类 <xref:System.ServiceModel.Channels.CommunicationObject> ，该基类实现 <xref:System.ServiceModel.ICommunicationObject> 和通道状态机。</span><span class="sxs-lookup"><span data-stu-id="c7a48-130">Windows Communication Foundation (WCF) provides an abstract base class named <xref:System.ServiceModel.Channels.CommunicationObject> that implements <xref:System.ServiceModel.ICommunicationObject> and the channel state machine.</span></span> <span data-ttu-id="c7a48-131">下图是特定于 <xref:System.ServiceModel.Channels.CommunicationObject> 的已修改状态关系图。</span><span class="sxs-lookup"><span data-stu-id="c7a48-131">The following graphic is a modified state diagram that is specific to <xref:System.ServiceModel.Channels.CommunicationObject>.</span></span> <span data-ttu-id="c7a48-132">除了 <xref:System.ServiceModel.ICommunicationObject> 状态机，它还显示调用附加 <xref:System.ServiceModel.Channels.CommunicationObject> 方法时的计时。</span><span class="sxs-lookup"><span data-stu-id="c7a48-132">In addition to the <xref:System.ServiceModel.ICommunicationObject> state machine, it shows the timing when additional <xref:System.ServiceModel.Channels.CommunicationObject> methods are invoked.</span></span>  
  
 <span data-ttu-id="c7a48-133">![CommunicationObject 实现状态更改的数据流关系图。](./media/understanding-state-changes/communicationobject-implementation-state-machine.gif)</span><span class="sxs-lookup"><span data-stu-id="c7a48-133">![Dataflow diagram of CommunicationObject implementation state changes.](./media/understanding-state-changes/communicationobject-implementation-state-machine.gif)</span></span>
<span data-ttu-id="c7a48-134">图 2.</span><span class="sxs-lookup"><span data-stu-id="c7a48-134">Figure 2.</span></span> <span data-ttu-id="c7a48-135">ICommunicationObject 状态机的 CommunicationObject 实现，包括对事件和受保护方法的调用。</span><span class="sxs-lookup"><span data-stu-id="c7a48-135">The CommunicationObject implementation of the ICommunicationObject state machine including calls to events and protected methods.</span></span>  
  
### <a name="icommunicationobject-events"></a><span data-ttu-id="c7a48-136">ICommunicationObject 事件</span><span class="sxs-lookup"><span data-stu-id="c7a48-136">ICommunicationObject Events</span></span>  

 <span data-ttu-id="c7a48-137"><xref:System.ServiceModel.Channels.CommunicationObject> 公开由 <xref:System.ServiceModel.ICommunicationObject> 定义的五个事件。</span><span class="sxs-lookup"><span data-stu-id="c7a48-137"><xref:System.ServiceModel.Channels.CommunicationObject> exposes the five events defined by <xref:System.ServiceModel.ICommunicationObject>.</span></span> <span data-ttu-id="c7a48-138">这些事件是为使用通信对象接收状态转换通知的代码而设计的。</span><span class="sxs-lookup"><span data-stu-id="c7a48-138">These events are designed for code using the communication object to be notified of state transitions.</span></span> <span data-ttu-id="c7a48-139">如上面的图 2 所示，每个事件都在对象的状态转换到按事件命名的状态后激发一次。</span><span class="sxs-lookup"><span data-stu-id="c7a48-139">As shown in Figure 2 above, each event is fired once after the object’s state transitions to the state named by the event.</span></span> <span data-ttu-id="c7a48-140">五个事件全部属于 `EventHandler` 类型，该类型定义如下：</span><span class="sxs-lookup"><span data-stu-id="c7a48-140">All five events are of the `EventHandler` type which is defined as:</span></span>  
  
 `public delegate void EventHandler(object sender, EventArgs e);`  
  
 <span data-ttu-id="c7a48-141">在 <xref:System.ServiceModel.Channels.CommunicationObject> 实现中，发送方是 <xref:System.ServiceModel.Channels.CommunicationObject> 本身或作为发送方传递至 <xref:System.ServiceModel.Channels.CommunicationObject> 构造函数（如果使用了该构造函数重载）中的任何内容。</span><span class="sxs-lookup"><span data-stu-id="c7a48-141">In the <xref:System.ServiceModel.Channels.CommunicationObject> implementation, the sender is either the <xref:System.ServiceModel.Channels.CommunicationObject> itself or whatever was passed in as the sender to the <xref:System.ServiceModel.Channels.CommunicationObject> constructor (if that constructor overload was used).</span></span> <span data-ttu-id="c7a48-142">EventArgs 参数 `e` 始终为 `EventArgs.Empty`。</span><span class="sxs-lookup"><span data-stu-id="c7a48-142">The EventArgs parameter, `e`, is always `EventArgs.Empty`.</span></span>  
  
### <a name="derived-object-callbacks"></a><span data-ttu-id="c7a48-143">派生对象回调</span><span class="sxs-lookup"><span data-stu-id="c7a48-143">Derived Object Callbacks</span></span>  

 <span data-ttu-id="c7a48-144">除了五个事件，<xref:System.ServiceModel.Channels.CommunicationObject> 还声明八个受保护的虚方法，用于在发生状态转换前后回调派生对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-144">In addition to the five events, <xref:System.ServiceModel.Channels.CommunicationObject> declares eight protected virtual methods designed to allow a derived object to be called back before and after state transitions occur.</span></span>  
  
 <span data-ttu-id="c7a48-145"><xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> 方法各自有三个与它们分别相关联的此类回调。</span><span class="sxs-lookup"><span data-stu-id="c7a48-145">The <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> methods have three such callbacks associated with each of them.</span></span> <span data-ttu-id="c7a48-146">例如，对应于 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType>，有 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c7a48-146">For example, corresponding to <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> there is <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c7a48-147">与 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> 相关联的是 <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="c7a48-147">Associated with <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> are the <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="c7a48-148">与此类似，<xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> 方法具有相应的 <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c7a48-148">Similarly, the <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> method has a corresponding <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c7a48-149"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> 没有默认实现，而其他回调却具有确保状态机正确性所必需的默认实现。</span><span class="sxs-lookup"><span data-stu-id="c7a48-149">While <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> have no default implementation, the other callbacks do have a default implementation which is necessary for state machine correctness.</span></span> <span data-ttu-id="c7a48-150">如果重写这些方法，请确保调用基实现或正确替换它。</span><span class="sxs-lookup"><span data-stu-id="c7a48-150">If you override those methods be sure to call the base implementation or correctly replace it.</span></span>  
  
 <span data-ttu-id="c7a48-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> 激发相应的 <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="c7a48-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> events.</span></span> <span data-ttu-id="c7a48-152"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> 分别将对象状态设置为“已打开”和“已关闭”，然后激发相应的 <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="c7a48-152"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> set the object state to Opened and Closed respectively then fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> events.</span></span>  
  
### <a name="state-transition-methods"></a><span data-ttu-id="c7a48-153">状态转换方法</span><span class="sxs-lookup"><span data-stu-id="c7a48-153">State Transition Methods</span></span>  

 <span data-ttu-id="c7a48-154"><xref:System.ServiceModel.Channels.CommunicationObject> 提供 Abort、Close 和 Open 的实现。</span><span class="sxs-lookup"><span data-stu-id="c7a48-154"><xref:System.ServiceModel.Channels.CommunicationObject> provides implementations of Abort, Close and Open.</span></span> <span data-ttu-id="c7a48-155">它还提供 Fault 方法，该方法可以将状态转换至“出错”状态。</span><span class="sxs-lookup"><span data-stu-id="c7a48-155">It also provides a Fault method which causes a state transition to the Faulted state.</span></span> <span data-ttu-id="c7a48-156">图 2 显示的是 <xref:System.ServiceModel.ICommunicationObject> 状态机，其每个转换都是由导致该转换的方法标记的（未标记转换发生在导致上一个标记转换的方法的实现内部）。</span><span class="sxs-lookup"><span data-stu-id="c7a48-156">Figure 2 shows the <xref:System.ServiceModel.ICommunicationObject> state machine with each transition labeled by the method that causes it (unlabeled transitions happen inside the implementation of the method that caused the last labeled transition).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c7a48-157">通信状态获取/设置的所有 <xref:System.ServiceModel.Channels.CommunicationObject> 实现都是线程同步的。</span><span class="sxs-lookup"><span data-stu-id="c7a48-157">All <xref:System.ServiceModel.Channels.CommunicationObject> implementations of communication state gets/sets are thread-synchronized.</span></span>  
  
 <span data-ttu-id="c7a48-158">构造函数</span><span class="sxs-lookup"><span data-stu-id="c7a48-158">Constructor</span></span>  
  
 <span data-ttu-id="c7a48-159"><xref:System.ServiceModel.Channels.CommunicationObject> 提供三个构造函数，它们都使对象保持“已创建”状态。</span><span class="sxs-lookup"><span data-stu-id="c7a48-159"><xref:System.ServiceModel.Channels.CommunicationObject> provides three constructors, all of which leave the object in the Created state.</span></span> <span data-ttu-id="c7a48-160">构造函数定义如下：</span><span class="sxs-lookup"><span data-stu-id="c7a48-160">The constructors are defined as:</span></span>  
  
 <span data-ttu-id="c7a48-161">第一个构造函数是委托给采用对象的构造函数重载的无参数构造函数：</span><span class="sxs-lookup"><span data-stu-id="c7a48-161">The first constructor is a parameterless constructor that delegates to the constructor overload that takes an object:</span></span>  
  
 `protected CommunicationObject() : this(new object()) { … }`  
  
 <span data-ttu-id="c7a48-162">采用对象的构造函数将该参数用作在同步对通信对象状态的访问时锁定的对象：</span><span class="sxs-lookup"><span data-stu-id="c7a48-162">The constructor that takes an object uses that parameter as the object to be locked when synchronizing access to communication object state:</span></span>  
  
 `protected CommunicationObject(object mutex) { … }`  
  
 <span data-ttu-id="c7a48-163">最后，第三个构造函数采用一个在激发 <xref:System.ServiceModel.ICommunicationObject> 事件时用作发送方自变量的附加参数。</span><span class="sxs-lookup"><span data-stu-id="c7a48-163">Finally, a third constructor takes an additional parameter that is used as the sender argument when <xref:System.ServiceModel.ICommunicationObject> events are fired.</span></span>  
  
 `protected CommunicationObject(object mutex, object eventSender) { … }`  
  
 <span data-ttu-id="c7a48-164">前两个构造函数将发送方设置为此对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-164">The previous two constructors set the sender to this.</span></span>  
  
 <span data-ttu-id="c7a48-165">Open 方法</span><span class="sxs-lookup"><span data-stu-id="c7a48-165">Open Method</span></span>  
  
 <span data-ttu-id="c7a48-166">前提条件：状态为“已创建”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-166">Precondition: State is Created.</span></span>  
  
 <span data-ttu-id="c7a48-167">后置条件：状态为“已打开”或“出错”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-167">Post-condition: State is Opened or Faulted.</span></span> <span data-ttu-id="c7a48-168">可能引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-168">May throw an exception.</span></span>  
  
 <span data-ttu-id="c7a48-169">Open() 方法将尝试打开通信对象，并将状态设置为“已打开”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-169">The Open() method will try to open the communication object and set the state to Opened.</span></span> <span data-ttu-id="c7a48-170">如果遇到错误，它会将状态设置为“出错”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-170">If it encounters an error, it will set the state to Faulted.</span></span>  
  
 <span data-ttu-id="c7a48-171">该方法首先检查当前状态是否是“已创建”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-171">The method first checks that the current state is Created.</span></span> <span data-ttu-id="c7a48-172">如果当前状态是“正在打开”或“已打开”，则它将引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="c7a48-172">If the current state is Opening or Opened it throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="c7a48-173">在当前状态是“正在关闭”或“已关闭”的情况下，如果对象已终止，则该方法将引发 <xref:System.ServiceModel.CommunicationObjectAbortedException>，否则将引发 <xref:System.ObjectDisposedException>。</span><span class="sxs-lookup"><span data-stu-id="c7a48-173">If the current state is Closing or Closed, it throws a <xref:System.ServiceModel.CommunicationObjectAbortedException> if the object has been terminated and <xref:System.ObjectDisposedException> otherwise.</span></span> <span data-ttu-id="c7a48-174">如果当前状态是“出错”，则它将引发 <xref:System.ServiceModel.CommunicationObjectFaultedException>。</span><span class="sxs-lookup"><span data-stu-id="c7a48-174">If the current state is Faulted, it throws a <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span></span>  
  
 <span data-ttu-id="c7a48-175">然后，它将状态设置为“正在打开”并依次调用 OnOpening()（将引发 Opening 事件）、OnOpen() 和 OnOpened()。</span><span class="sxs-lookup"><span data-stu-id="c7a48-175">It then sets the state to Opening and calls OnOpening() (which raises the Opening event), OnOpen() and OnOpened() in that order.</span></span> <span data-ttu-id="c7a48-176">OnOpened() 将状态设置为“已打开”并引发 Opened 事件。</span><span class="sxs-lookup"><span data-stu-id="c7a48-176">OnOpened() sets the state to Opened and raises the Opened event.</span></span> <span data-ttu-id="c7a48-177">如果这其中有任何一项引发异常，Open() 将调用 Fault() 并使异常向上冒泡。</span><span class="sxs-lookup"><span data-stu-id="c7a48-177">If any of these throws an exception, Open()calls Fault() and lets the exception bubble up.</span></span> <span data-ttu-id="c7a48-178">下面的关系图更详细地演示了“打开”过程。</span><span class="sxs-lookup"><span data-stu-id="c7a48-178">The following diagram shows the Open process in more detail.</span></span>  
  
 ![ICommunicationObject 状态更改的数据流关系图。](./media/understanding-state-changes/ico-open-process-override-onopen.gif)  
<span data-ttu-id="c7a48-180">重写 OnOpen 方法以实现自定义打开逻辑，例如，打开内部通信对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-180">Override the OnOpen method to implement custom open logic such as opening an inner communication object.</span></span>  
  
 <span data-ttu-id="c7a48-181">Close 方法</span><span class="sxs-lookup"><span data-stu-id="c7a48-181">Close Method</span></span>  
  
 <span data-ttu-id="c7a48-182">前提条件：无。</span><span class="sxs-lookup"><span data-stu-id="c7a48-182">Precondition: None.</span></span>  
  
 <span data-ttu-id="c7a48-183">后置条件：状态为“已关闭”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-183">Post-condition: State is Closed.</span></span> <span data-ttu-id="c7a48-184">可能引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-184">May throw an exception.</span></span>  
  
 <span data-ttu-id="c7a48-185">Close() 方法可以在任何状态下调用。</span><span class="sxs-lookup"><span data-stu-id="c7a48-185">The Close() method can be called at any state.</span></span> <span data-ttu-id="c7a48-186">它将尝试正常关闭对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-186">It tries to close the object normally.</span></span> <span data-ttu-id="c7a48-187">如果遇到错误，它将终止对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-187">If an error is encountered, it terminates the object.</span></span> <span data-ttu-id="c7a48-188">如果当前状态为“正在关闭”或“已关闭”，则该方法将不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="c7a48-188">The method does nothing if the current state is Closing or Closed.</span></span> <span data-ttu-id="c7a48-189">否则，它将状态设置为“正在关闭”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-189">Otherwise it sets the state to Closing.</span></span> <span data-ttu-id="c7a48-190">如果初始状态为“已创建”、“正在打开”或“出错”，它将调用 Abort()（请参见下面的关系图）。</span><span class="sxs-lookup"><span data-stu-id="c7a48-190">If the original state was Created, Opening or Faulted, it calls Abort() (see the following diagram).</span></span> <span data-ttu-id="c7a48-191">如果初始状态为“已打开”，它将依次调用 OnClosing()（将引发 Closing 事件）、OnClose() 和 OnClosed()。</span><span class="sxs-lookup"><span data-stu-id="c7a48-191">If the original state was Opened, it calls OnClosing() (which raises the Closing event), OnClose() and OnClosed() in that order.</span></span> <span data-ttu-id="c7a48-192">如果这其中有任何一项引发异常，Close() 将调用 Abort() 并使异常向上冒泡。</span><span class="sxs-lookup"><span data-stu-id="c7a48-192">If any of these throws an exception, Close()calls Abort() and lets the exception bubble up.</span></span> <span data-ttu-id="c7a48-193">OnClosed() 将状态设置为“已关闭”并引发 Closed 事件。</span><span class="sxs-lookup"><span data-stu-id="c7a48-193">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="c7a48-194">下面的关系图更详细地演示了“关闭”过程。</span><span class="sxs-lookup"><span data-stu-id="c7a48-194">The following diagram shows the Close process in more detail.</span></span>  
  
 ![ICommunicationObject 状态更改的数据流关系图。](./media/understanding-state-changes/ico-close-process-override-onclose.gif)  
<span data-ttu-id="c7a48-196">重写 OnClose 方法以实现自定义关闭逻辑，例如，关闭内部通信对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-196">Override the OnClose method to implement custom close logic, such as closing an inner communication object.</span></span> <span data-ttu-id="c7a48-197">可能长时间阻塞的所有正常关闭逻辑（例如，等待他方响应）应在 OnClose() 中实现，原因有两个，一是它采用超时参数，二是它不是作为 Abort() 的一部分调用的。</span><span class="sxs-lookup"><span data-stu-id="c7a48-197">All graceful closing logic that may block for a long time (for example, waiting for the other side to respond) should be implemented in OnClose() because it takes a timeout parameter and because it is not called as part of Abort().</span></span>  
  
 <span data-ttu-id="c7a48-198">中止</span><span class="sxs-lookup"><span data-stu-id="c7a48-198">Abort</span></span>  
  
 <span data-ttu-id="c7a48-199">前提条件：无。</span><span class="sxs-lookup"><span data-stu-id="c7a48-199">Precondition: None.</span></span>  
<span data-ttu-id="c7a48-200">后置条件：状态为“已关闭”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-200">Post-condition: State is Closed.</span></span> <span data-ttu-id="c7a48-201">可能引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-201">May throw an exception.</span></span>  
  
 <span data-ttu-id="c7a48-202">如果当前状态是“已关闭”或之前已终止对象（例如，可能通过在其他线程上执行 Abort()），则 Abort() 方法将不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="c7a48-202">The Abort() method does nothing if the current state is Closed or if the object has been terminated before (for example, possibly by having Abort() executing on another thread).</span></span> <span data-ttu-id="c7a48-203">否则，它将状态设置为“正在关闭”并依次调用 OnClosing()（将引发 Closing 事件）、OnAbort() 和 OnClosed()（因为是正在终止对象而非关闭，所以不调用 OnClose）。</span><span class="sxs-lookup"><span data-stu-id="c7a48-203">Otherwise it sets the state to Closing and calls OnClosing() (which raises the Closing event), OnAbort(), and OnClosed() in that order (does not call OnClose because the object is being terminated, not closed).</span></span> <span data-ttu-id="c7a48-204">OnClosed() 将状态设置为“已关闭”并引发 Closed 事件。</span><span class="sxs-lookup"><span data-stu-id="c7a48-204">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="c7a48-205">如果这其中的任何一项引发异常，它都将被重新引发至 Abort 的调用方。</span><span class="sxs-lookup"><span data-stu-id="c7a48-205">If any of these throw an exception, it is re-thrown to the caller of Abort.</span></span> <span data-ttu-id="c7a48-206">OnClosing()、OnClosed() 和 OnAbort() 的实现不应阻塞（例如，在输入/输出上）。</span><span class="sxs-lookup"><span data-stu-id="c7a48-206">Implementations of OnClosing(), OnClosed() and OnAbort() should not block (for example, on input/output).</span></span> <span data-ttu-id="c7a48-207">下面的关系图更详细地演示了“中止”过程。</span><span class="sxs-lookup"><span data-stu-id="c7a48-207">The following diagram shows the Abort process in more detail.</span></span>  
  
 ![ICommunicationObject 状态更改的数据流关系图。](./media/understanding-state-changes/ico-abort-process-override-onabort.gif)  
<span data-ttu-id="c7a48-209">重写 OnAbort 方法以实现自定义终止逻辑，例如，终止内部通信对象。</span><span class="sxs-lookup"><span data-stu-id="c7a48-209">Override the OnAbort method to implement custom terminate logic such as terminating an inner communication object.</span></span>  
  
 <span data-ttu-id="c7a48-210">故障</span><span class="sxs-lookup"><span data-stu-id="c7a48-210">Fault</span></span>  
  
 <span data-ttu-id="c7a48-211">Fault 方法特定于 <xref:System.ServiceModel.Channels.CommunicationObject> 且不是 <xref:System.ServiceModel.ICommunicationObject> 接口的一部分。</span><span class="sxs-lookup"><span data-stu-id="c7a48-211">The Fault method is specific to <xref:System.ServiceModel.Channels.CommunicationObject> and is not part of the <xref:System.ServiceModel.ICommunicationObject> interface.</span></span> <span data-ttu-id="c7a48-212">在此处对其介绍是出于完整性的考虑。</span><span class="sxs-lookup"><span data-stu-id="c7a48-212">It is included here for completeness.</span></span>  
  
 <span data-ttu-id="c7a48-213">前提条件：无。</span><span class="sxs-lookup"><span data-stu-id="c7a48-213">Precondition: None.</span></span>  
  
 <span data-ttu-id="c7a48-214">后置条件：状态为“出错”。</span><span class="sxs-lookup"><span data-stu-id="c7a48-214">Post-condition: State is Faulted.</span></span> <span data-ttu-id="c7a48-215">可能引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-215">May throw an exception.</span></span>  
  
 <span data-ttu-id="c7a48-216">如果当前状态为“出错”或“已关闭”，则 Fault() 方法不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="c7a48-216">The Fault() method does nothing if the current state is Faulted or Closed.</span></span> <span data-ttu-id="c7a48-217">否则，它将状态设置为“出错”并调用 OnFaulted()（将引发 Faulted 事件）。</span><span class="sxs-lookup"><span data-stu-id="c7a48-217">Otherwise it sets the state to Faulted and call OnFaulted(), which raises the Faulted event.</span></span> <span data-ttu-id="c7a48-218">如果 OnFaulted 引发异常，则将重新引发它。</span><span class="sxs-lookup"><span data-stu-id="c7a48-218">If OnFaulted throws an exception it is re-thrown.</span></span>  
  
### <a name="throwifxxx-methods"></a><span data-ttu-id="c7a48-219">ThrowIfXxx 方法</span><span class="sxs-lookup"><span data-stu-id="c7a48-219">ThrowIfXxx Methods</span></span>  

 <span data-ttu-id="c7a48-220">CommunicationObject 具有三个受保护的方法，可以用于在对象处于特定状态时引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-220">CommunicationObject has three protected methods that can be used to throw exceptions if the object is in a specific state.</span></span>  
  
 <span data-ttu-id="c7a48-221">如果状态为“正在关闭”、“已关闭”或“出错”，则 <xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> throws an exception if the state is Closing, Closed or Faulted.</span></span>  
  
 <span data-ttu-id="c7a48-222">如果状态不是“已创建”，则 <xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> throws an exception if the state is not Created.</span></span>  
  
 <span data-ttu-id="c7a48-223">如果状态不是“已打开”，则 <xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-223"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> throws an exception if the state is not Opened.</span></span>  
  
 <span data-ttu-id="c7a48-224">根据状态引发异常。</span><span class="sxs-lookup"><span data-stu-id="c7a48-224">The exceptions thrown depend on the state.</span></span> <span data-ttu-id="c7a48-225">下表显示不同的状态以及通过调用在该状态引发的 ThrowIfXxx 所引发的相应异常类型。</span><span class="sxs-lookup"><span data-stu-id="c7a48-225">The following table shows the different states and the corresponding exception type thrown by calling a ThrowIfXxx that throws on that state.</span></span>  
  
|<span data-ttu-id="c7a48-226">状态</span><span class="sxs-lookup"><span data-stu-id="c7a48-226">State</span></span>|<span data-ttu-id="c7a48-227">已调用 Abort？</span><span class="sxs-lookup"><span data-stu-id="c7a48-227">Has Abort been called?</span></span>|<span data-ttu-id="c7a48-228">异常</span><span class="sxs-lookup"><span data-stu-id="c7a48-228">Exception</span></span>|  
|-----------|----------------------------|---------------|  
|<span data-ttu-id="c7a48-229">创建</span><span class="sxs-lookup"><span data-stu-id="c7a48-229">Created</span></span>|<span data-ttu-id="c7a48-230">不适用</span><span class="sxs-lookup"><span data-stu-id="c7a48-230">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="c7a48-231">打开</span><span class="sxs-lookup"><span data-stu-id="c7a48-231">Opening</span></span>|<span data-ttu-id="c7a48-232">不适用</span><span class="sxs-lookup"><span data-stu-id="c7a48-232">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="c7a48-233">已打开</span><span class="sxs-lookup"><span data-stu-id="c7a48-233">Opened</span></span>|<span data-ttu-id="c7a48-234">不适用</span><span class="sxs-lookup"><span data-stu-id="c7a48-234">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="c7a48-235">关闭</span><span class="sxs-lookup"><span data-stu-id="c7a48-235">Closing</span></span>|<span data-ttu-id="c7a48-236">是</span><span class="sxs-lookup"><span data-stu-id="c7a48-236">Yes</span></span>|<xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>|  
|<span data-ttu-id="c7a48-237">关闭</span><span class="sxs-lookup"><span data-stu-id="c7a48-237">Closing</span></span>|<span data-ttu-id="c7a48-238">否</span><span class="sxs-lookup"><span data-stu-id="c7a48-238">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="c7a48-239">已关闭</span><span class="sxs-lookup"><span data-stu-id="c7a48-239">Closed</span></span>|<span data-ttu-id="c7a48-240">是</span><span class="sxs-lookup"><span data-stu-id="c7a48-240">Yes</span></span>|<span data-ttu-id="c7a48-241">如果通过前一个对 Abort 的显式调用来关闭对象，将引发 <xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c7a48-241"><xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType> in the case that an object was closed by a previous and explicit call of Abort.</span></span> <span data-ttu-id="c7a48-242">如果对对象调用 Close，将引发 <xref:System.ObjectDisposedException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c7a48-242">If you call Close on the object then an <xref:System.ObjectDisposedException?displayProperty=nameWithType> is thrown.</span></span>|  
|<span data-ttu-id="c7a48-243">已关闭</span><span class="sxs-lookup"><span data-stu-id="c7a48-243">Closed</span></span>|<span data-ttu-id="c7a48-244">否</span><span class="sxs-lookup"><span data-stu-id="c7a48-244">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="c7a48-245">出错</span><span class="sxs-lookup"><span data-stu-id="c7a48-245">Faulted</span></span>|<span data-ttu-id="c7a48-246">不适用</span><span class="sxs-lookup"><span data-stu-id="c7a48-246">N/A</span></span>|<xref:System.ServiceModel.CommunicationObjectFaultedException?displayProperty=nameWithType>|  
  
### <a name="timeouts"></a><span data-ttu-id="c7a48-247">超时</span><span class="sxs-lookup"><span data-stu-id="c7a48-247">Timeouts</span></span>  

 <span data-ttu-id="c7a48-248">在我们讨论的方法中，有一些方法采用超时参数。</span><span class="sxs-lookup"><span data-stu-id="c7a48-248">Several of the methods we discussed take timeout parameters.</span></span> <span data-ttu-id="c7a48-249">它们是 Close、Open（某些重载和异步版本）、OnClose 和 OnOpen。</span><span class="sxs-lookup"><span data-stu-id="c7a48-249">These are Close, Open (certain overloads and asynchronous versions), OnClose and OnOpen.</span></span> <span data-ttu-id="c7a48-250">这些方法旨在允许长时间的操作（例如，在正常断开连接时阻塞输入/输出），以使超时参数指示此类操作在被中断前要耗费多长时间。</span><span class="sxs-lookup"><span data-stu-id="c7a48-250">These methods are designed to allow for lengthy operations (for example, blocking on input/output while gracefully closing down a connection) so the timeout parameter indicates how long such operations can take before being interrupted.</span></span> <span data-ttu-id="c7a48-251">任何此类方法的实现都应使用提供的超时值，以此确保它在超时之前返回至调用方。</span><span class="sxs-lookup"><span data-stu-id="c7a48-251">Implementations of any of these methods should use the supplied timeout value to ensure it returns to the caller within that timeout.</span></span> <span data-ttu-id="c7a48-252">其他不采用超时的方法的实现不适用于长时间的操作，不应阻塞输入/输出。</span><span class="sxs-lookup"><span data-stu-id="c7a48-252">Implementations of other methods that do not take a timeout are not designed for lengthy operations and should not block on input/output.</span></span>  
  
 <span data-ttu-id="c7a48-253">但是不采用超时的 Open() 和 Close() 重载除外。</span><span class="sxs-lookup"><span data-stu-id="c7a48-253">The exception are the Open() and Close() overloads that do not take a timeout.</span></span> <span data-ttu-id="c7a48-254">它们使用由派生类提供的默认超时值。</span><span class="sxs-lookup"><span data-stu-id="c7a48-254">These use a default timeout value supplied by the derived class.</span></span> <span data-ttu-id="c7a48-255"><xref:System.ServiceModel.Channels.CommunicationObject>公开两个名为 <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> 的受保护抽象属性，定义如下：</span><span class="sxs-lookup"><span data-stu-id="c7a48-255"><xref:System.ServiceModel.Channels.CommunicationObject> exposes two protected abstract properties named <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> defined as:</span></span>  
  
 `protected abstract TimeSpan DefaultCloseTimeout { get; }`  
  
 `protected abstract TimeSpan DefaultOpenTimeout { get; }`  
  
 <span data-ttu-id="c7a48-256">派生类实现这些属性来为不采用超时值的 Open() 和 Close() 重载提供默认超时。</span><span class="sxs-lookup"><span data-stu-id="c7a48-256">A derived class implements these properties to provide the default timeout for the Open() and Close() overloads that do not take a timeout value.</span></span> <span data-ttu-id="c7a48-257">然后，Open() 和 Close() 实现委托给采用超时为它传递默认超时值的重载，例如：</span><span class="sxs-lookup"><span data-stu-id="c7a48-257">Then the Open() and Close() implementations delegate to the overload that takes a timeout passing it the default timeout value, for example:</span></span>  
  
 `public void Open()`  
  
 `{`  
  
 `this.Open(this.DefaultOpenTimeout);`  
  
 `}`  
  
#### <a name="idefaultcommunicationtimeouts"></a><span data-ttu-id="c7a48-258">IDefaultCommunicationTimeouts</span><span class="sxs-lookup"><span data-stu-id="c7a48-258">IDefaultCommunicationTimeouts</span></span>  

 <span data-ttu-id="c7a48-259">该接口有四个用于为 open、send、receive 和 close 提供默认超时值的只读属性。</span><span class="sxs-lookup"><span data-stu-id="c7a48-259">This interface has four read-only properties for providing default timeout values for open, send, receive, and close.</span></span> <span data-ttu-id="c7a48-260">每个实现都负责以任何适当的方式获取默认值。</span><span class="sxs-lookup"><span data-stu-id="c7a48-260">Each implementation is responsible for obtaining the default values in whatever manner appropriate.</span></span> <span data-ttu-id="c7a48-261">为方便起见，<xref:System.ServiceModel.Channels.ChannelFactoryBase> 和 <xref:System.ServiceModel.Channels.ChannelListenerBase> 默认将这些值中的每个值都设置为 1 分钟。</span><span class="sxs-lookup"><span data-stu-id="c7a48-261">As a convenience, <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase> default these values to 1 minute each.</span></span>
