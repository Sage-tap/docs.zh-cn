---
title: CA2008：不要在未传递 TaskScheduler 的情况下创建任务（代码分析）
description: 了解代码分析规则 CA2008：不要在未传递 TaskScheduler 的情况下创建任务
ms.date: 08/26/2020
ms.topic: reference
f1_keywords:
- CA2008
- DoNotCreateTasksWithoutPassingATaskSchedulerAnalyzer
helpviewer_keywords:
- CA2008
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 84a97e2fd653998b7b03056b8e50b32759c9ee99
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "99787651"
---
# <a name="ca2008-do-not-create-tasks-without-passing-a-taskscheduler"></a><span data-ttu-id="65f65-103">CA2008：不要在未传递 TaskScheduler 的情况下创建任务</span><span class="sxs-lookup"><span data-stu-id="65f65-103">CA2008: Do not create tasks without passing a TaskScheduler</span></span>

| | <span data-ttu-id="65f65-104">值</span><span class="sxs-lookup"><span data-stu-id="65f65-104">Value</span></span> |
|-|-|
| <span data-ttu-id="65f65-105">**规则 ID**</span><span class="sxs-lookup"><span data-stu-id="65f65-105">**Rule ID**</span></span> |<span data-ttu-id="65f65-106">CA2008</span><span class="sxs-lookup"><span data-stu-id="65f65-106">CA2008</span></span>|
| <span data-ttu-id="65f65-107">**类别**</span><span class="sxs-lookup"><span data-stu-id="65f65-107">**Category**</span></span> |[<span data-ttu-id="65f65-108">可靠性</span><span class="sxs-lookup"><span data-stu-id="65f65-108">Reliability</span></span>](reliability-warnings.md)|
| <span data-ttu-id="65f65-109">修复是中断修复还是非中断修复</span><span class="sxs-lookup"><span data-stu-id="65f65-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="65f65-110">非中断</span><span class="sxs-lookup"><span data-stu-id="65f65-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="65f65-111">原因</span><span class="sxs-lookup"><span data-stu-id="65f65-111">Cause</span></span>

<span data-ttu-id="65f65-112">任务创建或延续操作使用未指定 <xref:System.Threading.Tasks.TaskScheduler> 参数的方法重载。</span><span class="sxs-lookup"><span data-stu-id="65f65-112">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>

## <a name="rule-description"></a><span data-ttu-id="65f65-113">规则说明</span><span class="sxs-lookup"><span data-stu-id="65f65-113">Rule description</span></span>

<span data-ttu-id="65f65-114">以下 .NET 任务创建和延续方法具有允许指定或省略 <xref:System.Threading.Tasks.TaskScheduler> 实例的重载：</span><span class="sxs-lookup"><span data-stu-id="65f65-114">The following .NET task creation and continuation methods have overloads that allow specifying or omitting a <xref:System.Threading.Tasks.TaskScheduler> instance:</span></span>

- <span data-ttu-id="65f65-115"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> 方法</span><span class="sxs-lookup"><span data-stu-id="65f65-115"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> methods</span></span>
- <span data-ttu-id="65f65-116"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName> 方法</span><span class="sxs-lookup"><span data-stu-id="65f65-116"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName> methods</span></span>

<span data-ttu-id="65f65-117">始终指定显式 <xref:System.Threading.Tasks.TaskScheduler> 参数以避免默认 <xref:System.Threading.Tasks.TaskScheduler.Current%2A> 值，其行为由调用方定义并且在运行时可能会变化。</span><span class="sxs-lookup"><span data-stu-id="65f65-117">Always specify an explicit <xref:System.Threading.Tasks.TaskScheduler> argument to avoid the default <xref:System.Threading.Tasks.TaskScheduler.Current%2A> value, whose behavior is defined by the caller and may vary at runtime.</span></span> <span data-ttu-id="65f65-118"><xref:System.Threading.Tasks.TaskScheduler.Current%2A> 返回与该线程上当前运行的任何 <xref:System.Threading.Tasks.Task> 相关联的计划程序。</span><span class="sxs-lookup"><span data-stu-id="65f65-118"><xref:System.Threading.Tasks.TaskScheduler.Current%2A> returns the scheduler associated with whatever <xref:System.Threading.Tasks.Task> is currently running on that thread.</span></span> <span data-ttu-id="65f65-119">如果没有此类任务，则返回 <xref:System.Threading.Tasks.TaskScheduler.Default%2A>，它表示线程池。</span><span class="sxs-lookup"><span data-stu-id="65f65-119">If there is no such task, it returns <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, which represents the thread pool.</span></span> <span data-ttu-id="65f65-120">在某些情况下，使用 <xref:System.Threading.Tasks.TaskScheduler.Current%2A> 可能会导致死锁或 UI 响应问题，因为原本打算在线程池上创建任务，但却等待返回到 UI 线程。</span><span class="sxs-lookup"><span data-stu-id="65f65-120">Using <xref:System.Threading.Tasks.TaskScheduler.Current%2A> could lead to deadlocks or UI responsiveness issues in some situations, when it was intended to create the task on the thread pool, but instead it waits to get back onto the UI thread.</span></span>

<span data-ttu-id="65f65-121">有关详细信息和详细示例，请参阅 [.NET Framework 4.5 中的新 TaskCreationOptions 和 TaskContinuationOptions](https://devblogs.microsoft.com/pfxteam/new-taskcreationoptions-and-taskcontinuationoptions-in-net-4-5/)。</span><span class="sxs-lookup"><span data-stu-id="65f65-121">For further information and detailed examples, see [New TaskCreationOptions and TaskContinuationOptions in .NET Framework 4.5](https://devblogs.microsoft.com/pfxteam/new-taskcreationoptions-and-taskcontinuationoptions-in-net-4-5/).</span></span>

> [!NOTE]
> <span data-ttu-id="65f65-122">[VSTHRD105 - 避免使用假定 TaskScheduler.Current](https://github.com/microsoft/vs-threading/blob/master/doc/analyzers/VSTHRD105.md) 是在 [Microsoft.VisualStudio.Threading.Analyzers](https://www.nuget.org/packages/Microsoft.VisualStudio.Threading.Analyzers) 包中实现的类似规则的方法重载。</span><span class="sxs-lookup"><span data-stu-id="65f65-122">[VSTHRD105 - Avoid method overloads that assume TaskScheduler.Current](https://github.com/microsoft/vs-threading/blob/master/doc/analyzers/VSTHRD105.md) is a similar rule implemented in [Microsoft.VisualStudio.Threading.Analyzers](https://www.nuget.org/packages/Microsoft.VisualStudio.Threading.Analyzers) package.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="65f65-123">如何解决冲突</span><span class="sxs-lookup"><span data-stu-id="65f65-123">How to fix violations</span></span>

<span data-ttu-id="65f65-124">若要解决冲突，请调用接受 <xref:System.Threading.Tasks.TaskScheduler> 并显式传入 <xref:System.Threading.Tasks.TaskScheduler.Default%2A> 或 <xref:System.Threading.Tasks.TaskScheduler.Current%2A> 以使意图明确的方法重载。</span><span class="sxs-lookup"><span data-stu-id="65f65-124">To fix violations, call the method overload that takes a <xref:System.Threading.Tasks.TaskScheduler> and explicitly pass in <xref:System.Threading.Tasks.TaskScheduler.Default%2A> or <xref:System.Threading.Tasks.TaskScheduler.Current%2A> to make the intent clear.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="65f65-125">何时禁止显示警告</span><span class="sxs-lookup"><span data-stu-id="65f65-125">When to suppress warnings</span></span>

<span data-ttu-id="65f65-126">此警告主要针对库，在库中，代码可能会在任意环境中执行，并且代码不应该对环境或方法的调用方如何调用或等待作出假设。</span><span class="sxs-lookup"><span data-stu-id="65f65-126">This warning is intended primarily for libraries, where the code may be executed in arbitrary environments and where code shouldn't make assumptions about the environment or how the caller of the method may be invoking or waiting on it.</span></span> <span data-ttu-id="65f65-127">对于代表应用程序代码（而不是库代码）的项目，可禁止显示此警告。</span><span class="sxs-lookup"><span data-stu-id="65f65-127">It may be appropriate to suppress the warning for projects that represent application code rather than library code.</span></span>

## <a name="see-also"></a><span data-ttu-id="65f65-128">另请参阅</span><span class="sxs-lookup"><span data-stu-id="65f65-128">See also</span></span>

- [<span data-ttu-id="65f65-129">.NET Framework 4.5 中的新 TaskCreationOptions 和 TaskContinuationOptions</span><span class="sxs-lookup"><span data-stu-id="65f65-129">New TaskCreationOptions and TaskContinuationOptions in .NET Framework 4.5</span></span>](https://devblogs.microsoft.com/pfxteam/new-taskcreationoptions-and-taskcontinuationoptions-in-net-4-5/)
- [<span data-ttu-id="65f65-130">VSTHRD105 - 避免使用假定 TaskScheduler.Current 的方法重载</span><span class="sxs-lookup"><span data-stu-id="65f65-130">VSTHRD105 - Avoid method overloads that assume TaskScheduler.Current</span></span>](https://github.com/microsoft/vs-threading/blob/master/doc/analyzers/VSTHRD105.md)
- [<span data-ttu-id="65f65-131">CA2007：不直接等待任务</span><span class="sxs-lookup"><span data-stu-id="65f65-131">CA2007: Do not directly await a Task</span></span>](ca2007.md)
- [<span data-ttu-id="65f65-132">可靠性规则</span><span class="sxs-lookup"><span data-stu-id="65f65-132">Reliability rules</span></span>](reliability-warnings.md)
