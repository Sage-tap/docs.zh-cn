---
description: 详细了解：自动内存管理
title: 自动内存管理
ms.date: 03/30/2017
helpviewer_keywords:
- garbage collection, automatic memory management
- memory, allocating
- memory, automatic memory management
- memory, releasing
- common language runtime, automatic memory management
- automatic memory management
- managed heap
- runtime, automatic memory management
ms.assetid: d4850de5-fa63-4936-a250-5678d118acba
ms.openlocfilehash: 1897167faecb112ffa4aa7b0dd0c8bb55b8d9459
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99629963"
---
# <a name="automatic-memory-management"></a><span data-ttu-id="0b8b0-103">自动内存管理</span><span class="sxs-lookup"><span data-stu-id="0b8b0-103">Automatic Memory Management</span></span>

<span data-ttu-id="0b8b0-104">自动内存管理是公共语言运行时在[托管执行](managed-execution-process.md)过程中提供的服务之一。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-104">Automatic memory management is one of the services that the Common Language Runtime provides during [Managed Execution](managed-execution-process.md).</span></span> <span data-ttu-id="0b8b0-105">公共语言运行时的垃圾回收器为应用程序管理内存的分配和释放。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-105">The Common Language Runtime's garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="0b8b0-106">对开发人员而言，这就意味着在开发托管应用程序时不必编写执行内存管理任务的代码。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-106">For developers, this means that you do not have to write code to perform memory management tasks when you develop managed applications.</span></span> <span data-ttu-id="0b8b0-107">自动内存管理可解决常见问题，例如，忘记释放对象并导致内存泄漏，或尝试访问已释放对象的内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak, or attempting to access memory for an object that has already been freed.</span></span> <span data-ttu-id="0b8b0-108">本节描述垃圾回收器如何分配和释放内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-108">This section describes how the garbage collector allocates and releases memory.</span></span>  
  
## <a name="allocating-memory"></a><span data-ttu-id="0b8b0-109">分配内存</span><span class="sxs-lookup"><span data-stu-id="0b8b0-109">Allocating Memory</span></span>  

 <span data-ttu-id="0b8b0-110">初始化新进程时，运行时会为进程保留一个连续的地址空间区域。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-110">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="0b8b0-111">这个保留的地址空间被称为托管堆。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-111">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="0b8b0-112">托管堆维护着一个指针，用它指向将在堆中分配的下一个对象的地址。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-112">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="0b8b0-113">最初，该指针设置为指向托管堆的基址。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-113">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="0b8b0-114">托管堆上包含了所有[引用类型](base-types/common-type-system.md)。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-114">All [reference types](base-types/common-type-system.md) are allocated on the managed heap.</span></span> <span data-ttu-id="0b8b0-115">应用程序创建第一个引用类型时，将为托管堆的基址中的类型分配内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-115">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="0b8b0-116">应用程序创建下一个对象时，垃圾回收器在紧接第一个对象后面的地址空间内为它分配内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-116">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="0b8b0-117">只要地址空间可用，垃圾回收器就会继续以这种方式为新对象分配空间。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-117">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>  
  
 <span data-ttu-id="0b8b0-118">从托管堆中分配内存要比非托管内存分配速度快。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-118">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="0b8b0-119">由于运行时通过为指针添加值来为对象分配内存，所以这几乎和从堆栈中分配内存一样快。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-119">Because the runtime allocates memory for an object by adding a value to a pointer, it is almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="0b8b0-120">另外，由于连续分配的新对象在托管堆中是连续存储，所以应用程序可以快速访问这些对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-120">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects very quickly.</span></span>  
  
<a name="cpconautomaticmemorymanagementreleasingmemoryanchor1"></a>

## <a name="releasing-memory"></a><span data-ttu-id="0b8b0-121">释放内存</span><span class="sxs-lookup"><span data-stu-id="0b8b0-121">Releasing Memory</span></span>  

 <span data-ttu-id="0b8b0-122">垃圾回收器的优化引擎根据所执行的分配决定执行回收的最佳时间。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-122">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="0b8b0-123">垃圾回收器在执行回收时，会释放应用程序不再使用的对象的内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-123">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="0b8b0-124">它通过检查应用程序的根来确定不再使用的对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-124">It determines which objects are no longer being used by examining the application's roots.</span></span> <span data-ttu-id="0b8b0-125">每个应用程序都有一组根。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-125">Every application has a set of roots.</span></span> <span data-ttu-id="0b8b0-126">每个根或者引用托管堆中的对象，或者设置为空。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-126">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="0b8b0-127">应用程序的根包含线程堆栈上的静态字段、局部变量和参数以及 CPU 寄存器。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-127">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="0b8b0-128">垃圾回收器可以访问由[实时 (JIT) 编译器](managed-execution-process.md)和运行时维护的活动根的列表。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-128">The garbage collector has access to the list of active roots that the [just-in-time (JIT) compiler](managed-execution-process.md) and the runtime maintain.</span></span> <span data-ttu-id="0b8b0-129">垃圾回收器对照此列表检查应用程序的根，并在此过程中创建一个图表，在其中包含所有可从这些根中访问的对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-129">Using this list, it examines an application's roots, and in the process creates a graph that contains all the objects that are reachable from the roots.</span></span>  
  
 <span data-ttu-id="0b8b0-130">不在该图表中的对象将无法从应用程序的根中访问。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-130">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="0b8b0-131">垃圾回收器会考虑无法访问的对象垃圾，并释放为它们分配的内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-131">The garbage collector considers unreachable objects garbage and will release the memory allocated for them.</span></span> <span data-ttu-id="0b8b0-132">在回收中，垃圾回收器检查托管堆，查找无法访问对象所占据的地址空间块。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-132">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="0b8b0-133">发现无法访问的对象时，它就使用内存复制功能来压缩内存中可以访问的对象，释放分配给不可访问对象的地址空间块。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-133">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="0b8b0-134">在压缩了可访问对象的内存后，垃圾回收器就会做出必要的指针更正，以便应用程序的根指向新地址中的对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-134">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="0b8b0-135">它还将托管堆指针定位至最后一个可访问对象之后。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-135">It also positions the managed heap's pointer after the last reachable object.</span></span> <span data-ttu-id="0b8b0-136">请注意，只有在回收发现大量的无法访问的对象时，才会压缩内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-136">Note that memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="0b8b0-137">如果托管堆中的所有对象均未被回收，则不需要压缩内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-137">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>  
  
 <span data-ttu-id="0b8b0-138">为了改进性能，运行时为单独堆中的大型对象分配内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-138">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="0b8b0-139">垃圾回收器会自动释放大型对象的内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-139">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="0b8b0-140">但是，为了避免移动内存中的大型对象，不会压缩此内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-140">However, to avoid moving large objects in memory, this memory is not compacted.</span></span>  
  
## <a name="generations-and-performance"></a><span data-ttu-id="0b8b0-141">级别和性能</span><span class="sxs-lookup"><span data-stu-id="0b8b0-141">Generations and Performance</span></span>  

 <span data-ttu-id="0b8b0-142">为优化垃圾回收器的性能，将托管堆分为三代：第 0 代、第 1 代和第 2 代。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-142">To optimize the performance of the garbage collector, the managed heap is divided into three generations: 0, 1, and 2.</span></span> <span data-ttu-id="0b8b0-143">运行时的垃圾回收算法基于以下几个普遍原理，这些垃圾回收方案的原理已在计算机软件业通过实验得到了证实。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-143">The runtime's garbage collection algorithm is based on several generalizations that the computer software industry has discovered to be true by experimenting with garbage collection schemes.</span></span> <span data-ttu-id="0b8b0-144">首先，压缩托管堆的一部分内存要比压缩整个托管堆速度快。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-144">First, it is faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span> <span data-ttu-id="0b8b0-145">其次，较新的对象生存期较短，而较旧的对象生存期则较长。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-145">Secondly, newer objects will have shorter lifetimes and older objects will have longer lifetimes.</span></span> <span data-ttu-id="0b8b0-146">最后，较新的对象趋向于相互关联，并且大致同时由应用程序访问。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-146">Lastly, newer objects tend to be related to each other and accessed by the application around the same time.</span></span>  
  
 <span data-ttu-id="0b8b0-147">运行时的垃圾回收器将新对象存储在第 0 级中。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-147">The runtime's garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="0b8b0-148">在应用程序生存期的早期创建的对象如果未被回收，则被升级并存储在第 1 级和第 2 级中。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-148">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="0b8b0-149">本主题中稍后介绍了对象升级过程。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-149">The process of object promotion is described later in this topic.</span></span> <span data-ttu-id="0b8b0-150">因为压缩托管堆的一部分要比压缩整个托管堆速度快，所以此方案允许垃圾回收器在每次执行回收时释放特定级别的内存，而不是整个托管堆的内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-150">Because it is faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>  
  
 <span data-ttu-id="0b8b0-151">实际上，垃圾回收器在第 0 级托管堆已满时执行回收。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-151">In reality, the garbage collector performs a collection when generation 0 is full.</span></span> <span data-ttu-id="0b8b0-152">如果应用程序在第 0 级托管堆已满时尝试新建对象，垃圾回收器将会发现第 0 级托管堆中没有可分配给该对象的剩余地址空间。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-152">If an application attempts to create a new object when generation 0 is full, the garbage collector discovers that there is no address space remaining in generation 0 to allocate for the object.</span></span> <span data-ttu-id="0b8b0-153">垃圾回收器执行回收，尝试为对象释放第 0 级托管堆中的地址空间。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-153">The garbage collector performs a collection in an attempt to free address space in generation 0 for the object.</span></span> <span data-ttu-id="0b8b0-154">垃圾回收器从检查第 0 级托管堆中的对象（而不是托管堆中的所有对象）开始执行回收。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-154">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="0b8b0-155">这是最有效的途径，因为新对象的生存期往往较短，并且期望在执行回收时，应用程序不再使用第 0 级托管堆中的许多对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-155">This is the most efficient approach, because new objects tend to have short lifetimes, and it is expected that many of the objects in generation 0 will no longer be in use by the application when a collection is performed.</span></span> <span data-ttu-id="0b8b0-156">另外，单独回收第 0 级托管堆通常可以回收足够的内存，这样，应用程序便可以继续创建新对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-156">In addition, a collection of generation 0 alone often reclaims enough memory to allow the application to continue creating new objects.</span></span>  
  
 <span data-ttu-id="0b8b0-157">垃圾回收器执行第 0 级托管堆的回收后，会压缩可访问对象的内存，如本主题前面的[释放内存](#cpconautomaticmemorymanagementreleasingmemoryanchor1)中所述。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-157">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects as explained in [Releasing Memory](#cpconautomaticmemorymanagementreleasingmemoryanchor1) earlier in this topic.</span></span> <span data-ttu-id="0b8b0-158">然后，垃圾回收器升级这些对象，并考虑第 1 级托管堆的这一部分。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-158">The garbage collector then promotes these objects and considers this portion of the managed heap generation 1.</span></span> <span data-ttu-id="0b8b0-159">因为未被回收的对象往往具有较长的生存期，所以将它们升级至更高的级别很有意义。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-159">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="0b8b0-160">因此，垃圾回收器在每次执行第 0 级托管堆的回收时，不必重新检查第 1 级和第 2 级托管堆中的对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-160">As a result, the garbage collector does not have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>  
  
 <span data-ttu-id="0b8b0-161">在执行第 0 级托管堆的首次回收并把可访问的对象升级至第 1 级托管堆后，垃圾回收器将考虑第 0 级托管堆的其余部分。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-161">After the garbage collector performs its first collection of generation 0 and promotes the reachable objects to generation 1, it considers the remainder of the managed heap generation 0.</span></span> <span data-ttu-id="0b8b0-162">它将继续为第 0 级托管堆中的新对象分配内存，直至第 0 级托管堆已满并需执行另一回收为止。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-162">It continues to allocate memory for new objects in generation 0 until generation 0 is full and it is necessary to perform another collection.</span></span> <span data-ttu-id="0b8b0-163">这时，垃圾回收器的优化引擎会决定是否需要检查较旧的级别中的对象。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-163">At this point, the garbage collector's optimizing engine determines whether it is necessary to examine the objects in older generations.</span></span> <span data-ttu-id="0b8b0-164">例如，如果第 0 级托管堆的回收没有回收足够的内存，不能使应用程序成功完成创建新对象的尝试，垃圾回收器就会先执行第 1 级托管堆的回收，然后再执行第 2 级托管堆的回收。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-164">For example, if a collection of generation 0 does not reclaim enough memory for the application to successfully complete its attempt to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="0b8b0-165">如果这样仍不能回收足够的内存，垃圾回收器将执行第 2、1 和 0 级托管堆的回收。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-165">If this does not reclaim enough memory, the garbage collector can perform a collection of generations 2, 1, and 0.</span></span> <span data-ttu-id="0b8b0-166">每次回收后，垃圾回收器都会压缩第 0 级托管堆中的可访问对象并将它们升级至第 1 级托管堆。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-166">After each collection, the garbage collector compacts the reachable objects in generation 0 and promotes them to generation 1.</span></span> <span data-ttu-id="0b8b0-167">第 1 级托管堆中未被回收的对象将会升级至第 2 级托管堆。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-167">Objects in generation 1 that survive collections are promoted to generation 2.</span></span> <span data-ttu-id="0b8b0-168">由于垃圾回收器只支持三个级别，因此第 2 级托管堆中未被回收的对象会继续保留在第 2 级托管堆中，直到在将来的回收中确定它们为无法访问为止。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-168">Because the garbage collector supports only three generations, objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>  
  
## <a name="releasing-memory-for-unmanaged-resources"></a><span data-ttu-id="0b8b0-169">为非托管资源释放内存</span><span class="sxs-lookup"><span data-stu-id="0b8b0-169">Releasing Memory for Unmanaged Resources</span></span>  

 <span data-ttu-id="0b8b0-170">对于应用程序创建的大多数对象，可以依赖垃圾回收器自动执行必要的内存管理任务。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-170">For the majority of the objects that your application creates, you can rely on the garbage collector to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="0b8b0-171">但是，非托管资源需要显式清除。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-171">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="0b8b0-172">最常用的非托管资源类型是包装操作系统资源的对象，例如，文件句柄、窗口句柄或网络连接。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-172">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="0b8b0-173">虽然垃圾回收器可以跟踪封装非托管资源的托管对象的生存期，但却无法具体了解如何清理资源。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-173">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it does not have specific knowledge about how to clean up the resource.</span></span> <span data-ttu-id="0b8b0-174">创建封装非托管资源的对象时，建议在公共 **Dispose** 方法中提供必要的代码以清理非托管资源。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-174">When you create an object that encapsulates an unmanaged resource, it is recommended that you provide the necessary code to clean up the unmanaged resource in a public **Dispose** method.</span></span> <span data-ttu-id="0b8b0-175">通过提供 **Dispose** 方法，对象的用户可以在使用完对象后显式释放其内存。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-175">By providing a **Dispose** method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="0b8b0-176">使用封装非托管资源的对象时，应该了解 **Dispose** 并在必要时调用它。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-176">When you use an object that encapsulates an unmanaged resource, you should be aware of **Dispose** and call it as necessary.</span></span> <span data-ttu-id="0b8b0-177">有关清理非托管资源的详细信息和实现 **Dispose** 的设计模式示例，请参见 [垃圾回收](garbage-collection/index.md)。</span><span class="sxs-lookup"><span data-stu-id="0b8b0-177">For more information about cleaning up unmanaged resources and an example of a design pattern for implementing **Dispose**, see [Garbage Collection](garbage-collection/index.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0b8b0-178">请参阅</span><span class="sxs-lookup"><span data-stu-id="0b8b0-178">See also</span></span>

- <xref:System.GC>
- [<span data-ttu-id="0b8b0-179">垃圾回收</span><span class="sxs-lookup"><span data-stu-id="0b8b0-179">Garbage Collection</span></span>](garbage-collection/index.md)
- [<span data-ttu-id="0b8b0-180">托管执行过程</span><span class="sxs-lookup"><span data-stu-id="0b8b0-180">Managed Execution Process</span></span>](managed-execution-process.md)
