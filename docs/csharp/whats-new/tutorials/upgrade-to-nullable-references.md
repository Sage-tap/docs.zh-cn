---
title: 升级为可为 null 的引用类型
description: 本高级教程演示如何使用可为 null 的引用类型迁移现有代码。
ms.date: 02/19/2019
ms.technology: csharp-null-safety
ms.custom: mvc
ms.openlocfilehash: dc254e8ca7b9451ab9374bc1ec650b8eaa9da861
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/23/2021
ms.locfileid: "104878883"
---
# <a name="tutorial-migrate-existing-code-with-nullable-reference-types"></a><span data-ttu-id="f4d72-103">教程：使用可为空引用类型迁移现有代码</span><span class="sxs-lookup"><span data-stu-id="f4d72-103">Tutorial: Migrate existing code with nullable reference types</span></span>

<span data-ttu-id="f4d72-104">C# 8 引入了可为空引用类型，它们以与可为空值类型补充值类型相同的方式补充引用类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-104">C# 8 introduces **nullable reference types**, which complement reference types the same way nullable value types complement value types.</span></span> <span data-ttu-id="f4d72-105">通过将 `?` 追加到此类型，你可以将变量声明为  可为空引用类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-105">You declare a variable to be a **nullable reference type** by appending a `?` to the type.</span></span> <span data-ttu-id="f4d72-106">例如，`string?` 表示可为空的 `string`。</span><span class="sxs-lookup"><span data-stu-id="f4d72-106">For example, `string?` represents a nullable `string`.</span></span> <span data-ttu-id="f4d72-107">可以使用这些新类型更清楚地表达你的设计意图：某些变量  必须始终具有值，其他变量可以缺少值  。</span><span class="sxs-lookup"><span data-stu-id="f4d72-107">You can use these new types to more clearly express your design intent: some variables *must always have a value*, others *may be missing a value*.</span></span> <span data-ttu-id="f4d72-108">引用类型的任何现有变量都将被解释为不可为空引用类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-108">Any existing variables of a reference type would be interpreted as a non-nullable reference type.</span></span>

<span data-ttu-id="f4d72-109">本教程介绍以下操作：</span><span class="sxs-lookup"><span data-stu-id="f4d72-109">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="f4d72-110">使用代码时启用空引用检查。</span><span class="sxs-lookup"><span data-stu-id="f4d72-110">Enable null reference checks as you work with code.</span></span>
> - <span data-ttu-id="f4d72-111">诊断并更正与 Null 值相关的其他警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-111">Diagnose and correct different warnings related to null values.</span></span>
> - <span data-ttu-id="f4d72-112">管理可为空启用上下文和可为空禁用上下文之间的接口。</span><span class="sxs-lookup"><span data-stu-id="f4d72-112">Manage the interface between nullable enabled and nullable disabled contexts.</span></span>
> - <span data-ttu-id="f4d72-113">控制可为空的批注上下文。</span><span class="sxs-lookup"><span data-stu-id="f4d72-113">Control nullable annotation contexts.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="f4d72-114">先决条件</span><span class="sxs-lookup"><span data-stu-id="f4d72-114">Prerequisites</span></span>

<span data-ttu-id="f4d72-115">需要将计算机设置为运行 .NET Core，包括 C# 8.0 编译器。</span><span class="sxs-lookup"><span data-stu-id="f4d72-115">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="f4d72-116">自 [Visual Studio 2019 版本 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) 或 [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download) 起，开始随附 C# 8 编译器。</span><span class="sxs-lookup"><span data-stu-id="f4d72-116">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="f4d72-117">本教程假设你熟悉 C# 和 .NET，包括 Visual Studio 或 .NET Core CLI。</span><span class="sxs-lookup"><span data-stu-id="f4d72-117">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="explore-the-sample-application"></a><span data-ttu-id="f4d72-118">浏览示例应用程序</span><span class="sxs-lookup"><span data-stu-id="f4d72-118">Explore the sample application</span></span>

<span data-ttu-id="f4d72-119">即将迁移的示例应用程序是一个 RSS 源阅读器 Web 应用。</span><span class="sxs-lookup"><span data-stu-id="f4d72-119">The sample application that you'll migrate is an RSS feed reader web app.</span></span> <span data-ttu-id="f4d72-120">它从单个 RSS 源中进行读取并显示最新文章的摘要。</span><span class="sxs-lookup"><span data-stu-id="f4d72-120">It reads from a single RSS feed and displays summaries for the most recent articles.</span></span> <span data-ttu-id="f4d72-121">可以选择任何文章以访问网站。</span><span class="sxs-lookup"><span data-stu-id="f4d72-121">You can select any of the articles to visit the site.</span></span> <span data-ttu-id="f4d72-122">应用程序相对较新，但却是在可以使用可为空引用类型前编写的。</span><span class="sxs-lookup"><span data-stu-id="f4d72-122">The application is relatively new but was written before nullable reference types were available.</span></span> <span data-ttu-id="f4d72-123">应用程序的设计决策代表了合理的原则，但没有利用这一重要的语言功能。</span><span class="sxs-lookup"><span data-stu-id="f4d72-123">The design decisions for the application represented sound principles, but don't take advantage of this important language feature.</span></span>

<span data-ttu-id="f4d72-124">示例应用程序包括验证应用主要功能的单元测试库。</span><span class="sxs-lookup"><span data-stu-id="f4d72-124">The sample application includes a unit test library that validates the major functionality of the app.</span></span> <span data-ttu-id="f4d72-125">如果根据生成的警告更改任何实现，该项目将使安全升级变得更容易。</span><span class="sxs-lookup"><span data-stu-id="f4d72-125">That project will make it easier to upgrade safely, if you change any of the implementation based on the warnings generated.</span></span> <span data-ttu-id="f4d72-126">若要下载起始代码，可以访问 [dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/start) GitHub 存储库。</span><span class="sxs-lookup"><span data-stu-id="f4d72-126">You can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/start) GitHub repository.</span></span>

<span data-ttu-id="f4d72-127">迁移项目的目标应该是利用新的语言功能，以便清楚地表达对变量的为 Null 性的意图，并以如下特定方式执行此操作，即在将可为空注释上下文和可为空警告上下文设置为 `enabled` 时，编译器不会生成警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-127">Your goal migrating a project should be to leverage the new language features so that you clearly express your intent on the nullability of variables, and do so in such a way that the compiler doesn't generate warnings when you have the nullable annotation context and nullable warning context set to `enabled`.</span></span>

## <a name="upgrade-the-projects-to-c-8"></a><span data-ttu-id="f4d72-128">将项目升级到 C#8</span><span class="sxs-lookup"><span data-stu-id="f4d72-128">Upgrade the projects to C# 8</span></span>

<span data-ttu-id="f4d72-129">第一步建议确定迁移任务的范围。</span><span class="sxs-lookup"><span data-stu-id="f4d72-129">A good first step is to determine the scope of the migration task.</span></span> <span data-ttu-id="f4d72-130">首先将项目升级到 C# 8.0（或更高版本）。</span><span class="sxs-lookup"><span data-stu-id="f4d72-130">Start by upgrading the project to C# 8.0 (or newer).</span></span> <span data-ttu-id="f4d72-131">将 `LangVersion` 元素同时添加到 Web 项目和单元测试项目的 csproj 文件中的 PropertyGroup：</span><span class="sxs-lookup"><span data-stu-id="f4d72-131">Add the `LangVersion` element to the PropertyGroup in both csproj files for the web project and the unit test project:</span></span>

```xml
<LangVersion>8.0</LangVersion>
```

<span data-ttu-id="f4d72-132">升级语言版本选择 C# 8.0，但不启用可为空注释上下文或可为空警告上下文。</span><span class="sxs-lookup"><span data-stu-id="f4d72-132">Upgrading the language version selects C# 8.0, but does not enable the nullable annotation context or the nullable warning context.</span></span> <span data-ttu-id="f4d72-133">重新生成项目，以确保在没有警告的情况下进行生成。</span><span class="sxs-lookup"><span data-stu-id="f4d72-133">Rebuild the project to ensure that it builds without warnings.</span></span>

<span data-ttu-id="f4d72-134">下一步建议打开可为空注释上下文，看看生成了多少警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-134">A good next step is to turn on the nullable annotation context and see how many warnings are generated.</span></span> <span data-ttu-id="f4d72-135">在解决方案中的两个 csproj 文件中（直接在 `LangVersion` 元素下面）添加以下元素：</span><span class="sxs-lookup"><span data-stu-id="f4d72-135">Add the following element to both csproj files in the solution, directly under the `LangVersion` element:</span></span>

```xml
<Nullable>enable</Nullable>
```

<span data-ttu-id="f4d72-136">执行测试生成，并注意警告列表。</span><span class="sxs-lookup"><span data-stu-id="f4d72-136">Do a test build, and notice the warning list.</span></span> <span data-ttu-id="f4d72-137">在此小型应用程序中，编译器将生成五个警告，因此可能会启用可为空注释上下文，并开始为整个项目修复警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-137">In this small application, the compiler generates five warnings, so it's likely you'd leave the nullable annotation context enabled and start fixing warnings for the entire project.</span></span>

<span data-ttu-id="f4d72-138">该策略仅适用于较小的项目。</span><span class="sxs-lookup"><span data-stu-id="f4d72-138">That strategy works only for smaller projects.</span></span> <span data-ttu-id="f4d72-139">对于任何大型项目，通过为整个代码库启用可为空注释上下文而生成的警告数使得以系统方式修复警告变得更加困难。</span><span class="sxs-lookup"><span data-stu-id="f4d72-139">For any larger projects, the number of warnings generated by enabling the nullable annotation context for the entire codebase makes it harder to fix the warnings systematically.</span></span> <span data-ttu-id="f4d72-140">对于大型企业项目，通常希望一次迁移一个项目。</span><span class="sxs-lookup"><span data-stu-id="f4d72-140">For larger enterprise projects, you'll often want to migrate one project at a time.</span></span> <span data-ttu-id="f4d72-141">在每个项目中，一次迁移一个类或文件。</span><span class="sxs-lookup"><span data-stu-id="f4d72-141">In each project, migrate one class or file at a time.</span></span>

## <a name="warnings-help-discover-original-design-intent"></a><span data-ttu-id="f4d72-142">警告有助于发现原始设计意图</span><span class="sxs-lookup"><span data-stu-id="f4d72-142">Warnings help discover original design intent</span></span>

<span data-ttu-id="f4d72-143">有两个类生成多个警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-143">There are two classes that generate multiple warnings.</span></span> <span data-ttu-id="f4d72-144">从 `NewsStoryViewModel` 类开始。</span><span class="sxs-lookup"><span data-stu-id="f4d72-144">Start with the `NewsStoryViewModel` class.</span></span> <span data-ttu-id="f4d72-145">从两个 csproj 文件中删除 `Nullable` 元素，以便将警告范围限制为正在处理的代码部分。</span><span class="sxs-lookup"><span data-stu-id="f4d72-145">Remove the `Nullable` element from both csproj files so that you can limit the scope of warnings to the sections of code you're working with.</span></span> <span data-ttu-id="f4d72-146">打开 NewsStoryViewModel.cs 文件并添加下列指令，以启用 `NewsStoryViewModel` 的可为空注释上下文，并按照类定义对其进行还原：</span><span class="sxs-lookup"><span data-stu-id="f4d72-146">Open the *NewsStoryViewModel.cs* file and add the following directives to enable the nullable annotation context for the `NewsStoryViewModel` and restore it following that class definition:</span></span>

```csharp
#nullable enable
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; }
    public string Uri { get; set; }
}
#nullable restore
```

<span data-ttu-id="f4d72-147">这两条指令可帮助你专注于迁移工作。</span><span class="sxs-lookup"><span data-stu-id="f4d72-147">These two directives help you focus your migration efforts.</span></span> <span data-ttu-id="f4d72-148">为你正在积极处理的代码区域生成可为空警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-148">The nullable warnings are generated for the area of code you're actively working on.</span></span> <span data-ttu-id="f4d72-149">在做好准备为整个项目启用警告之前，将一直保留这些警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-149">You'll leave them on until you're ready to turn on the warnings for the entire project.</span></span> <span data-ttu-id="f4d72-150">应使用 `restore` 而不是 `disable` 值，以便在稍后为整个项目启用可为空注释时不会意外禁用上下文。</span><span class="sxs-lookup"><span data-stu-id="f4d72-150">You should use the `restore` rather than `disable` value so that you don't accidentally disable the context later when you've turned on nullable annotations for the entire project.</span></span> <span data-ttu-id="f4d72-151">一旦为整个项目启用了可为空注释上下文，就可以从该项目中删除所有 `#nullable` 杂注。</span><span class="sxs-lookup"><span data-stu-id="f4d72-151">Once you've turned on the nullable annotation context for the entire project, you can remove all the `#nullable` pragmas from that project.</span></span>

<span data-ttu-id="f4d72-152">`NewsStoryViewModel` 类是一个数据传输对象 (DTO)，其中两个属性是读/写字符串：</span><span class="sxs-lookup"><span data-stu-id="f4d72-152">The `NewsStoryViewModel` class is a data transfer object (DTO) and two of the properties are read/write strings:</span></span>

[!code-csharp[InitialViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#StarterViewModel)]

<span data-ttu-id="f4d72-153">这两个属性导致 `CS8618`，“不可为空属性未初始化”。</span><span class="sxs-lookup"><span data-stu-id="f4d72-153">These two properties cause `CS8618`, "Non-nullable property is uninitialized".</span></span> <span data-ttu-id="f4d72-154">这很清楚：在构造 `NewsStoryViewModel` 时，两个 `string` 属性的默认值都是 `null`。</span><span class="sxs-lookup"><span data-stu-id="f4d72-154">That's clear enough: both `string` properties have the default value of `null` when a `NewsStoryViewModel` is constructed.</span></span> <span data-ttu-id="f4d72-155">重要的是了解 `NewsStoryViewModel` 对象是如何构造的。</span><span class="sxs-lookup"><span data-stu-id="f4d72-155">What's important to discover is how `NewsStoryViewModel` objects are constructed.</span></span> <span data-ttu-id="f4d72-156">查看此类时，无法判断 `null` 值是否是设计的一部分，或者这些对象在创建时是否被设置为非 Null 值。</span><span class="sxs-lookup"><span data-stu-id="f4d72-156">Looking at this class, you can't tell if the `null` value is part of the design, or if these objects are set to non-null values whenever one is created.</span></span> <span data-ttu-id="f4d72-157">新闻故事在 `NewsService` 类的 `GetNews` 方法中创建：</span><span class="sxs-lookup"><span data-stu-id="f4d72-157">The news stories are created in the `GetNews` method of the `NewsService` class:</span></span>

[!code-csharp[StarterCreateNewsItem](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#CreateNewsItem)]

<span data-ttu-id="f4d72-158">前面的代码块中有相当多的内容。</span><span class="sxs-lookup"><span data-stu-id="f4d72-158">There's quite a bit going on in the preceding block of code.</span></span> <span data-ttu-id="f4d72-159">此应用程序使用 [AutoMapper](https://automapper.org/) NuGet 包从 `ISyndicationItem` 中构造新闻项。</span><span class="sxs-lookup"><span data-stu-id="f4d72-159">This application uses the [AutoMapper](https://automapper.org/) NuGet package to construct a news item from an `ISyndicationItem`.</span></span> <span data-ttu-id="f4d72-160">你会发现，在这一条语句中构造了新闻故事项，并设置了属性。</span><span class="sxs-lookup"><span data-stu-id="f4d72-160">You've discovered that the news story items are constructed and the properties are set in that one statement.</span></span> <span data-ttu-id="f4d72-161">这意味着 `NewsStoryViewModel` 的设计表明这些属性绝不应该有 `null` 值。</span><span class="sxs-lookup"><span data-stu-id="f4d72-161">That means the design for the `NewsStoryViewModel` indicates that these properties should never have the `null` value.</span></span> <span data-ttu-id="f4d72-162">这些属性应是不可为空引用类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-162">These properties should be **nonnullable reference types**.</span></span> <span data-ttu-id="f4d72-163">这样可以充分表达原始设计意图。</span><span class="sxs-lookup"><span data-stu-id="f4d72-163">That best expresses the original design intent.</span></span> <span data-ttu-id="f4d72-164">实际上，任何  都是`NewsStoryViewModel` 用非 Null 值正确实例化的。</span><span class="sxs-lookup"><span data-stu-id="f4d72-164">In fact, any `NewsStoryViewModel` *is* correctly instantiated with non-null values.</span></span> <span data-ttu-id="f4d72-165">这使得以下初始化代码成为一个有效的修复程序：</span><span class="sxs-lookup"><span data-stu-id="f4d72-165">That makes the following initialization code a valid fix:</span></span>

```csharp
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; } = default!;
    public string Uri { get; set; } = default!;
}
```

<span data-ttu-id="f4d72-166">`Title` 和 `Uri` 赋值为 `default`（`string` 类型为 `null`）不会更改程序的运行时行为。</span><span class="sxs-lookup"><span data-stu-id="f4d72-166">The assignment of `Title` and `Uri` to `default` which is `null` for the `string` type doesn't change the runtime behavior of the program.</span></span> <span data-ttu-id="f4d72-167">`NewsStoryViewModel` 仍然用 Null 值构造，但现在编译器不会报告任何警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-167">The `NewsStoryViewModel` is still constructed with null values, but now the compiler reports no warnings.</span></span> <span data-ttu-id="f4d72-168">Null 包容运算符，`default` 表达式后面的 `!` 字符指示编译器前面的表达式不为 Null。</span><span class="sxs-lookup"><span data-stu-id="f4d72-168">The **null-forgiving operator**, the `!` character following the `default` expression tells the compiler that the preceding expression is not null.</span></span> <span data-ttu-id="f4d72-169">当其他更改强制对代码库进行更大的更改时，这种方法可能会很方便，但在此应用程序中，有一个相对快速且更好的解决方案：使 `NewsStoryViewModel` 为不可变类型，其中所有属性均在构造函数中设置。</span><span class="sxs-lookup"><span data-stu-id="f4d72-169">This technique may be expedient when other changes force much larger changes to a code base, but in this application there is a relatively quick and better solution: Make the `NewsStoryViewModel` an immutable type where all the properties are set in the constructor.</span></span> <span data-ttu-id="f4d72-170">对 `NewsStoryViewModel` 进行以下更改：</span><span class="sxs-lookup"><span data-stu-id="f4d72-170">Make the following changes to the `NewsStoryViewModel`:</span></span>

[!code-csharp[FinishedViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#FinishedViewModel)]

<span data-ttu-id="f4d72-171">完成更改之后，需要更新配置 AutoMapper 的代码，以便它使用构造函数而不是设置属性。</span><span class="sxs-lookup"><span data-stu-id="f4d72-171">Once that's done, you need to update the code that configures the AutoMapper so that it uses the constructor rather than setting properties.</span></span> <span data-ttu-id="f4d72-172">打开 `NewsService.cs`，在文件底部查找以下代码：</span><span class="sxs-lookup"><span data-stu-id="f4d72-172">Open `NewsService.cs` and look for the following code at the bottom of the file:</span></span>

[!code-csharp[StarterAutoMapper](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="f4d72-173">该代码将 `ISyndicationItem` 对象的属性映射到 `NewsStoryViewModel` 属性。</span><span class="sxs-lookup"><span data-stu-id="f4d72-173">That code maps properties of the `ISyndicationItem` object to the `NewsStoryViewModel` properties.</span></span> <span data-ttu-id="f4d72-174">希望 AutoMapper 改用构造函数来提供映射。</span><span class="sxs-lookup"><span data-stu-id="f4d72-174">You want the AutoMapper to provide the mapping using a constructor instead.</span></span> <span data-ttu-id="f4d72-175">请用以下 automapper 配置替换上面的代码：</span><span class="sxs-lookup"><span data-stu-id="f4d72-175">Replace the above code with the following automapper configuration:</span></span>

[!code-csharp[FinishedViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="f4d72-176">注意，因为此类很小，而且你已经仔细检查过，所以应打开此类声明上面的 `#nullable enable` 指令。</span><span class="sxs-lookup"><span data-stu-id="f4d72-176">Notice that because this class is small, and you've examined carefully, you should turn on the `#nullable enable` directive above this class declaration.</span></span> <span data-ttu-id="f4d72-177">对构造函数的更改可能会破坏某些内容，因此有必要在继续之前运行所有测试并测试应用程序。</span><span class="sxs-lookup"><span data-stu-id="f4d72-177">The change to the constructor could have broken something, so it's worthwhile to run all the tests and test the application before moving on.</span></span>

<span data-ttu-id="f4d72-178">第一组更改展示了如何发现原始设计指示不应该将变量设置为 `null`。</span><span class="sxs-lookup"><span data-stu-id="f4d72-178">The first set of changes showed you how to discover when the original design indicated that variables shouldn't be set to `null`.</span></span> <span data-ttu-id="f4d72-179">该方法称为“通过构造更正”。</span><span class="sxs-lookup"><span data-stu-id="f4d72-179">The technique is referred to as **correct by construction**.</span></span> <span data-ttu-id="f4d72-180">在构造对象时，声明该对象及其属性不能为 `null`。</span><span class="sxs-lookup"><span data-stu-id="f4d72-180">You declare that an object and its properties cannot be `null` when it's constructed.</span></span> <span data-ttu-id="f4d72-181">编译器的流分析确保这些属性在构造之后不会被设置为 `null`。</span><span class="sxs-lookup"><span data-stu-id="f4d72-181">The compiler's flow analysis provides assurance that those properties aren't set to `null` after construction.</span></span> <span data-ttu-id="f4d72-182">注意，此构造函数由外部代码调用，而该代码无论是否可为空都能进行调用。</span><span class="sxs-lookup"><span data-stu-id="f4d72-182">Note that this constructor is called by external code, and that code is **nullable oblivious**.</span></span> <span data-ttu-id="f4d72-183">新语法不提供运行时检查。</span><span class="sxs-lookup"><span data-stu-id="f4d72-183">The new syntax doesn't provide runtime checking.</span></span> <span data-ttu-id="f4d72-184">外部代码可能会避开编译器的流分析。</span><span class="sxs-lookup"><span data-stu-id="f4d72-184">External code might circumvent the compiler's flow analysis.</span></span>

<span data-ttu-id="f4d72-185">其他情况下，类的结构提供了意图的不同线索。</span><span class="sxs-lookup"><span data-stu-id="f4d72-185">Other times, the structure of a class provides different clues to the intent.</span></span> <span data-ttu-id="f4d72-186">打开“Pages”文件夹中的“Error.cshtml.cs”文件。</span><span class="sxs-lookup"><span data-stu-id="f4d72-186">Open the *Error.cshtml.cs* file in the *Pages* folder.</span></span> <span data-ttu-id="f4d72-187">`ErrorViewModel` 包含以下代码：</span><span class="sxs-lookup"><span data-stu-id="f4d72-187">The `ErrorViewModel` contains the following code:</span></span>

[!code-csharp[StarterErrorModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Error.cshtml.cs#StartErrorModel)]

<span data-ttu-id="f4d72-188">在类声明之前添加 `#nullable enable` 指令，在类声明之后添加 `#nullable restore` 指令。</span><span class="sxs-lookup"><span data-stu-id="f4d72-188">Add the `#nullable enable` directive before the class declaration, and a `#nullable restore` directive after it.</span></span> <span data-ttu-id="f4d72-189">会出现一个警告，指示 `RequestId` 未初始化。</span><span class="sxs-lookup"><span data-stu-id="f4d72-189">You'll get one warning that `RequestId` is not initialized.</span></span> <span data-ttu-id="f4d72-190">通过查看类，应确定在某些情况下 `RequestId` 属性应为 Null。</span><span class="sxs-lookup"><span data-stu-id="f4d72-190">By looking at the class, you should decide that the `RequestId` property should be null in some cases.</span></span> <span data-ttu-id="f4d72-191">`ShowRequestId` 属性的存在表明可能缺失某些值。</span><span class="sxs-lookup"><span data-stu-id="f4d72-191">The existence of the `ShowRequestId` property indicates that missing values are possible.</span></span> <span data-ttu-id="f4d72-192">因为 `null` 有效，所以在 `string` 类型上添加 `?` 表示 `RequestId` 属性是可为空引用类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-192">Because `null` is valid, add the `?` on the `string` type to indicate the `RequestId` property is a *nullable reference type*.</span></span> <span data-ttu-id="f4d72-193">最终类如下所示：</span><span class="sxs-lookup"><span data-stu-id="f4d72-193">The final class looks like the following example:</span></span>

[!code-csharp[FinishedErrorModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Error.cshtml.cs#ErrorModel)]

<span data-ttu-id="f4d72-194">检查属性的使用情况，会看到在关联页中，在标记中呈现属性之前会检查其是否为 Null。</span><span class="sxs-lookup"><span data-stu-id="f4d72-194">Check for the uses of the property, and you see that in the associated page, the property is checked for null before rendering it in markup.</span></span> <span data-ttu-id="f4d72-195">这是可为空引用类型的安全使用，因此已完成此类的检查。</span><span class="sxs-lookup"><span data-stu-id="f4d72-195">That's a safe use of a nullable reference type, so you're done with this class.</span></span>

## <a name="fixing-nulls-causes-change"></a><span data-ttu-id="f4d72-196">修复 Null 会导致更改</span><span class="sxs-lookup"><span data-stu-id="f4d72-196">Fixing nulls causes change</span></span>

<span data-ttu-id="f4d72-197">通常情况下，修复一组警告会在相关代码中创建新的警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-197">Frequently, the fix for one set of warnings creates new warnings in related code.</span></span> <span data-ttu-id="f4d72-198">让我们通过修复 `index.cshtml.cs` 类来查看实际警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-198">Let's see the warnings in action by fixing the `index.cshtml.cs` class.</span></span> <span data-ttu-id="f4d72-199">打开 `index.cshtml.cs` 文件并检查代码。</span><span class="sxs-lookup"><span data-stu-id="f4d72-199">Open the `index.cshtml.cs` file and examine the code.</span></span> <span data-ttu-id="f4d72-200">此文件包含索引页的隐藏代码：</span><span class="sxs-lookup"><span data-stu-id="f4d72-200">This file contains the code behind for the index page:</span></span>

[!code-csharp[StarterIndexModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Index.cshtml.cs#IndexModelStart)]

<span data-ttu-id="f4d72-201">添加 `#nullable enable` 指令，将会看到两个警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-201">Add the `#nullable enable` directive and you'll see two warnings.</span></span> <span data-ttu-id="f4d72-202">`ErrorText` 属性和 `NewsItems` 属性都不会初始化。</span><span class="sxs-lookup"><span data-stu-id="f4d72-202">Neither the `ErrorText` property nor the `NewsItems` property is initialized.</span></span> <span data-ttu-id="f4d72-203">此类检查会让你认为这两个属性应为可为空引用类型：都具有专用的 setter。</span><span class="sxs-lookup"><span data-stu-id="f4d72-203">An examination of this class would lead you to believe that both properties should be nullable reference types: Both have private setters.</span></span> <span data-ttu-id="f4d72-204">在 `OnGet` 方法中正好分配了一个属性。</span><span class="sxs-lookup"><span data-stu-id="f4d72-204">Exactly one is assigned in the `OnGet` method.</span></span> <span data-ttu-id="f4d72-205">在更改之前，看看这两个属性的使用者。</span><span class="sxs-lookup"><span data-stu-id="f4d72-205">Before making changes, look at the consumers of both properties.</span></span> <span data-ttu-id="f4d72-206">在页面本身，在为任何错误生成标记之前，将检查 `ErrorText` 是否为 Null。</span><span class="sxs-lookup"><span data-stu-id="f4d72-206">In the page itself, the `ErrorText` is checked against null before generating markup for any errors.</span></span> <span data-ttu-id="f4d72-207">检查 `NewsItems` 集合是否为 `null`，并选中以确保集合具有项。</span><span class="sxs-lookup"><span data-stu-id="f4d72-207">The `NewsItems` collection is checked against `null`, and checked to ensure the collection has items.</span></span> <span data-ttu-id="f4d72-208">快速修复会使这两个属性成为可为空引用类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-208">A quick fix would be to make both properties nullable reference types.</span></span> <span data-ttu-id="f4d72-209">更好的解决方法是使集合成为不可为空引用类型，并在检索新闻时向现有集合添加项。</span><span class="sxs-lookup"><span data-stu-id="f4d72-209">A better fix would be to make the collection a nonnullable reference type, and add items to the existing collection when retrieving news.</span></span> <span data-ttu-id="f4d72-210">第一个解决方法是为 `ErrorText` 的 `string` 类型添加 `?`：</span><span class="sxs-lookup"><span data-stu-id="f4d72-210">The first fix is to add the `?` to the `string` type for the `ErrorText`:</span></span>

[!code-csharp[UpdateErrorText](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#UpdateErrorText)]

<span data-ttu-id="f4d72-211">此更改不会影响其他代码，因为对 `ErrorText` 属性的任何访问均已通过 Null 检查进行保护。</span><span class="sxs-lookup"><span data-stu-id="f4d72-211">That change won't ripple through other code, because any access to the `ErrorText` property was already guarded by null checks.</span></span> <span data-ttu-id="f4d72-212">接下来，初始化 `NewsItems` 列表并删除属性资源库，使其成为只读属性：</span><span class="sxs-lookup"><span data-stu-id="f4d72-212">Next, initialize the `NewsItems` list and remove the property setter, making it a readonly property:</span></span>

[!code-csharp[InitializeNewsItems](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#InitializeNewsItems)]

<span data-ttu-id="f4d72-213">这修复了警告，但引入了错误。</span><span class="sxs-lookup"><span data-stu-id="f4d72-213">That fixed the warning but introduced an error.</span></span> <span data-ttu-id="f4d72-214">`NewsItems` 列表现在是“通过构造更正，但在 `OnGet` 中设置列表的代码必须更改以匹配新的 API。</span><span class="sxs-lookup"><span data-stu-id="f4d72-214">The `NewsItems` list is now **correct by construction**, but the code that sets the list in `OnGet` must change to match the new API.</span></span> <span data-ttu-id="f4d72-215">调用 `AddRange` 将新闻项添加到现有列表，而不是赋值：</span><span class="sxs-lookup"><span data-stu-id="f4d72-215">Instead of an assignment, call `AddRange` to add the news items to the existing list:</span></span>

[!code-csharp[AddRange](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#AddRange)]

<span data-ttu-id="f4d72-216">使用 `AddRange` 而不是赋值意味着 `GetNews` 方法可以返回 `IEnumerable` 而不是 `List`。</span><span class="sxs-lookup"><span data-stu-id="f4d72-216">Using `AddRange` instead of an assignment means that the `GetNews` method can return an `IEnumerable` instead of a `List`.</span></span> <span data-ttu-id="f4d72-217">这节省了一次分配。</span><span class="sxs-lookup"><span data-stu-id="f4d72-217">That saves one allocation.</span></span> <span data-ttu-id="f4d72-218">更改方法的签名，并删除 `ToList` 调用，如下面的代码示例所示：</span><span class="sxs-lookup"><span data-stu-id="f4d72-218">Change the signature of the method, and remove the `ToList` call, as shown in the following code sample:</span></span>

[!code-csharp[GetNews](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#GetNewsFinished)]

<span data-ttu-id="f4d72-219">更改签名也会中断其中一个测试。</span><span class="sxs-lookup"><span data-stu-id="f4d72-219">Changing the signature breaks one of tests as well.</span></span> <span data-ttu-id="f4d72-220">打开 `SimpleFeedReader.Tests` 项目 `Services` 文件夹中的 `NewsServiceTests.cs` 文件。</span><span class="sxs-lookup"><span data-stu-id="f4d72-220">Open the `NewsServiceTests.cs` file in the `Services` folder of the `SimpleFeedReader.Tests` project.</span></span> <span data-ttu-id="f4d72-221">导航到 `Returns_News_Stories_Given_Valid_Uri` 测试并将 `result` 变量的类型更改为 `IEnumerable<NewsItem>`。</span><span class="sxs-lookup"><span data-stu-id="f4d72-221">Navigate to the `Returns_News_Stories_Given_Valid_Uri` test and change the type of the `result` variable to `IEnumerable<NewsItem>`.</span></span> <span data-ttu-id="f4d72-222">更改类型意味着 `Count` 属性不再可用，因此将 `Assert` 中的 `Count` 属性替换为对 `Any()` 的调用：</span><span class="sxs-lookup"><span data-stu-id="f4d72-222">Changing the type means the `Count` property is no longer available, so replace the `Count` property in the `Assert` with a call to `Any()`:</span></span>

[!code-csharp[FixTests](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader.Tests/Services/NewsServiceTests.cs#FixTestSignature)]

<span data-ttu-id="f4d72-223">还需要向文件开头添加一个 `using System.Linq` 语句。</span><span class="sxs-lookup"><span data-stu-id="f4d72-223">You'll need to add a `using System.Linq` statement to the beginning of the file as well.</span></span>

<span data-ttu-id="f4d72-224">这组更改强调了更新包含泛型实例化的代码时需要特别考虑的问题。</span><span class="sxs-lookup"><span data-stu-id="f4d72-224">This set of changes highlights special consideration when updating code that includes generic instantiations.</span></span> <span data-ttu-id="f4d72-225">列表和不可为空类型列表中的元素。</span><span class="sxs-lookup"><span data-stu-id="f4d72-225">Both the list and the elements in the list of non-nullable types.</span></span> <span data-ttu-id="f4d72-226">其中一个或两者可以是可为空类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-226">Either or both could be nullable types.</span></span> <span data-ttu-id="f4d72-227">允许所有以下声明：</span><span class="sxs-lookup"><span data-stu-id="f4d72-227">All the following declarations are allowed:</span></span>

- <span data-ttu-id="f4d72-228">`List<NewsStoryViewModel>`：不可为空视图模型的不可为空列表。</span><span class="sxs-lookup"><span data-stu-id="f4d72-228">`List<NewsStoryViewModel>`: nonnullable list of nonullable view models.</span></span>
- <span data-ttu-id="f4d72-229">`List<NewsStoryViewModel?>`：可为空视图模型的不可为空列表。</span><span class="sxs-lookup"><span data-stu-id="f4d72-229">`List<NewsStoryViewModel?>`: nonnullable list of nullable view models.</span></span>
- <span data-ttu-id="f4d72-230">`List<NewsStoryViewModel>?`：不可为空视图模型的可为空列表。</span><span class="sxs-lookup"><span data-stu-id="f4d72-230">`List<NewsStoryViewModel>?`: nullable list of nonnullable view models.</span></span>
- <span data-ttu-id="f4d72-231">`List<NewsStoryViewModel?>?`：可为空视图模型的可为空列表。</span><span class="sxs-lookup"><span data-stu-id="f4d72-231">`List<NewsStoryViewModel?>?`: nullable list of nullable view models.</span></span>

## <a name="interfaces-with-external-code"></a><span data-ttu-id="f4d72-232">使用外部代码的接口</span><span class="sxs-lookup"><span data-stu-id="f4d72-232">Interfaces with external code</span></span>

<span data-ttu-id="f4d72-233">已经对 `NewsService` 类进行了更改，因此请为该类启用 `#nullable enable` 注释。</span><span class="sxs-lookup"><span data-stu-id="f4d72-233">You've made changes to the `NewsService` class, so turn on the `#nullable enable` annotation for that class.</span></span> <span data-ttu-id="f4d72-234">这不会生成任何新的警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-234">This won't generate any new warnings.</span></span> <span data-ttu-id="f4d72-235">但是，仔细检查该类有助于说明编译器流分析的一些限制。</span><span class="sxs-lookup"><span data-stu-id="f4d72-235">However, careful examination of the class helps to illustrate some of the limitations of the compiler's flow analysis.</span></span> <span data-ttu-id="f4d72-236">检查构造函数：</span><span class="sxs-lookup"><span data-stu-id="f4d72-236">Examine the constructor:</span></span>

[!code-csharp[ServiceConstructor](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ServiceConstructor)]

<span data-ttu-id="f4d72-237">`IMapper` 参数类型为不可为空引用。</span><span class="sxs-lookup"><span data-stu-id="f4d72-237">The `IMapper` parameter is typed as a nonnullable reference.</span></span> <span data-ttu-id="f4d72-238">它由 ASP.NET Core 基础结构代码调用，因此编译器并不知道 `IMapper` 永远不会为 Null。</span><span class="sxs-lookup"><span data-stu-id="f4d72-238">It's called by ASP.NET Core infrastructure code, so the compiler doesn't really know that the `IMapper` will never be null.</span></span> <span data-ttu-id="f4d72-239">如果默认的 ASP.NET Core 依赖关系注入 (DI) 容器不能解析必要的服务，就会引发异常，因此代码是正确的。</span><span class="sxs-lookup"><span data-stu-id="f4d72-239">The default ASP.NET Core dependency injection (DI) container throws an exception if it can't resolve a necessary service, so the code is correct.</span></span> <span data-ttu-id="f4d72-240">编译器无法验证对公共 API 的所有调用，即使代码是在启用了可为空注释上下文的情况下编译的。</span><span class="sxs-lookup"><span data-stu-id="f4d72-240">The compiler can't validate all calls to your public APIs, even if your code is compiled with nullable annotation contexts enabled.</span></span> <span data-ttu-id="f4d72-241">此外，尚未选择使用可为空引用类型的项目可能会使用你的库。</span><span class="sxs-lookup"><span data-stu-id="f4d72-241">Furthermore, your libraries may be consumed by projects that have not yet opted into using nullable reference types.</span></span> <span data-ttu-id="f4d72-242">验证公共 API 的输入，即使已将它们声明为不可为空类型。</span><span class="sxs-lookup"><span data-stu-id="f4d72-242">Validate inputs to public APIs even though you've declared them as nonnullable types.</span></span>

## <a name="get-the-code"></a><span data-ttu-id="f4d72-243">获取代码</span><span class="sxs-lookup"><span data-stu-id="f4d72-243">Get the code</span></span>

<span data-ttu-id="f4d72-244">已经修复了在初始测试编译中标识的警告，因此现在可以为两个项目启用可为空注释上下文。</span><span class="sxs-lookup"><span data-stu-id="f4d72-244">You've fixed the warnings you identified in the initial test compile, so now you can turn on the nullable annotation context for both projects.</span></span> <span data-ttu-id="f4d72-245">重新生成项目；编译器不会报告任何警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-245">Rebuild the projects; the compiler reports no warnings.</span></span> <span data-ttu-id="f4d72-246">可以在 [dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/finished) GitHub 存储库中获取已完成项目的代码。</span><span class="sxs-lookup"><span data-stu-id="f4d72-246">You can get the code for the finished project in the [dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/finished) GitHub repository.</span></span>

<span data-ttu-id="f4d72-247">支持可为空引用类型的新功能可以帮助你发现和修复代码中处理 `null` 值的方式中的潜在错误。</span><span class="sxs-lookup"><span data-stu-id="f4d72-247">The new features that support nullable reference types help you find and fix potential errors in how you handle `null` values in your code.</span></span> <span data-ttu-id="f4d72-248">启用可为空注释上下文可以表达设计意图：某些变量永远不应为 Null，其他变量可以包含 Null 值。</span><span class="sxs-lookup"><span data-stu-id="f4d72-248">Enabling the nullable annotation context allows you to express your design intent: some variables should never be null, other variables may contain null values.</span></span> <span data-ttu-id="f4d72-249">借助这些功能，可以更轻松地声明设计意图。</span><span class="sxs-lookup"><span data-stu-id="f4d72-249">These features make it easier for you to declare your design intent.</span></span> <span data-ttu-id="f4d72-250">同样，可为空警告上下文指示编译器在违背该意图时发出警告。</span><span class="sxs-lookup"><span data-stu-id="f4d72-250">Similarly, the nullable warning context instructs the compiler to issue warnings when you have violated that intent.</span></span> <span data-ttu-id="f4d72-251">这些警告指导你进行更新，使代码更具弹性，并减少在执行期间引发 `NullReferenceException` 的可能性。</span><span class="sxs-lookup"><span data-stu-id="f4d72-251">Those warnings guide you to make updates that make your code more resilient and less likely to throw a `NullReferenceException` during execution.</span></span> <span data-ttu-id="f4d72-252">可以控制这些上下文的范围，以便专注于要迁移的代码的本地区域，同时保证其余代码库不受影响。</span><span class="sxs-lookup"><span data-stu-id="f4d72-252">You can control the scope of these contexts so that you can focus on local areas of code to migrate while the remaining codebase is untouched.</span></span> <span data-ttu-id="f4d72-253">实际上，可以将此迁移任务作为类的常规维护的一部分。</span><span class="sxs-lookup"><span data-stu-id="f4d72-253">In practice, you can make this migration task a part of regular maintenance to your classes.</span></span> <span data-ttu-id="f4d72-254">本教程演示了迁移应用程序以使用可为空引用类型的过程。</span><span class="sxs-lookup"><span data-stu-id="f4d72-254">This tutorial demonstrated the process to migrate an application to use nullable reference types.</span></span> <span data-ttu-id="f4d72-255">可以通过检查 PR [Jon Skeet](https://github.com/jskeet) 来浏览此过程一个更大的实际示例，用于将可为空引用类型合并到 [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits)。</span><span class="sxs-lookup"><span data-stu-id="f4d72-255">You can explore a larger real-world example of this process by examining the PR [Jon Skeet](https://github.com/jskeet) made to incorporate nullable reference types into [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits).</span></span> <span data-ttu-id="f4d72-256">此外，还可以在 [Entity Framework Core - 使用可为 null 的引用类型](/ef/core/miscellaneous/nullable-reference-types)中学习将可为 null 的引用类型与 Entity Framework Core 结合使用的技术。</span><span class="sxs-lookup"><span data-stu-id="f4d72-256">Or just In addition, you can learn techniques for using nullable reference types with Entity Framework Core in [Entity Framework Core - Working with nullable reference types](/ef/core/miscellaneous/nullable-reference-types).</span></span>
