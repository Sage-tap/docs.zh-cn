---
title: CA1835：在基于流的类中，首选 ReadAsync/WriteAsync 方法的基于内存的重载（代码分析）
description: 了解代码分析规则 CA1835：在基于流的类中，首选 ReadAsync/WriteAsync 方法的基于内存的重载
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 5febce07d38bd3781601d6d70a663c779eaa6d66
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/27/2021
ms.locfileid: "105637268"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="006a6-103">CA1835：在基于流的类中，首选 ReadAsync/WriteAsync 方法的基于内存的重载</span><span class="sxs-lookup"><span data-stu-id="006a6-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="006a6-104">值</span><span class="sxs-lookup"><span data-stu-id="006a6-104">Value</span></span> |
|-|-|
| <span data-ttu-id="006a6-105">**类型名称**</span><span class="sxs-lookup"><span data-stu-id="006a6-105">**Type name**</span></span> |<span data-ttu-id="006a6-106">PreferStreamAsyncMemoryOverloads</span><span class="sxs-lookup"><span data-stu-id="006a6-106">PreferStreamAsyncMemoryOverloads</span></span>|
| <span data-ttu-id="006a6-107">**规则 ID**</span><span class="sxs-lookup"><span data-stu-id="006a6-107">**Rule ID**</span></span> |<span data-ttu-id="006a6-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="006a6-108">CA1835</span></span>|
| <span data-ttu-id="006a6-109">**类别**</span><span class="sxs-lookup"><span data-stu-id="006a6-109">**Category**</span></span> |[<span data-ttu-id="006a6-110">“性能”</span><span class="sxs-lookup"><span data-stu-id="006a6-110">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="006a6-111">**修复是中断修复还是非中断修复**</span><span class="sxs-lookup"><span data-stu-id="006a6-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="006a6-112">非中断</span><span class="sxs-lookup"><span data-stu-id="006a6-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="006a6-113">原因</span><span class="sxs-lookup"><span data-stu-id="006a6-113">Cause</span></span>

<span data-ttu-id="006a6-114">此规则查找 `ReadAsync` 和 `WriteAsync` 的基于字节数组的方法重载的等待调用，并建议改为使用基于内存的方法重载，因为它们的效率更高。</span><span class="sxs-lookup"><span data-stu-id="006a6-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="006a6-115">规则说明</span><span class="sxs-lookup"><span data-stu-id="006a6-115">Rule description</span></span>

<span data-ttu-id="006a6-116">基于内存的方法重载具有比基于字节数组的重载更有效的内存使用。</span><span class="sxs-lookup"><span data-stu-id="006a6-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="006a6-117">此规则适用于从 <xref:System.IO.Stream> 继承的任何类的 `ReadAsync` 和 `WriteAsync` 调用。</span><span class="sxs-lookup"><span data-stu-id="006a6-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="006a6-118">仅当方法前面带有 `await` 关键字时，此规则才有效。</span><span class="sxs-lookup"><span data-stu-id="006a6-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="006a6-119">检测到的方法</span><span class="sxs-lookup"><span data-stu-id="006a6-119">Detected method</span></span>|<span data-ttu-id="006a6-120">建议的方法</span><span class="sxs-lookup"><span data-stu-id="006a6-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="006a6-121">`CancellationToken` 设置为 `default`（在 C# 中）或 `Nothing`（在 Visual Basic 中）的 <xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>。</span><span class="sxs-lookup"><span data-stu-id="006a6-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="006a6-122">`CancellationToken` 设置为 `default`（在 C# 中）或 `Nothing`（在 Visual Basic 中）的 <xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>。</span><span class="sxs-lookup"><span data-stu-id="006a6-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="006a6-123">确保将 `offset` 和 `count` 整数参数传递到创建的 `Memory` 或 `ReadOnlyMemory` 实例。</span><span class="sxs-lookup"><span data-stu-id="006a6-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="006a6-124">规则 CA1835 适用于所有提供基于内存的重载的 .NET 版本：</span><span class="sxs-lookup"><span data-stu-id="006a6-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="006a6-125">.NET Standard 2.1 及更高版本。</span><span class="sxs-lookup"><span data-stu-id="006a6-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="006a6-126">.NET Core 2.1 及更高版本。</span><span class="sxs-lookup"><span data-stu-id="006a6-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="006a6-127">如何解决冲突</span><span class="sxs-lookup"><span data-stu-id="006a6-127">How to fix violations</span></span>

<span data-ttu-id="006a6-128">可以手动修复，也可以选择让 Visual Studio 执行修复，方法是将鼠标悬停在方法调用旁显示的灯泡图标上，然后选择建议的更改。</span><span class="sxs-lookup"><span data-stu-id="006a6-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="006a6-129">示例：</span><span class="sxs-lookup"><span data-stu-id="006a6-129">Example:</span></span>

![CA1835 的代码修复 - 在基于流的类中，首选 ReadAsync/WriteAsync 方法的基于内存的重载](media/ca1835-codefix.png)

<span data-ttu-id="006a6-131">此规则可以检测 `ReadAsync` 和 `WriteAsync` 方法的多种冲突。</span><span class="sxs-lookup"><span data-stu-id="006a6-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="006a6-132">下面是此规则可检测到的情况示例：</span><span class="sxs-lookup"><span data-stu-id="006a6-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="006a6-133">示例 1</span><span class="sxs-lookup"><span data-stu-id="006a6-133">Example 1</span></span>

<span data-ttu-id="006a6-134">`ReadAsync` 的调用，未使用和使用 `CancellationToken` 参数：</span><span class="sxs-lookup"><span data-stu-id="006a6-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="006a6-135">解决方法：</span><span class="sxs-lookup"><span data-stu-id="006a6-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="006a6-136">示例 2</span><span class="sxs-lookup"><span data-stu-id="006a6-136">Example 2</span></span>

<span data-ttu-id="006a6-137">`WriteAsync` 的调用，未使用和使用 `CancellationToken` 参数：</span><span class="sxs-lookup"><span data-stu-id="006a6-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="006a6-138">解决方法：</span><span class="sxs-lookup"><span data-stu-id="006a6-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="006a6-139">示例 3</span><span class="sxs-lookup"><span data-stu-id="006a6-139">Example 3</span></span>

<span data-ttu-id="006a6-140">使用 `ConfigureAwait` 的调用：</span><span class="sxs-lookup"><span data-stu-id="006a6-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="006a6-141">解决方法：</span><span class="sxs-lookup"><span data-stu-id="006a6-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="006a6-142">无冲突</span><span class="sxs-lookup"><span data-stu-id="006a6-142">Non-violations</span></span>

<span data-ttu-id="006a6-143">下面是不会触发此规则的一些调用示例。</span><span class="sxs-lookup"><span data-stu-id="006a6-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="006a6-144">返回值保存在 `Task` 变量中，而不是在等待：</span><span class="sxs-lookup"><span data-stu-id="006a6-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="006a6-145">返回值由包装方法返回，而不是在等待：</span><span class="sxs-lookup"><span data-stu-id="006a6-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="006a6-146">返回值用于调用 `ContinueWith`，这是在等待的方法：</span><span class="sxs-lookup"><span data-stu-id="006a6-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="006a6-147">何时禁止显示警告</span><span class="sxs-lookup"><span data-stu-id="006a6-147">When to suppress warnings</span></span>

<span data-ttu-id="006a6-148">如果不考虑在基于流的类中读取或写入缓冲区时提高性能，则可以放心地抑制此规则的冲突。</span><span class="sxs-lookup"><span data-stu-id="006a6-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="006a6-149">另请参阅</span><span class="sxs-lookup"><span data-stu-id="006a6-149">See also</span></span>

- [<span data-ttu-id="006a6-150">性能规则</span><span class="sxs-lookup"><span data-stu-id="006a6-150">Performance rules</span></span>](performance-warnings.md)
