---
description: 了解详细信息：针对验证的扩展保护概述
title: 身份验证的扩展保护概述
ms.date: 03/30/2017
ms.assetid: 3d2ceffe-a7bf-4bd9-a5a2-9406423bd7f8
ms.openlocfilehash: 5f79092d71266176af3916e919be0018793959ad
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99780266"
---
# <a name="extended-protection-for-authentication-overview"></a><span data-ttu-id="444d1-103">身份验证的扩展保护概述</span><span class="sxs-lookup"><span data-stu-id="444d1-103">Extended Protection for Authentication Overview</span></span>

<span data-ttu-id="444d1-104">身份验证的扩展保护有助于抵御中间人 (MITM) 攻击，在此类攻击中，攻击者截获客户端凭据并将它们转发给服务器。</span><span class="sxs-lookup"><span data-stu-id="444d1-104">Extended Protection for Authentication helps protect against man-in-the-middle (MITM) attacks, in which an attacker intercepts a client’s credentials and forwards them to a server.</span></span>  
  
 <span data-ttu-id="444d1-105">假设有这么一种情况，有三个参与者：客户端、服务器和攻击者。</span><span class="sxs-lookup"><span data-stu-id="444d1-105">Consider a scenario with three participants: a client, server, and attacker.</span></span> <span data-ttu-id="444d1-106">服务器的 URL 为 `https://server`，而攻击者的 URL 为 `https://attacker`。</span><span class="sxs-lookup"><span data-stu-id="444d1-106">The server has the URL `https://server`, whereas the attacker has the URL `https://attacker`.</span></span> <span data-ttu-id="444d1-107">攻击者诱骗客户端访问攻击者，就好像它是服务器。</span><span class="sxs-lookup"><span data-stu-id="444d1-107">The attacker tricks the client into accessing the attacker as if it were the server.</span></span> <span data-ttu-id="444d1-108">然后，攻击者向服务器发送一个请求。</span><span class="sxs-lookup"><span data-stu-id="444d1-108">The attacker then sends a request to the server.</span></span> <span data-ttu-id="444d1-109">如果攻击者尝试访问安全资源，则服务器会使用 WWW-Authenticate 标头答复攻击者。</span><span class="sxs-lookup"><span data-stu-id="444d1-109">If the attacker is trying to access a secure resource, the server replies to the attacker with a WWW-Authenticate header.</span></span> <span data-ttu-id="444d1-110">由于攻击者没有身份验证信息，因此它会将 WWW-Authenticate 标头发送给客户端。</span><span class="sxs-lookup"><span data-stu-id="444d1-110">The attacker does not have the authentication information, so it sends the WWW-Authenticate header on to the client.</span></span> <span data-ttu-id="444d1-111">客户端将 Authorization 标头发送给攻击者，然后，攻击者将此标头发送给服务器，并使用客户端凭据获取对安全资源的访问权限。</span><span class="sxs-lookup"><span data-stu-id="444d1-111">The client sends the Authorization header to the attacker, and the attacker sends the header on to the server and gets access to the secure resources using the client’s credentials.</span></span>  
  
 <span data-ttu-id="444d1-112">目前，当客户端应用程序通过 HTTPS 使用 Kerberos、Digest 或 NTLM 向服务器验证自身的身份时，首先会建立一个传输层安全 (TLS) 通道，然后使用此通道进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="444d1-112">Currently, when a client application authenticates itself to the server using Kerberos, Digest, or NTLM using HTTPS, a Transport Level Security (TLS) channel is first established and authentication takes place using this channel.</span></span> <span data-ttu-id="444d1-113">但是，安全套接字层 (SSL) 生成的会话密钥和身份验证期间生成的会话密钥之间没有任何绑定。</span><span class="sxs-lookup"><span data-stu-id="444d1-113">However, there is no binding between the session key generated by Secure Sockets Layer (SSL) and the session key that is generated during authentication.</span></span> <span data-ttu-id="444d1-114">因此，在前面的情况中，如果通过 TLS（如 HTTPS 通道）进行通信，则会创建两个 SSL 通道：一个用于客户端与攻击者之间的通信，另一个用于攻击者与服务器之间的通信。</span><span class="sxs-lookup"><span data-stu-id="444d1-114">So, in the previous scenario, if the communication takes places over a TLS (such as an HTTPS channel), there are two SSL channels created: one between the client and the attacker, and another between the attacker and the server.</span></span> <span data-ttu-id="444d1-115">首先，通过客户端与攻击者之间的 SSL 通道从客户端发送客户端凭据，然后再通过攻击者与服务器之间的通道将凭据发送至服务器。</span><span class="sxs-lookup"><span data-stu-id="444d1-115">The client’s credentials are sent from the client to the server first over the SSL channel between the client and the attacker and then over the channel between the attacker and the server.</span></span> <span data-ttu-id="444d1-116">在客户端凭据到达服务器之后，服务器会验证凭据，而不检测通过其发送这些凭据的通道源自攻击者，而不是客户端。</span><span class="sxs-lookup"><span data-stu-id="444d1-116">Once the client’s credentials reach the server, the server verifies the credentials without detecting that the channel over which those credentials were sent originated with the attacker and not the client.</span></span>  
  
 <span data-ttu-id="444d1-117">解决方案是使用受 TLS 保护的外部通道和对客户端进行身份验证的内部通道，并将通道绑定令牌 (CBT) 传递给服务器。</span><span class="sxs-lookup"><span data-stu-id="444d1-117">The solution is to use a TLS-secured outer channel and a client-authenticated inner channel, and to pass a Channel Binding Token (CBT) to the server.</span></span> <span data-ttu-id="444d1-118">CBT 是受 TLS 保护的外部通道的属性，并且用于通过对客户端进行身份验证的内部通道将外部通道绑定到对话。</span><span class="sxs-lookup"><span data-stu-id="444d1-118">The CBT is a property of the TLS-secured outer channel, and is used to bind the outer channel to a conversation over the client-authenticated inner channel.</span></span>  
  
 <span data-ttu-id="444d1-119">在前面的情况中，客户端-攻击者 TSL 通道的 CBT 与发送给服务器的授权信息合并。</span><span class="sxs-lookup"><span data-stu-id="444d1-119">In the previous scenario, the CBT of the client-attacker TLS channel is merged with the authorization information that is sent to the server.</span></span> <span data-ttu-id="444d1-120">识别 CBT 的服务器将客户端身份验证信息中所含的 CBT（与客户端-攻击者通道相对应）与附加到攻击者-服务器通道的 CBT 进行比较。</span><span class="sxs-lookup"><span data-stu-id="444d1-120">A CBT-aware server compares the CBT contained in the client authentication information, which corresponds to the client-attacker channel, to the CBT attached to the attacker-server channel.</span></span> <span data-ttu-id="444d1-121">CBT 特定于通道目标，因此客户端-攻击者 CBT 与攻击者-服务器 CBT 不匹配。</span><span class="sxs-lookup"><span data-stu-id="444d1-121">A CBT is specific to a channel’s destination, so the client-attacker CBT does not match the attacker-server CBT.</span></span> <span data-ttu-id="444d1-122">这样，服务器就可检测 MITM 攻击并拒绝身份验证请求。</span><span class="sxs-lookup"><span data-stu-id="444d1-122">This lets the server detect the MITM attack and refuse the authentication request.</span></span>  
  
 <span data-ttu-id="444d1-123">客户端不需要任何配置设置。</span><span class="sxs-lookup"><span data-stu-id="444d1-123">The client side does not require any configuration setting.</span></span> <span data-ttu-id="444d1-124">在对客户端进行了更新以将 CBT 传递给服务器之后，它会始终执行此操作。</span><span class="sxs-lookup"><span data-stu-id="444d1-124">Once the client has been updated to pass the CBT to the server, it always does so.</span></span> <span data-ttu-id="444d1-125">如果也对服务器进行了更新，则可以对其进行配置以使用 CBT 或忽略它。</span><span class="sxs-lookup"><span data-stu-id="444d1-125">If the server has also been updated, it can be configured to use the CBT or ignore it.</span></span> <span data-ttu-id="444d1-126">如果未对服务器进行更新，则它会忽略 CBT。</span><span class="sxs-lookup"><span data-stu-id="444d1-126">If it has not been updated, it ignores it.</span></span>  
  
 <span data-ttu-id="444d1-127">服务器可以具有以下级别的保护：</span><span class="sxs-lookup"><span data-stu-id="444d1-127">The server can have the following levels of protection:</span></span>  
  
- <span data-ttu-id="444d1-128">无。</span><span class="sxs-lookup"><span data-stu-id="444d1-128">None.</span></span> <span data-ttu-id="444d1-129">不执行任何通道绑定验证。</span><span class="sxs-lookup"><span data-stu-id="444d1-129">No channel binding validation is performed.</span></span> <span data-ttu-id="444d1-130">这是所有尚未更新的服务器的行为。</span><span class="sxs-lookup"><span data-stu-id="444d1-130">This is the behavior of all servers that have not been updated.</span></span>  
  
- <span data-ttu-id="444d1-131">部分支持。</span><span class="sxs-lookup"><span data-stu-id="444d1-131">Partial.</span></span> <span data-ttu-id="444d1-132">所有已更新的客户端必须向服务器提供通道绑定信息。</span><span class="sxs-lookup"><span data-stu-id="444d1-132">All clients that have been updated must provide channel binding information to the server.</span></span> <span data-ttu-id="444d1-133">尚未更新的客户端无需执行此操作。</span><span class="sxs-lookup"><span data-stu-id="444d1-133">Clients that have not been updated do not have to do so.</span></span> <span data-ttu-id="444d1-134">这是一个中间选项，可以实现应用程序兼容。</span><span class="sxs-lookup"><span data-stu-id="444d1-134">This is an intermediate option that allows for application compatibility.</span></span>  
  
- <span data-ttu-id="444d1-135">已满。</span><span class="sxs-lookup"><span data-stu-id="444d1-135">Full.</span></span> <span data-ttu-id="444d1-136">所有客户端都必须提供通道绑定信息。</span><span class="sxs-lookup"><span data-stu-id="444d1-136">All clients must provide channel binding information.</span></span> <span data-ttu-id="444d1-137">服务器拒绝来自不提供通道绑定信息的客户端的身份验证请求。</span><span class="sxs-lookup"><span data-stu-id="444d1-137">The server rejects authentication requests from clients that do not do so.</span></span>  
  
 <span data-ttu-id="444d1-138">有关更多信息，请参见 Win7 CBT/扩展保护示例。</span><span class="sxs-lookup"><span data-stu-id="444d1-138">For more information, see the Win7 CBT/Extended Protection sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="444d1-139">请参阅</span><span class="sxs-lookup"><span data-stu-id="444d1-139">See also</span></span>

- <span data-ttu-id="444d1-140">[Windows Server App Fabric 的安全模型](/previous-versions/appfabric/ee677202(v=azure.10))</span><span class="sxs-lookup"><span data-stu-id="444d1-140">[Security Model for Windows Server App Fabric](/previous-versions/appfabric/ee677202(v=azure.10))</span></span>
