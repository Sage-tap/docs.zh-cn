---
description: 了解详细信息：上下文交换协议
title: 上下文交换协议
ms.date: 03/30/2017
ms.assetid: 3dfd38e0-ae52-491c-94f4-7a862b9843d4
ms.openlocfilehash: c4c81ef28821cd7373d53822728490d50687d5f2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99780526"
---
# <a name="context-exchange-protocol"></a><span data-ttu-id="90a07-103">上下文交换协议</span><span class="sxs-lookup"><span data-stu-id="90a07-103">Context Exchange Protocol</span></span>

<span data-ttu-id="90a07-104">本部分介绍 Windows Communication Foundation (WCF .NET Framework) 版本3.5 中引入的上下文交换协议。</span><span class="sxs-lookup"><span data-stu-id="90a07-104">This section describes the context exchange protocol introduced in Windows Communication Foundation (WCF) release .NET Framework version 3.5.</span></span> <span data-ttu-id="90a07-105">此协议允许客户端通道接受某个服务提供的上下文，并将其应用于通过相同客户端通道实例发送的针对该服务的所有后续请求。</span><span class="sxs-lookup"><span data-stu-id="90a07-105">This protocol allows the client channel to accept a context supplied by a service and apply it to all subsequent requests to that service sent over the same client channel instance.</span></span> <span data-ttu-id="90a07-106">上下文交换协议的实现可以使用以下两个机制之一在服务器和客户端之间传播上下文：HTTP Cookie 或 SOAP 标头。</span><span class="sxs-lookup"><span data-stu-id="90a07-106">The implementation of the context exchange protocol can use one of the following two mechanisms to propagate the context between the server and the client: HTTP cookies or a SOAP header.</span></span>  
  
 <span data-ttu-id="90a07-107">上下文交换协议是在自定义通道层中实现的。</span><span class="sxs-lookup"><span data-stu-id="90a07-107">The context exchange protocol is implemented in a custom channel layer.</span></span> <span data-ttu-id="90a07-108">通道使用 <xref:System.ServiceModel.Channels.ContextMessageProperty> 属性在应用程序层之间来回传递上下文。</span><span class="sxs-lookup"><span data-stu-id="90a07-108">The channel communicates the context to and from the application layer using a <xref:System.ServiceModel.Channels.ContextMessageProperty> property.</span></span> <span data-ttu-id="90a07-109">对于终结点之间的传输，上下文的值或者在通道层序列化为 SOAP 标头，或者在表示 HTTP 请求和响应的消息属性之间来回转换。</span><span class="sxs-lookup"><span data-stu-id="90a07-109">For transmission between endpoints, the value of the context is either serialized as a SOAP header at the channel layer, or converted to or from the message properties that represent a HTTP request and response.</span></span> <span data-ttu-id="90a07-110">在后一种情况下，应有一个基础通道层将 HTTP 请求和响应消息属性分别与 HTTP Cookie 来回进行转换。</span><span class="sxs-lookup"><span data-stu-id="90a07-110">In the latter case, it is expected that one of the underlying channel layers converts the HTTP request and response message properties to and from HTTP cookies, respectively.</span></span> <span data-ttu-id="90a07-111">可通过使用 <xref:System.ServiceModel.Channels.ContextExchangeMechanism> 上的 <xref:System.ServiceModel.Channels.ContextBindingElement> 属性来选择用于交换上下文的机制。</span><span class="sxs-lookup"><span data-stu-id="90a07-111">The choice of the mechanism used to exchange the context is done using the <xref:System.ServiceModel.Channels.ContextExchangeMechanism> property on the <xref:System.ServiceModel.Channels.ContextBindingElement>.</span></span> <span data-ttu-id="90a07-112">有效值为 `HttpCookie` or `SoapHeader`进行求值的基于 SQL 语言的筛选器表达式。</span><span class="sxs-lookup"><span data-stu-id="90a07-112">Valid values are `HttpCookie` or `SoapHeader`.</span></span>  
  
 <span data-ttu-id="90a07-113">在客户端上，通道的实例可以基于通道属性 <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> 上的设置在两种模式中操作。</span><span class="sxs-lookup"><span data-stu-id="90a07-113">On the client, an instance of a channel can operate in two modes based on the settings on the channel property, <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A>.</span></span>  
  
## <a name="mode-1-channel-context-management"></a><span data-ttu-id="90a07-114">模式 1：通道上下文管理</span><span class="sxs-lookup"><span data-stu-id="90a07-114">Mode 1: Channel Context Management</span></span>  

 <span data-ttu-id="90a07-115">这是默认模式，其中将 <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="90a07-115">This is the default mode where <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> is set to `true`.</span></span> <span data-ttu-id="90a07-116">在此模式中，上下文通道将管理上下文，并在上下文的生存期内将其缓存。</span><span class="sxs-lookup"><span data-stu-id="90a07-116">In this mode the context channel manages the context and caches the context during its lifetime.</span></span> <span data-ttu-id="90a07-117">通过调用 `IContextManager` 方法，可以通过通道属性 `GetContext` 从通道检索上下文。</span><span class="sxs-lookup"><span data-stu-id="90a07-117">Context can be retrieved from the channel through channel property `IContextManager` by calling the `GetContext` method.</span></span> <span data-ttu-id="90a07-118">在通过对通道属性调用 `SetContext` 方法打开通道之前，还可以使用特定的上下文来预先初始化通道。</span><span class="sxs-lookup"><span data-stu-id="90a07-118">The channel can also be pre-initialized with specific context before being opened by calling the `SetContext` method on the channel property.</span></span> <span data-ttu-id="90a07-119">在使用上下文初始化通道之后，将不能重置通道。</span><span class="sxs-lookup"><span data-stu-id="90a07-119">Once the channel is initialized with context it cannot be reset.</span></span>  
  
 <span data-ttu-id="90a07-120">以下是此模式中的固定行为的列表：</span><span class="sxs-lookup"><span data-stu-id="90a07-120">The following is a list of invariants in this mode:</span></span>  
  
- <span data-ttu-id="90a07-121">任何试图在已经打开通道之后使用 `SetContext` 来重置上下文的操作都会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="90a07-121">Any attempt to reset the context using `SetContext` after the channel has been opened throws an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="90a07-122">任何试图在传出消息中使用 <xref:System.ServiceModel.Channels.ContextMessageProperty> 来发送上下文的操作都会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="90a07-122">Any attempt to send context by using the <xref:System.ServiceModel.Channels.ContextMessageProperty> in an outgoing message throws an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="90a07-123">在已使用特定的上下文对通道进行初始化之后，如果使用特定的上下文从服务器接收消息，则会导致 <xref:System.ServiceModel.ProtocolException>。</span><span class="sxs-lookup"><span data-stu-id="90a07-123">If a message is received from server with a specific context, when the channel has already been initialized with a specific context, this results in a <xref:System.ServiceModel.ProtocolException>.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="90a07-124">仅在打开通道时没有显式设置任何上下文的情况下，从服务器上接收初始上下文才是合适的。</span><span class="sxs-lookup"><span data-stu-id="90a07-124">It is appropriate to receive an initial context from the server only if the channel is opened without any context set explicitly.</span></span>  
  
- <span data-ttu-id="90a07-125">传入消息上的 <xref:System.ServiceModel.Channels.ContextMessageProperty> 始终为空。</span><span class="sxs-lookup"><span data-stu-id="90a07-125">The <xref:System.ServiceModel.Channels.ContextMessageProperty> on incoming message is always null.</span></span>  
  
## <a name="mode-2-application-context-management"></a><span data-ttu-id="90a07-126">模式 2：应用程序上下文管理</span><span class="sxs-lookup"><span data-stu-id="90a07-126">Mode 2: Application Context Management</span></span>  

 <span data-ttu-id="90a07-127">在此模式中，<xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> 设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="90a07-127">This is the mode when <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> is set to `false`.</span></span> <span data-ttu-id="90a07-128">在此模式中，上下文通道并不对上下文进行管理，</span><span class="sxs-lookup"><span data-stu-id="90a07-128">In this mode the context channel does not manage context.</span></span> <span data-ttu-id="90a07-129">而是由应用程序负责通过使用 <xref:System.ServiceModel.Channels.ContextMessageProperty> 来检索、管理和应用上下文。</span><span class="sxs-lookup"><span data-stu-id="90a07-129">It is the application's responsibility to retrieve, manage and apply context by using the <xref:System.ServiceModel.Channels.ContextMessageProperty>.</span></span> <span data-ttu-id="90a07-130">任何尝试调用 `GetContext` 或 `SetContext` 的操作都会导致 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="90a07-130">Any attempt to call `GetContext` or `SetContext` results in an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="90a07-131">无论选择哪种模式，客户端通道工厂都支持 <xref:System.ServiceModel.Channels.IRequestChannel>、<xref:System.ServiceModel.Channels.IRequestSessionChannel> 和 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 消息交换模式。</span><span class="sxs-lookup"><span data-stu-id="90a07-131">No matter which mode is chosen the client channel factory supports <xref:System.ServiceModel.Channels.IRequestChannel>, <xref:System.ServiceModel.Channels.IRequestSessionChannel>, and <xref:System.ServiceModel.Channels.IDuplexSessionChannel> message exchange patterns.</span></span>  
  
 <span data-ttu-id="90a07-132">在服务上，通道的实例负责将客户端提供的传入消息的上下文转换为 <xref:System.ServiceModel.Channels.ContextMessageProperty>。</span><span class="sxs-lookup"><span data-stu-id="90a07-132">On the service, an instance of the channel is responsible for converting the context supplied by the client on incoming messages to the <xref:System.ServiceModel.Channels.ContextMessageProperty>.</span></span> <span data-ttu-id="90a07-133">然后应用程序层或调用堆栈中更上层的其他通道就可以访问消息属性。</span><span class="sxs-lookup"><span data-stu-id="90a07-133">The message property can then be accessed by the application layer or other channels further up in the call stack.</span></span> <span data-ttu-id="90a07-134">服务通道还允许应用程序层通过将 <xref:System.ServiceModel.Channels.ContextMessageProperty> 附加到响应消息，指定要传播回客户端的新上下文值。</span><span class="sxs-lookup"><span data-stu-id="90a07-134">The service channels also allow the application layer to specify a new context value to be propagated back to the client by attaching a <xref:System.ServiceModel.Channels.ContextMessageProperty> to the response message.</span></span> <span data-ttu-id="90a07-135">此属性将会转换为包含上下文的 SOAP 标头或 HTTP Cookie，具体取决于绑定的配置。</span><span class="sxs-lookup"><span data-stu-id="90a07-135">This property is converted to the SOAP header or HTTP cookie that contains the context, which depends on the configuration of the binding.</span></span> <span data-ttu-id="90a07-136">服务通道侦听器支持 <xref:System.ServiceModel.Channels.IReplyChannel>、<xref:System.ServiceModel.Channels.IReplySessionChannel> 和 <xref:System.ServiceModel.Channels.IReplySessionChannel> 消息交换模式。</span><span class="sxs-lookup"><span data-stu-id="90a07-136">The service channel listener supports <xref:System.ServiceModel.Channels.IReplyChannel>, <xref:System.ServiceModel.Channels.IReplySessionChannel>, and <xref:System.ServiceModel.Channels.IReplySessionChannel> message exchange patterns.</span></span>  
  
 <span data-ttu-id="90a07-137">上下文交换协议引入了一个新的 `wsc:Context` SOAP 标头，以便在未使用 HTTP Cookie 来传播上下文的情况下表示上下文信息。</span><span class="sxs-lookup"><span data-stu-id="90a07-137">The context exchange protocol introduces a new `wsc:Context` SOAP header to represent the context information when HTTP cookies are not used to propagate the context.</span></span> <span data-ttu-id="90a07-138">上下文标头架构允许任意数量的子元素，每个元素都有一个字符串键和字符串内容。</span><span class="sxs-lookup"><span data-stu-id="90a07-138">The context header schema allows for any number of child elements, each with a string key and string content.</span></span> <span data-ttu-id="90a07-139">下面是一个上下文标头示例。</span><span class="sxs-lookup"><span data-stu-id="90a07-139">The following is an example of a context header.</span></span>  
  
 `<Context xmlns="http://schemas.microsoft.com/ws/2006/05/context">`  
  
 `<property name="myContext">context-2</property>`  
  
 `</Context>`  
  
 <span data-ttu-id="90a07-140">在 `HttpCookie` 模式中，将使用 `SetCookie` 标头设置 Cookie。</span><span class="sxs-lookup"><span data-stu-id="90a07-140">When in `HttpCookie` mode, cookies are set using the `SetCookie` header.</span></span> <span data-ttu-id="90a07-141">相应的 Cookie 名称为 `WscContext`。</span><span class="sxs-lookup"><span data-stu-id="90a07-141">The cookie name is `WscContext`.</span></span> <span data-ttu-id="90a07-142">Cookie 的值是 `wsc:Context` 标头的 Base64 编码。</span><span class="sxs-lookup"><span data-stu-id="90a07-142">The value of the cookie is the Base64 encoding of the `wsc:Context` header.</span></span> <span data-ttu-id="90a07-143">此值包含在引号中。</span><span class="sxs-lookup"><span data-stu-id="90a07-143">This value is enclosed in quotes.</span></span>  
  
 <span data-ttu-id="90a07-144">在传输过程中必须保护上下文的值，使之不会被修改，其原因与保护 WS-Addressing 标头的原因相同（标头可用于确定在将请求调度到服务上的何处）。</span><span class="sxs-lookup"><span data-stu-id="90a07-144">The value of the context must be protected from modification while in transit for the same reason WS-Addressing headers are protected – the header is used to determine where to dispatch the request to on the service.</span></span> <span data-ttu-id="90a07-145">因此，当绑定提供消息保护功能时，需要在 SOAP 或传输级对 `wsc:Context` 标头进行数字签名或进行签名并加密。</span><span class="sxs-lookup"><span data-stu-id="90a07-145">The `wsc:Context` header is therefore required to be digitally signed or signed and encrypted at either the SOAP or transport level when the binding offers message protection capability.</span></span> <span data-ttu-id="90a07-146">当使用 HTTP Cookie 来传播上下文时，应使用传输安全来保护 HTTP Cookie。</span><span class="sxs-lookup"><span data-stu-id="90a07-146">When HTTP cookies are used to propagate context, they should be protected using transport security.</span></span>  
  
 <span data-ttu-id="90a07-147">要求支持上下文交换协议的服务终结点可以在其发布的策略中明确此要求。</span><span class="sxs-lookup"><span data-stu-id="90a07-147">Service endpoints that require support for the context exchange protocol can make it explicit in the published policy.</span></span> <span data-ttu-id="90a07-148">已经引入了两个新的策略断言来表示要求客户端在 SOAP 级支持上下文交换协议或启用 HTTP Cookie 支持。</span><span class="sxs-lookup"><span data-stu-id="90a07-148">Two new policy assertions have been introduced to represent the requirement for the client to support the context exchange protocol at the SOAP level or to enable HTTP cookie support.</span></span> <span data-ttu-id="90a07-149">由 <xref:System.ServiceModel.Channels.ContextBindingElement.ContextExchangeMechanism%2A> 属性控制如何将这些断言生成到服务策略中，如下所示：</span><span class="sxs-lookup"><span data-stu-id="90a07-149">Generation of these assertions into the policy on the service is controlled by the value of the <xref:System.ServiceModel.Channels.ContextBindingElement.ContextExchangeMechanism%2A> property as follows:</span></span>  
  
- <span data-ttu-id="90a07-150">对于 <xref:System.ServiceModel.Channels.ContextExchangeMechanism.ContextSoapHeader>，将生成以下断言：</span><span class="sxs-lookup"><span data-stu-id="90a07-150">For <xref:System.ServiceModel.Channels.ContextExchangeMechanism.ContextSoapHeader>, the following assertion is generated:</span></span>  
  
    ```xml  
    <IncludeContext
    xmlns="http://schemas.microsoft.com/ws/2006/05/context"  
    protectionLevel="Sign" />  
    ```  
  
- <span data-ttu-id="90a07-151">对于 <xref:System.ServiceModel.Channels.ContextExchangeMechanism.HttpCookie>，将生成以下断言：</span><span class="sxs-lookup"><span data-stu-id="90a07-151">For <xref:System.ServiceModel.Channels.ContextExchangeMechanism.HttpCookie>, the following assertion is generated:</span></span>  
  
    ```xml  
    <HttpUseCookie xmlns="http://schemas.xmlsoap.org/soap/http"/>  
    ```  
  
## <a name="see-also"></a><span data-ttu-id="90a07-152">请参阅</span><span class="sxs-lookup"><span data-stu-id="90a07-152">See also</span></span>

- [<span data-ttu-id="90a07-153">Web 服务协议互操作性指南</span><span class="sxs-lookup"><span data-stu-id="90a07-153">Web Services Protocols Interoperability Guide</span></span>](web-services-protocols-interoperability-guide.md)
