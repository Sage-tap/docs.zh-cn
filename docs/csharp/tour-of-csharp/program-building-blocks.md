---
title: C# 程序的构建基块
description: 了解 C# 成员、表达式和语句。 类型包含你编写的成员。 这些成员是根据语句和表达式生成的。
ms.date: 08/06/2020
ms.openlocfilehash: 0ac45eee180b60062a328fca9ab5c63a1537debe
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216611"
---
# <a name="program-building-blocks"></a><span data-ttu-id="e6f13-105">程序构建基块</span><span class="sxs-lookup"><span data-stu-id="e6f13-105">Program building blocks</span></span>

<span data-ttu-id="e6f13-106">上文中介绍的类型是使用以下构建基块生成的：[成员](../programming-guide/classes-and-structs/members.md)、[表达式和语句](../programming-guide/statements-expressions-operators/index.md)_\*__ 。</span><span class="sxs-lookup"><span data-stu-id="e6f13-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _*_statements_*_](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="e6f13-107">成员</span><span class="sxs-lookup"><span data-stu-id="e6f13-107">Members</span></span>

<span data-ttu-id="e6f13-108">`class` 的成员要么是静态成员，要么是实例成员 。</span><span class="sxs-lookup"><span data-stu-id="e6f13-108">The members of a `class` are either _*_static members_*_ or _*_instance members_*_.</span></span> <span data-ttu-id="e6f13-109">静态成员属于类，而实例成员则属于对象（类实例）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="e6f13-110">以下列表概述了类可以包含的成员类型。</span><span class="sxs-lookup"><span data-stu-id="e6f13-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="e6f13-111">_\*常数\*\*：与类相关联的常量值</span><span class="sxs-lookup"><span data-stu-id="e6f13-111">_\*Constants\*\*: Constant values associated with the class</span></span>
- <span data-ttu-id="e6f13-112">**字段**：与类关联的变量</span><span class="sxs-lookup"><span data-stu-id="e6f13-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="e6f13-113">**方法**：类可执行的操作</span><span class="sxs-lookup"><span data-stu-id="e6f13-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="e6f13-114">**属性**：与读取和写入类的已命名属性相关联的操作</span><span class="sxs-lookup"><span data-stu-id="e6f13-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="e6f13-115">**索引器**：与将类实例编入索引（像处理数组一样）相关联的操作</span><span class="sxs-lookup"><span data-stu-id="e6f13-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="e6f13-116">**事件**：类可以生成的通知</span><span class="sxs-lookup"><span data-stu-id="e6f13-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="e6f13-117">**运算符**：类支持的转换和表达式运算符</span><span class="sxs-lookup"><span data-stu-id="e6f13-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="e6f13-118">**构造函数**：初始化类实例或类本身所需的操作</span><span class="sxs-lookup"><span data-stu-id="e6f13-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="e6f13-119">**终结器**：永久放弃类实例之前执行的操作</span><span class="sxs-lookup"><span data-stu-id="e6f13-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="e6f13-120">**类型**：类声明的嵌套类型</span><span class="sxs-lookup"><span data-stu-id="e6f13-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="e6f13-121">辅助功能</span><span class="sxs-lookup"><span data-stu-id="e6f13-121">Accessibility</span></span>

<span data-ttu-id="e6f13-122">每个类成员都有关联的可访问性，用于控制能够访问成员的程序文本区域。</span><span class="sxs-lookup"><span data-stu-id="e6f13-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="e6f13-123">可访问性有六种可能的形式。</span><span class="sxs-lookup"><span data-stu-id="e6f13-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="e6f13-124">以下内容对访问修饰符进行了汇总。</span><span class="sxs-lookup"><span data-stu-id="e6f13-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="e6f13-125">`public`：访问不受限制。</span><span class="sxs-lookup"><span data-stu-id="e6f13-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="e6f13-126">`private`：访问仅限于此类。</span><span class="sxs-lookup"><span data-stu-id="e6f13-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="e6f13-127">`protected`：访问仅限于此类或派生自此类的类。</span><span class="sxs-lookup"><span data-stu-id="e6f13-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="e6f13-128">`internal`：仅可访问当前程序集（`.exe` 或 `.dll`）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="e6f13-129">`protected internal`：仅可访问此类、从此类中派生的类，或者同一程序集中的类。</span><span class="sxs-lookup"><span data-stu-id="e6f13-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="e6f13-130">`private protected`：仅可访问此类或同一程序集中从此类中派生的类。</span><span class="sxs-lookup"><span data-stu-id="e6f13-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="e6f13-131">字段</span><span class="sxs-lookup"><span data-stu-id="e6f13-131">Fields</span></span>

<span data-ttu-id="e6f13-132">*字段* 是与类或类实例相关联的变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="e6f13-133">使用静态修饰符声明的字段定义的是静态字段。</span><span class="sxs-lookup"><span data-stu-id="e6f13-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="e6f13-134">静态字段只指明一个存储位置。</span><span class="sxs-lookup"><span data-stu-id="e6f13-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="e6f13-135">无论创建多少个类实例，永远只有一个静态字段副本。</span><span class="sxs-lookup"><span data-stu-id="e6f13-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="e6f13-136">不使用静态修饰符声明的字段定义的是实例字段。</span><span class="sxs-lookup"><span data-stu-id="e6f13-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="e6f13-137">每个类实例均包含相应类的所有实例字段的单独副本。</span><span class="sxs-lookup"><span data-stu-id="e6f13-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="e6f13-138">在以下示例中，每个 `Color` 类实例均包含 `R`、`G` 和 `B` 实例字段的单独副本，但只包含 `Black`、`White`、`Red`、`Green` 和 `Blue` 静态字段的一个副本：</span><span class="sxs-lookup"><span data-stu-id="e6f13-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="e6f13-139">如上面的示例所示，可以使用 `readonly` 修饰符声明 *只读字段*。</span><span class="sxs-lookup"><span data-stu-id="e6f13-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="e6f13-140">只能在字段声明期间或在同一个类的构造函数中向只读字段赋值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="e6f13-141">方法</span><span class="sxs-lookup"><span data-stu-id="e6f13-141">Methods</span></span>

<span data-ttu-id="e6f13-142">*方法* 是实现对象或类可执行的计算或操作的成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="e6f13-143">*静态方法* 是通过类进行访问。</span><span class="sxs-lookup"><span data-stu-id="e6f13-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="e6f13-144">*实例方法* 是通过类实例进行访问。</span><span class="sxs-lookup"><span data-stu-id="e6f13-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="e6f13-145">方法可能包含一个参数列表，这些参数表示传递给方法的值或变量引用。</span><span class="sxs-lookup"><span data-stu-id="e6f13-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="e6f13-146">方法具有返回类型，它用于指定方法计算和返回的值的类型。</span><span class="sxs-lookup"><span data-stu-id="e6f13-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="e6f13-147">如果方法未返回值，则它的返回类型为 `void`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="e6f13-148">方法可能也包含一组类型参数，必须在调用方法时指定类型自变量，这一点与类型一样。</span><span class="sxs-lookup"><span data-stu-id="e6f13-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="e6f13-149">与类型不同的是，通常可以根据方法调用的自变量推断出类型自变量，无需显式指定。</span><span class="sxs-lookup"><span data-stu-id="e6f13-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="e6f13-150">在声明方法的类中，方法的 *签名* 必须是唯一的。</span><span class="sxs-lookup"><span data-stu-id="e6f13-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="e6f13-151">方法签名包含方法名称、类型参数数量及其参数的数量、修饰符和类型。</span><span class="sxs-lookup"><span data-stu-id="e6f13-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="e6f13-152">方法签名不包含返回类型。</span><span class="sxs-lookup"><span data-stu-id="e6f13-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="e6f13-153">当方法主体是单个表达式时，可使用紧凑表达式格式定义方法，如下例中所示：</span><span class="sxs-lookup"><span data-stu-id="e6f13-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="e6f13-154">参数</span><span class="sxs-lookup"><span data-stu-id="e6f13-154">Parameters</span></span>

<span data-ttu-id="e6f13-155">参数用于将值或变量引用传递给方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="e6f13-156">方法参数从调用方法时指定的 *自变量* 中获取其实际值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="e6f13-157">有四类参数：值参数、引用参数、输出参数和参数数组。</span><span class="sxs-lookup"><span data-stu-id="e6f13-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="e6f13-158">值参数用于传递输入自变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="e6f13-159">值参数对应于局部变量，从为其传递的自变量中获取初始值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="e6f13-160">修改值形参不会影响为其传递的实参。</span><span class="sxs-lookup"><span data-stu-id="e6f13-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="e6f13-161">可以指定默认值，从而省略相应的自变量，这样值参数就是可选的。</span><span class="sxs-lookup"><span data-stu-id="e6f13-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="e6f13-162">引用参数用于按引用传递自变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="e6f13-163">为引用参数传递的自变量必须是一个带有明确值的变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="e6f13-164">在方法执行期间，引用参数指出的存储位置与自变量相同。</span><span class="sxs-lookup"><span data-stu-id="e6f13-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="e6f13-165">引用参数使用 `ref` 修饰符进行声明。</span><span class="sxs-lookup"><span data-stu-id="e6f13-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="e6f13-166">下面的示例展示了如何使用 `ref` 参数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="e6f13-167">输出参数用于按引用传递自变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="e6f13-168">输出参数与引用参数类似，不同之处在于，不要求向调用方提供的自变量显式赋值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="e6f13-169">输出参数使用 `out` 修饰符进行声明。</span><span class="sxs-lookup"><span data-stu-id="e6f13-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="e6f13-170">下面的示例演示如何通过 C# 7 中引入的语法使用 `out` 参数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="e6f13-171">*参数数组* 允许向方法传递数量不定的自变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="e6f13-172">参数数组使用 `params` 修饰符进行声明。</span><span class="sxs-lookup"><span data-stu-id="e6f13-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="e6f13-173">参数数组只能是方法的最后一个参数，且参数数组的类型必须是一维数组类型。</span><span class="sxs-lookup"><span data-stu-id="e6f13-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="e6f13-174"><xref:System.Console?displayProperty=nameWithType> 类的 `Write` 和 `WriteLine` 方法是参数数组用法的典型示例。</span><span class="sxs-lookup"><span data-stu-id="e6f13-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="e6f13-175">它们的声明方式如下。</span><span class="sxs-lookup"><span data-stu-id="e6f13-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="e6f13-176">在使用参数数组的方法中，参数数组的行为与数组类型的常规参数完全相同。</span><span class="sxs-lookup"><span data-stu-id="e6f13-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="e6f13-177">不过，在调用包含形参数组的方法时，要么可以传递形参数组类型的一个实参，要么可以传递形参数组的元素类型的任意数量实参。</span><span class="sxs-lookup"><span data-stu-id="e6f13-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="e6f13-178">在后一种情况中，数组实例会自动创建，并初始化为包含给定的自变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="e6f13-179">以下示例：</span><span class="sxs-lookup"><span data-stu-id="e6f13-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="e6f13-180">等同于编写以下代码：</span><span class="sxs-lookup"><span data-stu-id="e6f13-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="e6f13-181">方法主体和局部变量</span><span class="sxs-lookup"><span data-stu-id="e6f13-181">Method body and local variables</span></span>

<span data-ttu-id="e6f13-182">方法主体指定了在调用方法时执行的语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="e6f13-183">方法主体可以声明特定于方法调用的变量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="e6f13-184">此类变量称为 *局部变量*。</span><span class="sxs-lookup"><span data-stu-id="e6f13-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="e6f13-185">局部变量声明指定了类型名称、变量名称以及可能的初始值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="e6f13-186">下面的示例声明了初始值为零的局部变量 `i` 和无初始值的局部变量 `j`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="e6f13-187">C# 要求必须先 *明确赋值* 局部变量，然后才能获取其值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="e6f13-188">例如，如果上述 `i` 的声明未包含初始值，那么编译器会在后续使用 `i` 时报告错误，因为在后续使用时 `i` 不会在程序中得到明确赋值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="e6f13-189">方法可以使用 `return` 语句将控制权返回给调用方。</span><span class="sxs-lookup"><span data-stu-id="e6f13-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="e6f13-190">在返回 `void` 的方法中，`return` 语句无法指定表达式。</span><span class="sxs-lookup"><span data-stu-id="e6f13-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="e6f13-191">在不返回 void 的方法中，`return` 语句必须包括用于计算返回值的表达式。</span><span class="sxs-lookup"><span data-stu-id="e6f13-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="e6f13-192">静态和实例方法</span><span class="sxs-lookup"><span data-stu-id="e6f13-192">Static and instance methods</span></span>

<span data-ttu-id="e6f13-193">使用 `static` 修饰符声明的方法是静态方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="e6f13-194">静态方法不对特定的实例起作用，只能直接访问静态成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="e6f13-195">未使用 `static` 修饰符声明的方法是实例方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="e6f13-196">实例方法对特定的实例起作用，并能够访问静态和实例成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="e6f13-197">其中调用实例方法的实例可以作为 `this` 显式访问。</span><span class="sxs-lookup"><span data-stu-id="e6f13-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="e6f13-198">在静态方法中引用 `this` 会生成错误。</span><span class="sxs-lookup"><span data-stu-id="e6f13-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="e6f13-199">以下 `Entity` 类包含静态和实例成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="e6f13-200">每个 `Entity` 实例均有一个序列号（很可能包含此处未显示的其他一些信息）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="e6f13-201">`Entity` 构造函数（类似于实例方法）将新实例初始化为包含下一个可用的序列号。</span><span class="sxs-lookup"><span data-stu-id="e6f13-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="e6f13-202">由于构造函数是实例成员，因此可以访问 `_serialNo` 实例字段和 `s_nextSerialNo` 静态字段。</span><span class="sxs-lookup"><span data-stu-id="e6f13-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="e6f13-203">`GetNextSerialNo` 和 `SetNextSerialNo` 静态方法可以访问 `s_nextSerialNo` 静态字段，但如果直接访问 `_serialNo` 实例字段，则会生成错误。</span><span class="sxs-lookup"><span data-stu-id="e6f13-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="e6f13-204">下例显示了 `Entity` 类的用法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="e6f13-205">`SetNextSerialNo` 和 `GetNextSerialNo` 静态方法在类中进行调用，而 `GetSerialNo` 实例方法则是在类实例中进行调用。</span><span class="sxs-lookup"><span data-stu-id="e6f13-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="e6f13-206">虚方法、重写方法和抽象方法</span><span class="sxs-lookup"><span data-stu-id="e6f13-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="e6f13-207">如果实例方法声明中有 `virtual` 修饰符，可以将实例方法称为“*虚方法*”。</span><span class="sxs-lookup"><span data-stu-id="e6f13-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="e6f13-208">如果没有 virtual 修饰符，可以将实例方法称为“*非虚方法*”。</span><span class="sxs-lookup"><span data-stu-id="e6f13-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="e6f13-209">调用虚方法时，为其调用方法的实例的 *运行时类型* 决定了要调用的实际方法实现代码。</span><span class="sxs-lookup"><span data-stu-id="e6f13-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="e6f13-210">调用非虚方法时，实例的 *编译时类型* 是决定性因素。</span><span class="sxs-lookup"><span data-stu-id="e6f13-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="e6f13-211">可以在派生类中 *重写* 虚方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="e6f13-212">如果实例方法声明中有 override 修饰符，那么实例方法可以重写签名相同的继承虚方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="e6f13-213">虚方法声明引入了新方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="e6f13-214">重写方法声明通过提供现有继承的虚方法的新实现，专门针对该方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="e6f13-215">*抽象方法* 是没有实现代码的虚方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="e6f13-216">抽象方法使用 `abstract` 修饰符进行声明，仅可在抽象类中使用。</span><span class="sxs-lookup"><span data-stu-id="e6f13-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="e6f13-217">必须在所有非抽象派生类中重写抽象方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="e6f13-218">下面的示例声明了一个抽象类 `Expression`，用于表示表达式树节点；还声明了三个派生类（`Constant`、`VariableReference` 和 `Operation`），用于实现常量、变量引用和算术运算的表达式树节点。</span><span class="sxs-lookup"><span data-stu-id="e6f13-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="e6f13-219">（该示例与表达式树类型相似，但与它无关）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="e6f13-220">上面的四个类可用于进行算术表达式建模。</span><span class="sxs-lookup"><span data-stu-id="e6f13-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="e6f13-221">例如，使用这些类的实例，可以按如下方式表示表达式 `x + 3`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="e6f13-222">调用 `Expression` 实例的 `Evaluate` 方法可以计算给定的表达式并生成 `double` 值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="e6f13-223">此方法需要使用自变量 `Dictionary`，其中包含变量名称（作为项键）和值（作为项值）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="e6f13-224">因为 `Evaluate` 是一个抽象方法，因此派生自 `Expression` 的非抽象类必须替代 `Evaluate`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="e6f13-225">`Constant` 的 `Evaluate` 实现代码只返回存储的常量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="e6f13-226">`VariableReference` 实现代码查找字典中的变量名称，并返回结果值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="e6f13-227">`Operation` 实现代码先计算左右操作数（以递归方式调用其 `Evaluate` 方法），然后执行给定的算术运算。</span><span class="sxs-lookup"><span data-stu-id="e6f13-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="e6f13-228">以下程序使用 `Expression` 类根据不同的 `x` 和 `y` 值计算表达式 `x * (y + 2)`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="e6f13-229">方法重载</span><span class="sxs-lookup"><span data-stu-id="e6f13-229">Method overloading</span></span>

<span data-ttu-id="e6f13-230">借助方法 *重载*，同一类中可以有多个同名的方法，只要这些方法具有唯一签名即可。</span><span class="sxs-lookup"><span data-stu-id="e6f13-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="e6f13-231">编译如何调用重载的方法时，编译器使用 *重载决策* 来确定要调用的特定方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="e6f13-232">重载决策会查找与自变量匹配度最高的一种方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="e6f13-233">如果找不到任何最佳匹配项，则会报告错误。</span><span class="sxs-lookup"><span data-stu-id="e6f13-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="e6f13-234">下面的示例展示了重载决策的实际工作方式。</span><span class="sxs-lookup"><span data-stu-id="e6f13-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="e6f13-235">`UsageExample` 方法中每个调用的注释指明了调用的方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="e6f13-236">如示例所示，可将自变量显式转换成确切的参数类型和类型自变量，随时选择特定的方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="e6f13-237">其他函数成员</span><span class="sxs-lookup"><span data-stu-id="e6f13-237">Other function members</span></span>

<span data-ttu-id="e6f13-238">包含可执行代码的成员统称为类的 *函数成员*。</span><span class="sxs-lookup"><span data-stu-id="e6f13-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="e6f13-239">上一部分介绍了作为主要函数成员类型的方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="e6f13-240">此部分将介绍 C# 支持的其他类型函数成员：构造函数、属性、索引器、事件、运算符和终结器。</span><span class="sxs-lookup"><span data-stu-id="e6f13-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="e6f13-241">下面的示例展示了 `MyList<T>` 泛型类，用于实现对象的可扩充列表。</span><span class="sxs-lookup"><span data-stu-id="e6f13-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="e6f13-242">此类包含最常见类型函数成员的多个示例。</span><span class="sxs-lookup"><span data-stu-id="e6f13-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="e6f13-243">构造函数</span><span class="sxs-lookup"><span data-stu-id="e6f13-243">Constructors</span></span>

<span data-ttu-id="e6f13-244">C# 支持实例和静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="e6f13-245">*实例构造函数* 是实现初始化类实例所需执行的操作的成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="e6f13-246">静态构造函数是实现在首次加载类时初始化类本身所需执行的操作的成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="e6f13-247">构造函数的声明方式与方法一样，都没有返回类型，且与所含类同名。</span><span class="sxs-lookup"><span data-stu-id="e6f13-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="e6f13-248">如果构造函数声明包含 `static` 修饰符，则声明的是静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="e6f13-249">否则，声明的是实例构造函数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="e6f13-250">实例构造函数可重载并且可具有可选参数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="e6f13-251">例如，`MyList<T>` 类声明一个具有单个可选 `int` 参数的实例构造函数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="e6f13-252">实例构造函数使用 `new` 运算符进行调用。</span><span class="sxs-lookup"><span data-stu-id="e6f13-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="e6f13-253">下面的语句使用包含和不包含可选自变量的 `MyList` 类构造函数来分配两个 `MyList<string>` 实例。</span><span class="sxs-lookup"><span data-stu-id="e6f13-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="e6f13-254">与其他成员不同，实例构造函数不会被继承。</span><span class="sxs-lookup"><span data-stu-id="e6f13-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="e6f13-255">类中只能包含实际上已在该类中声明的实例构造函数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="e6f13-256">如果没有为类提供实例构造函数，则会自动提供不含参数的空实例构造函数。</span><span class="sxs-lookup"><span data-stu-id="e6f13-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="e6f13-257">“属性”</span><span class="sxs-lookup"><span data-stu-id="e6f13-257">Properties</span></span>

<span data-ttu-id="e6f13-258">*属性* 是字段的自然扩展。</span><span class="sxs-lookup"><span data-stu-id="e6f13-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="e6f13-259">两者都是包含关联类型的已命名成员，用于访问字段和属性的语法也是一样的。</span><span class="sxs-lookup"><span data-stu-id="e6f13-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="e6f13-260">不过，与字段不同的是，属性不指明存储位置。</span><span class="sxs-lookup"><span data-stu-id="e6f13-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="e6f13-261">相反，属性包含访问器，用于指定在读取或写入属性值时执行的语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="e6f13-262">属性的声明方式与字段相似，区别是属性声明以在分隔符 `{` 和 `}` 之间写入的 get 访问器或 set 访问器结束，而不是以分号结束。</span><span class="sxs-lookup"><span data-stu-id="e6f13-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="e6f13-263">同时具有 get 访问器和 set 访问器的属性是“读写属性”。</span><span class="sxs-lookup"><span data-stu-id="e6f13-263">A property that has both a get accessor and a set accessor is a *read-write property*.</span></span> <span data-ttu-id="e6f13-264">只有 get 访问器的属性是“只读属性”。</span><span class="sxs-lookup"><span data-stu-id="e6f13-264">A property that has only a get accessor is a *read-only property*.</span></span> <span data-ttu-id="e6f13-265">只有 set 访问器的属性是“只写属性”。</span><span class="sxs-lookup"><span data-stu-id="e6f13-265">A property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="e6f13-266">get 访问器对应于包含属性类型的返回值的无参数方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-266">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="e6f13-267">set 访问器对应于包含一个名为 value 的参数但不含返回类型的方法。</span><span class="sxs-lookup"><span data-stu-id="e6f13-267">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="e6f13-268">get 访问器会计算属性的值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-268">The get accessor computes the value of the property.</span></span> <span data-ttu-id="e6f13-269">set 访问器会为属性提供新值。</span><span class="sxs-lookup"><span data-stu-id="e6f13-269">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="e6f13-270">当属性是赋值的目标，或者是 `++` 或 `--` 的操作数时，会调用 set 访问器。</span><span class="sxs-lookup"><span data-stu-id="e6f13-270">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="e6f13-271">在引用了属性的其他情况下，会调用 get 访问器。</span><span class="sxs-lookup"><span data-stu-id="e6f13-271">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="e6f13-272">`MyList<T>` 类声明以下两个属性：`Count` 和 `Capacity`（分别为只读和读写）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-272">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="e6f13-273">以下示例代码展示了如何使用这些属性：</span><span class="sxs-lookup"><span data-stu-id="e6f13-273">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="e6f13-274">类似于字段和方法，C# 支持实例属性和静态属性。</span><span class="sxs-lookup"><span data-stu-id="e6f13-274">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="e6f13-275">静态属性使用静态修饰符进行声明，而实例属性则不使用静态修饰符进行声明。</span><span class="sxs-lookup"><span data-stu-id="e6f13-275">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="e6f13-276">属性的访问器可以是虚的。</span><span class="sxs-lookup"><span data-stu-id="e6f13-276">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="e6f13-277">如果属性声明包含 `virtual`、`abstract` 或 `override` 修饰符，则适用于属性的访问器。</span><span class="sxs-lookup"><span data-stu-id="e6f13-277">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="e6f13-278">索引器</span><span class="sxs-lookup"><span data-stu-id="e6f13-278">Indexers</span></span>

<span data-ttu-id="e6f13-279">借助 *索引器* 成员，可以将对象编入索引（像处理数组一样）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-279">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="e6f13-280">索引器的声明方式与属性类似，不同之处在于，索引器成员名称格式为 `this` 后跟在分隔符 `[` 和 `]` 内写入的参数列表。</span><span class="sxs-lookup"><span data-stu-id="e6f13-280">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="e6f13-281">这些参数在索引器的访问器中可用。</span><span class="sxs-lookup"><span data-stu-id="e6f13-281">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="e6f13-282">类似于属性，索引器分为读写、只读和只写索引器，且索引器的访问器可以是虚的。</span><span class="sxs-lookup"><span data-stu-id="e6f13-282">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="e6f13-283">`MyList<T>` 类声明一个需要使用 `int` 参数的读写索引器。</span><span class="sxs-lookup"><span data-stu-id="e6f13-283">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="e6f13-284">借助索引器，可以使用 `int` 值将 `MyList<T>` 实例编入索引。</span><span class="sxs-lookup"><span data-stu-id="e6f13-284">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="e6f13-285">例如：</span><span class="sxs-lookup"><span data-stu-id="e6f13-285">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="e6f13-286">索引器可被重载。</span><span class="sxs-lookup"><span data-stu-id="e6f13-286">Indexers can be overloaded.</span></span> <span data-ttu-id="e6f13-287">一个类可声明多个索引器，只要其参数的数量或类型不同即可。</span><span class="sxs-lookup"><span data-stu-id="e6f13-287">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="e6f13-288">事件</span><span class="sxs-lookup"><span data-stu-id="e6f13-288">Events</span></span>

<span data-ttu-id="e6f13-289">借助 *事件* 成员，类或对象可以提供通知。</span><span class="sxs-lookup"><span data-stu-id="e6f13-289">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="e6f13-290">事件的声明方式与字段类似，区别是事件声明包括 `event` 关键字，且类型必须是委托类型。</span><span class="sxs-lookup"><span data-stu-id="e6f13-290">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="e6f13-291">在声明事件成员的类中，事件的行为与委托类型的字段完全相同（前提是事件不是抽象的，且不声明访问器）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-291">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="e6f13-292">字段存储对委托的引用，委托表示已添加到事件的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e6f13-292">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="e6f13-293">如果没有任何事件处理程序，则字段为 `null`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-293">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="e6f13-294">`MyList<T>` 类声明一个 `Changed` 事件成员，指明已向列表添加了新项。</span><span class="sxs-lookup"><span data-stu-id="e6f13-294">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="e6f13-295">Changed 事件由 `OnChanged` 虚方法引发，此方法会先检查事件是否是 `null`（即不含任何处理程序）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-295">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="e6f13-296">引发事件的概念恰恰等同于调用由事件表示的委托。</span><span class="sxs-lookup"><span data-stu-id="e6f13-296">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="e6f13-297">不存在用于引发事件的特殊语言构造。</span><span class="sxs-lookup"><span data-stu-id="e6f13-297">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="e6f13-298">客户端通过 *事件处理程序* 响应事件。</span><span class="sxs-lookup"><span data-stu-id="e6f13-298">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="e6f13-299">使用 `+=` 和 `-=` 运算符分别可以附加和删除事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e6f13-299">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="e6f13-300">下面的示例展示了如何向 `MyList<string>` 的 `Changed` 事件附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e6f13-300">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="e6f13-301">对于需要控制事件的基础存储的高级方案，事件声明可以显式提供 `add` 和 `remove` 访问器，这与属性的 `set` 访问器类似。</span><span class="sxs-lookup"><span data-stu-id="e6f13-301">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="e6f13-302">运算符</span><span class="sxs-lookup"><span data-stu-id="e6f13-302">Operators</span></span>

<span data-ttu-id="e6f13-303">*运算符* 是定义向类实例应用特定表达式运算符的含义的成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-303">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="e6f13-304">可以定义三种类型的运算符：一元运算符、二元运算符和转换运算符。</span><span class="sxs-lookup"><span data-stu-id="e6f13-304">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="e6f13-305">所有运算符都必须声明为 `public` 和 `static`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-305">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="e6f13-306">`MyList<T>` 类会声明两个运算符：`operator ==` 和 `operator !=`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-306">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="e6f13-307">对于向 `MyList` 实例应用这些运算符的表达式来说，这些重写的运算符向它们赋予了新的含义。</span><span class="sxs-lookup"><span data-stu-id="e6f13-307">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="e6f13-308">具体而言，这些运算符定义的是两个 `MyList<T>` 实例的相等性（使用其 `Equals` 方法比较所包含的每个对象）。</span><span class="sxs-lookup"><span data-stu-id="e6f13-308">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="e6f13-309">下面的示例展示了如何使用 `==` 运算符比较两个 `MyList<int>` 实例。</span><span class="sxs-lookup"><span data-stu-id="e6f13-309">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="e6f13-310">第一个 `Console.WriteLine` 输出 `True`，因为两个列表包含的对象不仅数量相同，而且值和顺序也相同。</span><span class="sxs-lookup"><span data-stu-id="e6f13-310">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="e6f13-311">如果 `MyList<T>` 未定义 `operator ==`，那么第一个 `Console.WriteLine` 会输出 `False`，因为 `a` 和 `b` 引用不同的 `MyList<int>` 实例。</span><span class="sxs-lookup"><span data-stu-id="e6f13-311">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="e6f13-312">终结器</span><span class="sxs-lookup"><span data-stu-id="e6f13-312">Finalizers</span></span>

<span data-ttu-id="e6f13-313">*终结器* 是实现完成类实例所需的操作的成员。</span><span class="sxs-lookup"><span data-stu-id="e6f13-313">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="e6f13-314">通常，需要使用终结器来释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="e6f13-314">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="e6f13-315">终结器既不能包含参数和可访问性修饰符，也不能进行显式调用。</span><span class="sxs-lookup"><span data-stu-id="e6f13-315">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="e6f13-316">实例的终结器在垃圾回收期间自动调用。</span><span class="sxs-lookup"><span data-stu-id="e6f13-316">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="e6f13-317">有关详细信息，请参阅[终结器](../programming-guide/classes-and-structs/destructors.md)一文。</span><span class="sxs-lookup"><span data-stu-id="e6f13-317">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="e6f13-318">垃圾回收器在决定何时收集对象和运行终结器时有很大自由度。</span><span class="sxs-lookup"><span data-stu-id="e6f13-318">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="e6f13-319">具体而言，终结器的调用时间具有不确定性，可以在任意线程上执行终结器。</span><span class="sxs-lookup"><span data-stu-id="e6f13-319">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="e6f13-320">因为这样或那样的原因，只有在没有其他可行的解决方案时，类才能实现终结器。</span><span class="sxs-lookup"><span data-stu-id="e6f13-320">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="e6f13-321">处理对象析构的更好方法是使用 `using` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-321">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="e6f13-322">表达式</span><span class="sxs-lookup"><span data-stu-id="e6f13-322">Expressions</span></span>

<span data-ttu-id="e6f13-323">*表达式* 是在 *操作数* 和 *运算符* 的基础之上构造而成。</span><span class="sxs-lookup"><span data-stu-id="e6f13-323">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="e6f13-324">表达式的运算符指明了向操作数应用的运算。</span><span class="sxs-lookup"><span data-stu-id="e6f13-324">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="e6f13-325">运算符的示例包括 `+`、`-`、`*`、`/` 和 `new`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-325">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="e6f13-326">操作数的示例包括文本、字段、局部变量和表达式。</span><span class="sxs-lookup"><span data-stu-id="e6f13-326">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="e6f13-327">如果某个表达式包含多个运算符，则运算符的优先顺序控制各个运算符的计算顺序。</span><span class="sxs-lookup"><span data-stu-id="e6f13-327">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="e6f13-328">例如，表达式 `x + y * z` 相当于计算 `x + (y * z)`，因为 `*` 运算符的优先级高于 `+` 运算符。</span><span class="sxs-lookup"><span data-stu-id="e6f13-328">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="e6f13-329">如果操作数两边的两个运算符的优先级相同，那么运算符的 *结合性* 决定了运算的执行顺序：</span><span class="sxs-lookup"><span data-stu-id="e6f13-329">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="e6f13-330">除了赋值运算符和 null 合并运算符之外，所有二元运算符均为左结合运算符，即从左向右执行运算。</span><span class="sxs-lookup"><span data-stu-id="e6f13-330">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="e6f13-331">例如，`x + y + z` 将计算为 `(x + y) + z`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-331">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="e6f13-332">赋值运算符、null 合并 `??` 和 `??=` 运算符和条件运算符 `?:` 为右结合运算符，即从右向左执行运算。</span><span class="sxs-lookup"><span data-stu-id="e6f13-332">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="e6f13-333">例如，`x = y = z` 将计算为 `x = (y = z)`。</span><span class="sxs-lookup"><span data-stu-id="e6f13-333">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="e6f13-334">可以使用括号控制优先级和结合性。</span><span class="sxs-lookup"><span data-stu-id="e6f13-334">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="e6f13-335">例如，`x + y * z` 先计算 `y` 乘 `z`，并将结果与 `x` 相加，而 `(x + y) * z` 则先计算 `x` 加 `y`，然后将结果与 `z` 相乘。</span><span class="sxs-lookup"><span data-stu-id="e6f13-335">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="e6f13-336">大部分运算符可 [*重载*](../language-reference/operators/operator-overloading.md)。</span><span class="sxs-lookup"><span data-stu-id="e6f13-336">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="e6f13-337">借助运算符重载，可以为一个或两个操作数为用户定义类或结构类型的运算指定用户定义运算符实现代码。</span><span class="sxs-lookup"><span data-stu-id="e6f13-337">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="e6f13-338">C# 提供多个运算符用于执行[算术](../language-reference/operators/arithmetic-operators.md)、[逻辑](../language-reference/operators/boolean-logical-operators.md)、[按位和移位](../language-reference/operators/bitwise-and-shift-operators.md)运算以及[相等](../language-reference/operators/equality-operators.md)和[排序](../language-reference/operators/comparison-operators.md)比较。</span><span class="sxs-lookup"><span data-stu-id="e6f13-338">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="e6f13-339">要了解按优先级排序的完整 C# 运算符列表，请参阅 [C# 运算符](../language-reference/operators/index.md)。</span><span class="sxs-lookup"><span data-stu-id="e6f13-339">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="e6f13-340">语句</span><span class="sxs-lookup"><span data-stu-id="e6f13-340">Statements</span></span>

<span data-ttu-id="e6f13-341">程序操作使用 *语句* 进行表示。</span><span class="sxs-lookup"><span data-stu-id="e6f13-341">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="e6f13-342">C# 支持几种不同的语句，其中许多语句是从嵌入语句的角度来定义的。</span><span class="sxs-lookup"><span data-stu-id="e6f13-342">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="e6f13-343">使用 *代码块*，可以在允许编写一个语句的上下文中编写多个语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-343">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="e6f13-344">代码块是由一系列在分隔符 `{` 和 `}` 内编写的语句组成。</span><span class="sxs-lookup"><span data-stu-id="e6f13-344">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="e6f13-345">*声明语句* 用于声明局部变量和常量。</span><span class="sxs-lookup"><span data-stu-id="e6f13-345">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="e6f13-346">*表达式语句* 用于计算表达式。</span><span class="sxs-lookup"><span data-stu-id="e6f13-346">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="e6f13-347">可用作语句的表达式包括方法调用、使用 `new` 运算符的对象分配、使用 `=` 和复合赋值运算符的赋值、使用 `++` 和 `--` 运算符和 `await` 表达式的递增和递减运算。</span><span class="sxs-lookup"><span data-stu-id="e6f13-347">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="e6f13-348">*选择语句* 用于根据一些表达式的值从多个可能的语句中选择一个以供执行。</span><span class="sxs-lookup"><span data-stu-id="e6f13-348">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="e6f13-349">此组包含 `if` 和 `switch` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-349">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="e6f13-350">*迭代语句* 用于重复执行嵌入语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-350">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="e6f13-351">此组包含 `while`、`do`、`for` 和 `foreach` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-351">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="e6f13-352">*跳转语句* 用于转移控制权。</span><span class="sxs-lookup"><span data-stu-id="e6f13-352">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="e6f13-353">此组包含 `break`、`continue`、`goto`、`throw`、`return` 和 `yield` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-353">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="e6f13-354">`try`...`catch` 语句用于捕获在代码块执行期间发生的异常，`try`...`finally` 语句用于指定始终执行的最终代码，无论异常发生与否。</span><span class="sxs-lookup"><span data-stu-id="e6f13-354">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="e6f13-355">`checked` 和 `unchecked` 语句用于控制整型类型算术运算和转换的溢出检查上下文。</span><span class="sxs-lookup"><span data-stu-id="e6f13-355">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="e6f13-356">`lock` 语句用于获取给定对象的相互排斥锁定，执行语句，然后解除锁定。</span><span class="sxs-lookup"><span data-stu-id="e6f13-356">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="e6f13-357">`using` 语句用于获取资源，执行语句，然后释放资源。</span><span class="sxs-lookup"><span data-stu-id="e6f13-357">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="e6f13-358">下面列出了可使用的语句类型：</span><span class="sxs-lookup"><span data-stu-id="e6f13-358">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="e6f13-359">局部变量声明。</span><span class="sxs-lookup"><span data-stu-id="e6f13-359">Local variable declaration.</span></span>
* <span data-ttu-id="e6f13-360">局部常量声明。</span><span class="sxs-lookup"><span data-stu-id="e6f13-360">Local constant declaration.</span></span>
* <span data-ttu-id="e6f13-361">表达式语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-361">Expression statement.</span></span>
* <span data-ttu-id="e6f13-362">`if` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-362">`if` statement.</span></span>
* <span data-ttu-id="e6f13-363">`switch` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-363">`switch` statement.</span></span>
* <span data-ttu-id="e6f13-364">`while` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-364">`while` statement.</span></span>
* <span data-ttu-id="e6f13-365">`do` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-365">`do` statement.</span></span>
* <span data-ttu-id="e6f13-366">`for` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-366">`for` statement.</span></span>
* <span data-ttu-id="e6f13-367">`foreach` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-367">`foreach` statement.</span></span>
* <span data-ttu-id="e6f13-368">`break` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-368">`break` statement.</span></span>
* <span data-ttu-id="e6f13-369">`continue` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-369">`continue` statement.</span></span>
* <span data-ttu-id="e6f13-370">`goto` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-370">`goto` statement.</span></span>
* <span data-ttu-id="e6f13-371">`return` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-371">`return` statement.</span></span>
* <span data-ttu-id="e6f13-372">`yield` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-372">`yield` statement.</span></span>
* <span data-ttu-id="e6f13-373">`throw` 和 `try` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-373">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="e6f13-374">`checked` 和 `unchecked` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-374">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="e6f13-375">`lock` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-375">`lock` statement.</span></span>
* <span data-ttu-id="e6f13-376">`using` 语句。</span><span class="sxs-lookup"><span data-stu-id="e6f13-376">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e6f13-377">[上一页](types.md)
>[下一页](features.md)</span><span class="sxs-lookup"><span data-stu-id="e6f13-377">[Previous](types.md)
[Next](features.md)</span></span>
