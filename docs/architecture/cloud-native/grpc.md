---
title: gRPC
description: 了解 gRPC，它在云本机应用程序中的作用，以及它与 HTTP RESTful 通信有何不同。
author: robvet
no-loc:
- Blazor
- Blazor WebAssembly
ms.date: 01/19/2021
ms.openlocfilehash: 8667f2d3a7a19aa6dffdd8ce8bef103eab5cc54f
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505695"
---
# <a name="grpc"></a><span data-ttu-id="aea0b-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="aea0b-103">gRPC</span></span>

<span data-ttu-id="aea0b-104">到目前为止，我们致力于 [基于 REST 的](/azure/architecture/best-practices/api-design) 通信。</span><span class="sxs-lookup"><span data-stu-id="aea0b-104">So far in this book, we've focused on [REST-based](/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="aea0b-105">我们已经看到，REST 是一种灵活的体系结构样式，它定义了对实体资源的基于 CRUD 的操作。</span><span class="sxs-lookup"><span data-stu-id="aea0b-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="aea0b-106">客户端使用请求/响应通信模型跨 HTTP 与资源进行交互。</span><span class="sxs-lookup"><span data-stu-id="aea0b-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="aea0b-107">尽管 REST 是广泛实现的，但一种较新的通信技术 gRPC 已在云本机社区中获得巨大的动力。</span><span class="sxs-lookup"><span data-stu-id="aea0b-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="aea0b-108">什么是 gRPC？</span><span class="sxs-lookup"><span data-stu-id="aea0b-108">What is gRPC?</span></span>

<span data-ttu-id="aea0b-109">gRPC 是一种新式的高性能框架， (RPC) 协议演变旧的 [远程过程调用 ](https://en.wikipedia.org/wiki/Remote_procedure_call) 。</span><span class="sxs-lookup"><span data-stu-id="aea0b-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="aea0b-110">在应用程序级别，gRPC 简化了客户端和后端服务之间的消息传送。</span><span class="sxs-lookup"><span data-stu-id="aea0b-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="aea0b-111">GRPC 是源自 Google 的开源和  [云本机计算基础的一部分 () CNCF ](https://www.cncf.io/) 云本机产品/服务的生态系统。</span><span class="sxs-lookup"><span data-stu-id="aea0b-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="aea0b-112">CNCF 考虑 gRPC [孵化项目](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)。</span><span class="sxs-lookup"><span data-stu-id="aea0b-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="aea0b-113">孵化表示最终用户在生产应用程序中使用技术，而项目的参与者数量是正常的。</span><span class="sxs-lookup"><span data-stu-id="aea0b-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="aea0b-114">典型的 gRPC 客户端应用程序将公开一个用于实现业务操作的本地进程内函数。</span><span class="sxs-lookup"><span data-stu-id="aea0b-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="aea0b-115">在这种情况下，该本地函数调用远程计算机上的另一个函数。</span><span class="sxs-lookup"><span data-stu-id="aea0b-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="aea0b-116">本地调用似乎是对远程服务的透明进程外调用。</span><span class="sxs-lookup"><span data-stu-id="aea0b-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="aea0b-117">RPC 管道对计算机之间的点到点网络通信、序列化和执行进行了抽象。</span><span class="sxs-lookup"><span data-stu-id="aea0b-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="aea0b-118">在云本机应用程序中，开发人员通常跨编程语言、框架和技术。</span><span class="sxs-lookup"><span data-stu-id="aea0b-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="aea0b-119">此 *互操作性* 使消息协定和跨平台通信所需的管道复杂化。</span><span class="sxs-lookup"><span data-stu-id="aea0b-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="aea0b-120">gRPC 提供了一个 "统一的水平层" 来抽象这些问题。</span><span class="sxs-lookup"><span data-stu-id="aea0b-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="aea0b-121">开发人员代码在其本地平台上侧重于业务功能，而 gRPC 则负责处理通信。</span><span class="sxs-lookup"><span data-stu-id="aea0b-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="aea0b-122">gRPC 提供跨最常见开发堆栈（包括 Java、JavaScript、c #、中转、Swift 和 NodeJS）的全面支持。</span><span class="sxs-lookup"><span data-stu-id="aea0b-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="aea0b-123">gRPC 权益</span><span class="sxs-lookup"><span data-stu-id="aea0b-123">gRPC Benefits</span></span>

<span data-ttu-id="aea0b-124">gRPC 对其传输协议使用 HTTP/2。</span><span class="sxs-lookup"><span data-stu-id="aea0b-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="aea0b-125">与 HTTP 1.1 兼容，HTTP/2 功能很多高级功能：</span><span class="sxs-lookup"><span data-stu-id="aea0b-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="aea0b-126">用于数据传输的二进制组帧协议-与基于文本的 HTTP 1.1 不同。</span><span class="sxs-lookup"><span data-stu-id="aea0b-126">A binary framing protocol for data transport - unlike HTTP 1.1, which is text based.</span></span>
- <span data-ttu-id="aea0b-127">多路复用支持通过同一连接发送多个并行请求-HTTP 1.1 限制处理一次请求/响应消息。</span><span class="sxs-lookup"><span data-stu-id="aea0b-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="aea0b-128">同时发送客户端请求和服务器响应的双向全双工通信。</span><span class="sxs-lookup"><span data-stu-id="aea0b-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="aea0b-129">内置流式处理可对大型数据集进行异步流式处理的请求和响应。</span><span class="sxs-lookup"><span data-stu-id="aea0b-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>
- <span data-ttu-id="aea0b-130">减少网络使用量的标头压缩。</span><span class="sxs-lookup"><span data-stu-id="aea0b-130">Header compression that reduces network usage.</span></span>

<span data-ttu-id="aea0b-131">gRPC 是轻型且高性能的。</span><span class="sxs-lookup"><span data-stu-id="aea0b-131">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="aea0b-132">与 JSON 序列化相比，与 JSON 序列化相比，它的最高速率为60-80%。</span><span class="sxs-lookup"><span data-stu-id="aea0b-132">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="aea0b-133">在 Microsoft [Windows Communication Foundation (WCF) ](../../framework/wcf/whats-wcf.md) 行话，gRPC 性能超出了高度优化的 [wcf-nettcp 绑定](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)的速度和效率。</span><span class="sxs-lookup"><span data-stu-id="aea0b-133">In Microsoft [Windows Communication Foundation (WCF)](../../framework/wcf/whats-wcf.md) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="aea0b-134">不同于 Microsoft stack 的 Wcf-nettcp，gRPC 是跨平台的。</span><span class="sxs-lookup"><span data-stu-id="aea0b-134">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="aea0b-135">协议缓冲区</span><span class="sxs-lookup"><span data-stu-id="aea0b-135">Protocol Buffers</span></span>

<span data-ttu-id="aea0b-136">gRPC 拥有称为 [协议缓冲区](https://developers.google.com/protocol-buffers/docs/overview)的开源技术。</span><span class="sxs-lookup"><span data-stu-id="aea0b-136">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="aea0b-137">它们提供了一种高效且平台中立的序列化格式，用于序列化服务相互发送的结构化消息。</span><span class="sxs-lookup"><span data-stu-id="aea0b-137">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="aea0b-138">使用跨平台接口定义语言 (IDL) ，开发人员定义每个微服务的服务协定。</span><span class="sxs-lookup"><span data-stu-id="aea0b-138">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="aea0b-139">作为基于文本的文件实现的协定将 `.proto` 描述每个服务的方法、输入和输出。</span><span class="sxs-lookup"><span data-stu-id="aea0b-139">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="aea0b-140">同一约定文件可用于在不同开发平台上构建的 gRPC 客户端和服务。</span><span class="sxs-lookup"><span data-stu-id="aea0b-140">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="aea0b-141">使用 proto 文件，Protobuf 编译器 `protoc` 生成目标平台的客户端和服务代码。</span><span class="sxs-lookup"><span data-stu-id="aea0b-141">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="aea0b-142">此代码包括以下组件：</span><span class="sxs-lookup"><span data-stu-id="aea0b-142">The code includes the following components:</span></span>

- <span data-ttu-id="aea0b-143">由客户端和服务共享的强类型对象，表示消息的服务操作和数据元素。</span><span class="sxs-lookup"><span data-stu-id="aea0b-143">Strongly typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="aea0b-144">一个强类型的基类，其中包含远程 gRPC 服务可以继承和扩展的必需的网络管道。</span><span class="sxs-lookup"><span data-stu-id="aea0b-144">A strongly typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="aea0b-145">包含调用远程 gRPC 服务所需的管道的客户端存根。</span><span class="sxs-lookup"><span data-stu-id="aea0b-145">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="aea0b-146">在运行时，每条消息都序列化为标准 Protobuf 表示形式，并在客户端和远程服务之间交换。</span><span class="sxs-lookup"><span data-stu-id="aea0b-146">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="aea0b-147">与 JSON 或 XML 不同，Protobuf 消息会序列化为已编译的二进制字节。</span><span class="sxs-lookup"><span data-stu-id="aea0b-147">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="aea0b-148">Microsoft 体系结构站点提供了 [gRPC FOR WCF 开发人员](../grpc-for-wcf-developers/index.md)的书籍，提供了 GRPC 和协议缓冲区的深入介绍。</span><span class="sxs-lookup"><span data-stu-id="aea0b-148">The book, [gRPC for WCF Developers](../grpc-for-wcf-developers/index.md), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="aea0b-149">.NET 中的 gRPC 支持</span><span class="sxs-lookup"><span data-stu-id="aea0b-149">gRPC support in .NET</span></span>

<span data-ttu-id="aea0b-150">gRPC 集成到 .NET Core 3.0 SDK 和更高版本中。</span><span class="sxs-lookup"><span data-stu-id="aea0b-150">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="aea0b-151">以下工具支持它：</span><span class="sxs-lookup"><span data-stu-id="aea0b-151">The following tools support it:</span></span>

- <span data-ttu-id="aea0b-152">安装了 web 开发工作负荷的 Visual Studio 2019、版本16.3 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="aea0b-152">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="aea0b-153">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="aea0b-153">Visual Studio Code</span></span>
- <span data-ttu-id="aea0b-154">dotnet CLI</span><span class="sxs-lookup"><span data-stu-id="aea0b-154">the dotnet CLI</span></span>

<span data-ttu-id="aea0b-155">SDK 包括用于终结点路由、内置 IoC 和日志记录的工具。</span><span class="sxs-lookup"><span data-stu-id="aea0b-155">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="aea0b-156">开源 Kestrel web 服务器支持 HTTP/2 连接。</span><span class="sxs-lookup"><span data-stu-id="aea0b-156">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="aea0b-157">图4-20 显示了一个 Visual Studio 2019 模板，该模板基架了 gRPC 服务的主干项目。</span><span class="sxs-lookup"><span data-stu-id="aea0b-157">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="aea0b-158">请注意 .NET 如何完全支持 Windows、Linux 和 macOS。</span><span class="sxs-lookup"><span data-stu-id="aea0b-158">Note how .NET fully supports Windows, Linux, and macOS.</span></span>

![Visual Studio 2019 中的 gRPC 支持](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="aea0b-160">图 4-20  。</span><span class="sxs-lookup"><span data-stu-id="aea0b-160">**Figure 4-20**.</span></span> <span data-ttu-id="aea0b-161">Visual Studio 2019 中的 gRPC 支持</span><span class="sxs-lookup"><span data-stu-id="aea0b-161">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="aea0b-162">图4-21 显示了 Visual Studio 2019 中包含的内置基架生成的主干 gRPC 服务。</span><span class="sxs-lookup"><span data-stu-id="aea0b-162">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![Visual Studio 2019 中的 gRPC 项目](./media/grpc-project.png  )

<span data-ttu-id="aea0b-164">图 4-21  。</span><span class="sxs-lookup"><span data-stu-id="aea0b-164">**Figure 4-21**.</span></span> <span data-ttu-id="aea0b-165">Visual Studio 2019 中的 gRPC 项目</span><span class="sxs-lookup"><span data-stu-id="aea0b-165">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="aea0b-166">在上图中，记下 proto 说明文件和服务代码。</span><span class="sxs-lookup"><span data-stu-id="aea0b-166">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="aea0b-167">正如您很快将看到的那样，Visual Studio 会在 Startup 类和基础项目文件中同时生成附加配置。</span><span class="sxs-lookup"><span data-stu-id="aea0b-167">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="aea0b-168">gRPC 用法</span><span class="sxs-lookup"><span data-stu-id="aea0b-168">gRPC usage</span></span>

<span data-ttu-id="aea0b-169">为以下方案优选 gRPC：</span><span class="sxs-lookup"><span data-stu-id="aea0b-169">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="aea0b-170">同步后端微服务到微服务的通信，需要立即响应才能继续处理。</span><span class="sxs-lookup"><span data-stu-id="aea0b-170">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="aea0b-171">需要支持混合编程平台的 Polyglot 环境。</span><span class="sxs-lookup"><span data-stu-id="aea0b-171">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="aea0b-172">低延迟和高吞吐量通信，其中的性能至关重要。</span><span class="sxs-lookup"><span data-stu-id="aea0b-172">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="aea0b-173">点到点实时通信-gRPC 可以实时推送消息而无需轮询，并对双向流式处理提供了极佳支持。</span><span class="sxs-lookup"><span data-stu-id="aea0b-173">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="aea0b-174">网络约束环境–二进制 gRPC 消息始终小于等效的基于文本的 JSON 消息。</span><span class="sxs-lookup"><span data-stu-id="aea0b-174">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="aea0b-175">在撰写本文时，gRPC 主要用于后端服务。</span><span class="sxs-lookup"><span data-stu-id="aea0b-175">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="aea0b-176">新式浏览器无法提供支持前端 gRPC 客户端所需的 HTTP/2 控制级别。</span><span class="sxs-lookup"><span data-stu-id="aea0b-176">Modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="aea0b-177">这就是，有了支持 [gRPC 的 .net](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) ，它支持通过 JavaScript 或技术生成的基于浏览器的应用的 gRPC 通信 Blazor WebAssembly 。</span><span class="sxs-lookup"><span data-stu-id="aea0b-177">That said, there's support for [gRPC-Web with .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="aea0b-178">[gRPC](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) 使 ASP.NET Core gRPC 应用支持浏览器应用中的 gRPC 功能：</span><span class="sxs-lookup"><span data-stu-id="aea0b-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="aea0b-179">强类型的代码生成客户端</span><span class="sxs-lookup"><span data-stu-id="aea0b-179">Strongly typed, code-generated clients</span></span>
- <span data-ttu-id="aea0b-180">Compact Protobuf 消息</span><span class="sxs-lookup"><span data-stu-id="aea0b-180">Compact Protobuf messages</span></span>
- <span data-ttu-id="aea0b-181">服务器流式处理</span><span class="sxs-lookup"><span data-stu-id="aea0b-181">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="aea0b-182">gRPC 实现</span><span class="sxs-lookup"><span data-stu-id="aea0b-182">gRPC implementation</span></span>

<span data-ttu-id="aea0b-183">微服务参考体系结构（ [容器上的 eShop](https://github.com/dotnet-architecture/eShopOnContainers)）显示了如何在 .net 应用程序中实现 gRPC 服务。</span><span class="sxs-lookup"><span data-stu-id="aea0b-183">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET applications.</span></span> <span data-ttu-id="aea0b-184">图4-22 显示后端体系结构。</span><span class="sxs-lookup"><span data-stu-id="aea0b-184">Figure 4-22 presents the back-end architecture.</span></span>

![容器上的 eShop 的后端体系结构](./media/eshop-with-aggregators.png)

<span data-ttu-id="aea0b-186">**图 4-22**。</span><span class="sxs-lookup"><span data-stu-id="aea0b-186">**Figure 4-22**.</span></span> <span data-ttu-id="aea0b-187">容器上的 eShop 的后端体系结构</span><span class="sxs-lookup"><span data-stu-id="aea0b-187">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="aea0b-188">在上图中，请注意 eShop 如何通过公开多个 API 网关来通过 [前端模式](/azure/architecture/patterns/backends-for-frontends) (BFF) 。</span><span class="sxs-lookup"><span data-stu-id="aea0b-188">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="aea0b-189">本章前面介绍了 BFF 模式。</span><span class="sxs-lookup"><span data-stu-id="aea0b-189">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="aea0b-190">请密切注意位于 Web-Shopping API 网关和后端购物微服务之间的聚合器微服务 (灰色) 。</span><span class="sxs-lookup"><span data-stu-id="aea0b-190">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="aea0b-191">聚合器接收来自客户端的单个请求，将其调度到不同的微服务，聚合结果并将其发送回发出请求的客户端。</span><span class="sxs-lookup"><span data-stu-id="aea0b-191">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="aea0b-192">此类操作通常需要同步通信，才能生成立即响应。</span><span class="sxs-lookup"><span data-stu-id="aea0b-192">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="aea0b-193">在 eShop 中，使用 gRPC 执行从聚合器的后端调用，如图4-23 所示。</span><span class="sxs-lookup"><span data-stu-id="aea0b-193">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![容器的 eShop 中的 gRPC](./media/grpc-implementation.png)

<span data-ttu-id="aea0b-195">图 4-23  。</span><span class="sxs-lookup"><span data-stu-id="aea0b-195">**Figure 4-23**.</span></span> <span data-ttu-id="aea0b-196">容器的 eShop 中的 gRPC</span><span class="sxs-lookup"><span data-stu-id="aea0b-196">gRPC in eShop on Containers</span></span>

<span data-ttu-id="aea0b-197">gRPC 通信需要客户端和服务器组件。</span><span class="sxs-lookup"><span data-stu-id="aea0b-197">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="aea0b-198">在上图中，请注意购物聚合器如何实现 gRPC 客户端。</span><span class="sxs-lookup"><span data-stu-id="aea0b-198">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="aea0b-199">客户端将 (以红色) 对后端微服务进行同步调用，其中每个调用都实现 gRPC 服务器。</span><span class="sxs-lookup"><span data-stu-id="aea0b-199">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="aea0b-200">客户端和服务器都利用 .NET SDK 中的内置 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="aea0b-200">Both the client and server take advantage of the built-in gRPC plumbing from the .NET SDK.</span></span> <span data-ttu-id="aea0b-201">客户端 *存根* 提供用于调用远程 gRPC 调用的管道。</span><span class="sxs-lookup"><span data-stu-id="aea0b-201">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="aea0b-202">服务器端组件提供自定义服务类可以继承和使用的 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="aea0b-202">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="aea0b-203">同时公开 RESTful API 和 gRPC 通信的微服务需要使用多个终结点来管理流量。</span><span class="sxs-lookup"><span data-stu-id="aea0b-203">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="aea0b-204">你将打开一个终结点，该终结点侦听 RESTful 调用的 HTTP 流量，另一个用于 gRPC 调用。</span><span class="sxs-lookup"><span data-stu-id="aea0b-204">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="aea0b-205">必须为 gRPC 通信所需的 HTTP/2 协议配置 gRPC 终结点。</span><span class="sxs-lookup"><span data-stu-id="aea0b-205">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="aea0b-206">尽管我们正在努力将微服务与异步通信模式分离，但某些操作需要直接调用。</span><span class="sxs-lookup"><span data-stu-id="aea0b-206">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="aea0b-207">gRPC 应该是微服务之间直接同步通信的主要选择。</span><span class="sxs-lookup"><span data-stu-id="aea0b-207">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="aea0b-208">基于 HTTP/2 和协议缓冲区的高性能通信协议使其成为最佳选择。</span><span class="sxs-lookup"><span data-stu-id="aea0b-208">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="aea0b-209">正在寻找</span><span class="sxs-lookup"><span data-stu-id="aea0b-209">Looking ahead</span></span>

<span data-ttu-id="aea0b-210">仔细看，gRPC 将继续为云本机系统提供吸引力。</span><span class="sxs-lookup"><span data-stu-id="aea0b-210">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="aea0b-211">性能优势和轻松开发非常引人注目。</span><span class="sxs-lookup"><span data-stu-id="aea0b-211">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="aea0b-212">但是，REST 可能会长时间发生。</span><span class="sxs-lookup"><span data-stu-id="aea0b-212">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="aea0b-213">它 transact-sql 公开的 Api 和向后兼容性的原因。</span><span class="sxs-lookup"><span data-stu-id="aea0b-213">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="aea0b-214">[上一页](service-to-service-communication.md)
>[下一页](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="aea0b-214">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
