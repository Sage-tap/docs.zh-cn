---
title: 在 C# 中使用默认接口方法安全地更新接口
description: 本高级教程探讨了如何安全地向现有接口定义添加新功能，而不破坏实现该接口的所有类和结构。
ms.date: 05/06/2019
ms.technlogy: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 43af25cee765ba18543b0c7bfe0069542a90e0e5
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/23/2021
ms.locfileid: "104878875"
---
# <a name="tutorial-update-interfaces-with-default-interface-methods-in-c-80"></a><span data-ttu-id="1f98f-103">教程：在 C# 8.0 中使用默认接口方法更新接口</span><span class="sxs-lookup"><span data-stu-id="1f98f-103">Tutorial: Update interfaces with default interface methods in C# 8.0</span></span>

<span data-ttu-id="1f98f-104">从 .NET Core 3.0 上的 C# 8.0 开始，可以在声明接口成员时定义实现。</span><span class="sxs-lookup"><span data-stu-id="1f98f-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="1f98f-105">最常见的方案是安全地将成员添加到已经由无数客户端发布并使用的接口。</span><span class="sxs-lookup"><span data-stu-id="1f98f-105">The most common scenario is to safely add members to an interface already released and used by innumerable clients.</span></span>

<span data-ttu-id="1f98f-106">在本教程中，你将了解：</span><span class="sxs-lookup"><span data-stu-id="1f98f-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="1f98f-107">通过使用实现添加方法，安全地扩展接口。</span><span class="sxs-lookup"><span data-stu-id="1f98f-107">Extend interfaces safely by adding methods with implementations.</span></span>
> * <span data-ttu-id="1f98f-108">创建参数化实现以提供更大的灵活性。</span><span class="sxs-lookup"><span data-stu-id="1f98f-108">Create parameterized implementations to provide greater flexibility.</span></span>
> * <span data-ttu-id="1f98f-109">使实现器能够以替代的形式提供更具体的实现。</span><span class="sxs-lookup"><span data-stu-id="1f98f-109">Enable implementers to provide a more specific implementation in the form of an override.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="1f98f-110">先决条件</span><span class="sxs-lookup"><span data-stu-id="1f98f-110">Prerequisites</span></span>

<span data-ttu-id="1f98f-111">需要将计算机设置为运行 .NET Core，包括 C# 8.0 编译器。</span><span class="sxs-lookup"><span data-stu-id="1f98f-111">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="1f98f-112">自 [Visual Studio 2019 版本 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) 或 [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download) 起，开始随附 C# 8.0 编译器。</span><span class="sxs-lookup"><span data-stu-id="1f98f-112">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="scenario-overview"></a><span data-ttu-id="1f98f-113">方案概述</span><span class="sxs-lookup"><span data-stu-id="1f98f-113">Scenario overview</span></span>

<span data-ttu-id="1f98f-114">本教程从客户关系库版本 1 开始。</span><span class="sxs-lookup"><span data-stu-id="1f98f-114">This tutorial starts with version 1 of a customer relationship library.</span></span> <span data-ttu-id="1f98f-115">可以在 [GitHub 上的示例存储库](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/starter/customer-relationship)中获取入门应用程序。</span><span class="sxs-lookup"><span data-stu-id="1f98f-115">You can get the starter application on our [samples repo on GitHub](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/starter/customer-relationship).</span></span> <span data-ttu-id="1f98f-116">生成此库的公司希望拥有现有应用程序的客户采用其库。</span><span class="sxs-lookup"><span data-stu-id="1f98f-116">The company that built this library intended customers with existing applications to adopt their library.</span></span> <span data-ttu-id="1f98f-117">他们为使用其库的用户提供最小接口定义供其实现。</span><span class="sxs-lookup"><span data-stu-id="1f98f-117">They provided minimal interface definitions for users of their library to implement.</span></span> <span data-ttu-id="1f98f-118">以下是客户的接口定义：</span><span class="sxs-lookup"><span data-stu-id="1f98f-118">Here's the interface definition for a customer:</span></span>

[!code-csharp[InitialCustomerInterface](~/samples/snippets/csharp/tutorials/default-interface-members-versions/starter/customer-relationship/ICustomer.cs?name=SnippetICustomerVersion1)]

<span data-ttu-id="1f98f-119">他们定义了表示订单的第二个接口：</span><span class="sxs-lookup"><span data-stu-id="1f98f-119">They defined a second interface that represents an order:</span></span>

[!code-csharp[InitialOrderInterface](~/samples/snippets/csharp/tutorials/default-interface-members-versions/starter/customer-relationship/IOrder.cs?name=SnippetIorderVersion1)]

<span data-ttu-id="1f98f-120">通过这些接口，团队可以为其用户生成一个库，以便为其客户创造更好的体验。</span><span class="sxs-lookup"><span data-stu-id="1f98f-120">From those interfaces, the team could build a library for their users to create a better experience for their customers.</span></span> <span data-ttu-id="1f98f-121">他们的目标是与现有客户建立更深入的关系，并改善他们与新客户的关系。</span><span class="sxs-lookup"><span data-stu-id="1f98f-121">Their goal was to create a deeper relationship with existing customers and improve their relationships with new customers.</span></span>

<span data-ttu-id="1f98f-122">现在，是时候为下一版本升级库了。</span><span class="sxs-lookup"><span data-stu-id="1f98f-122">Now, it's time to upgrade the library for the next release.</span></span> <span data-ttu-id="1f98f-123">其中一个请求的功能可以为拥有大量订单的客户提供忠实客户折扣。</span><span class="sxs-lookup"><span data-stu-id="1f98f-123">One of the requested features enables a loyalty discount for customers that have lots of orders.</span></span> <span data-ttu-id="1f98f-124">无论客户何时下单，都会应用这一新的忠实客户折扣。</span><span class="sxs-lookup"><span data-stu-id="1f98f-124">This new loyalty discount gets applied whenever a customer makes an order.</span></span> <span data-ttu-id="1f98f-125">该特定折扣是每位客户的财产。</span><span class="sxs-lookup"><span data-stu-id="1f98f-125">The specific discount is a property of each individual customer.</span></span> <span data-ttu-id="1f98f-126">`ICustomer` 的每个实现都可以为忠实客户折扣设置不同的规则。</span><span class="sxs-lookup"><span data-stu-id="1f98f-126">Each implementation of `ICustomer` can set different rules for the loyalty discount.</span></span>

<span data-ttu-id="1f98f-127">添加此功能的最自然方式是使用用于应用任何忠实客户折扣的方法来增强 `ICustomer` 接口。</span><span class="sxs-lookup"><span data-stu-id="1f98f-127">The most natural way to add this functionality is to enhance the `ICustomer` interface with a method to apply any loyalty discount.</span></span> <span data-ttu-id="1f98f-128">此设计建议引起了经验丰富的开发人员的关注：“一旦发布，接口就是固定不变的！</span><span class="sxs-lookup"><span data-stu-id="1f98f-128">This design suggestion caused concern among experienced developers: "Interfaces are immutable once they've been released!</span></span> <span data-ttu-id="1f98f-129">这是一项突破性的变革！”</span><span class="sxs-lookup"><span data-stu-id="1f98f-129">This is a breaking change!"</span></span> <span data-ttu-id="1f98f-130">C# 8.0 添加了 *默认接口实现* 用于升级接口。</span><span class="sxs-lookup"><span data-stu-id="1f98f-130">C# 8.0 adds *default interface implementations* for upgrading interfaces.</span></span> <span data-ttu-id="1f98f-131">库作者可以向接口添加新成员，并为这些成员提供默认实现。</span><span class="sxs-lookup"><span data-stu-id="1f98f-131">The library authors can add new members to the interface and provide a default implementation for those members.</span></span>

<span data-ttu-id="1f98f-132">默认接口实现使开发人员能够升级接口，同时仍允许任何实现器替代该实现。</span><span class="sxs-lookup"><span data-stu-id="1f98f-132">Default interface implementations enable developers to upgrade an interface while still enabling any implementors to override that implementation.</span></span> <span data-ttu-id="1f98f-133">库的用户可以接受默认实现作为非中断性变更。</span><span class="sxs-lookup"><span data-stu-id="1f98f-133">Users of the library can accept the default implementation as a non-breaking change.</span></span> <span data-ttu-id="1f98f-134">如果他们的业务规则不同，则可以进行替代。</span><span class="sxs-lookup"><span data-stu-id="1f98f-134">If their business rules are different, they can override.</span></span>

## <a name="upgrade-with-default-interface-methods"></a><span data-ttu-id="1f98f-135">使用默认接口方法升级</span><span class="sxs-lookup"><span data-stu-id="1f98f-135">Upgrade with default interface methods</span></span>

<span data-ttu-id="1f98f-136">团队就最有可能的默认实现达成一致：针对客户的忠实客户折扣。</span><span class="sxs-lookup"><span data-stu-id="1f98f-136">The team agreed on the most likely default implementation: a loyalty discount for customers.</span></span>

<span data-ttu-id="1f98f-137">升级应提供用于设置两个属性的功能：符合折扣条件所需的订单数量以及折扣百分比。</span><span class="sxs-lookup"><span data-stu-id="1f98f-137">The upgrade should provide the functionality to set two properties: the number of orders needed to be eligible for the discount, and the percentage of the discount.</span></span> <span data-ttu-id="1f98f-138">这使其成为用于默认接口成员的完美方案。</span><span class="sxs-lookup"><span data-stu-id="1f98f-138">This makes it a perfect scenario for default interface methods.</span></span> <span data-ttu-id="1f98f-139">可以向 `ICustomer` 接口添加方法，并提供最有可能的实现。</span><span class="sxs-lookup"><span data-stu-id="1f98f-139">You can add a method to the `ICustomer` interface, and provide the most likely implementation.</span></span> <span data-ttu-id="1f98f-140">所有现有的和任何新的实现都可以使用默认实现，或者提供其自己的实现。</span><span class="sxs-lookup"><span data-stu-id="1f98f-140">All existing, and any new implementations can use the default implementation, or provide their own.</span></span>

<span data-ttu-id="1f98f-141">首先，将新方法添加到接口，包括方法的主体：</span><span class="sxs-lookup"><span data-stu-id="1f98f-141">First, add the new method to the interface, including the body of the method:</span></span>

[!code-csharp[InitialOrderInterface](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetLoyaltyDiscountVersionOne)]

<span data-ttu-id="1f98f-142">库作者编写了用于检查实现的第一个测试：</span><span class="sxs-lookup"><span data-stu-id="1f98f-142">The library author wrote a first test to check the implementation:</span></span>

[!code-csharp[TestDefaultImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetTestDefaultImplementation)]

<span data-ttu-id="1f98f-143">注意测试的以下部分：</span><span class="sxs-lookup"><span data-stu-id="1f98f-143">Notice the following portion of the test:</span></span>

[!code-csharp[TestDefaultImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetHighlightCast)]

<span data-ttu-id="1f98f-144">从 `SampleCustomer` 到 `ICustomer` 的强制转换是必需的。</span><span class="sxs-lookup"><span data-stu-id="1f98f-144">That cast from `SampleCustomer` to `ICustomer` is necessary.</span></span> <span data-ttu-id="1f98f-145">`SampleCustomer` 类不需要为 `ComputeLoyaltyDiscount` 提供实现；这由 `ICustomer` 接口提供。</span><span class="sxs-lookup"><span data-stu-id="1f98f-145">The `SampleCustomer` class doesn't need to provide an implementation for `ComputeLoyaltyDiscount`; that's provided by the `ICustomer` interface.</span></span> <span data-ttu-id="1f98f-146">但是，`SampleCustomer` 类不会从其接口继承成员。</span><span class="sxs-lookup"><span data-stu-id="1f98f-146">However, the `SampleCustomer` class doesn't inherit members from its interfaces.</span></span> <span data-ttu-id="1f98f-147">该规则没有更改。</span><span class="sxs-lookup"><span data-stu-id="1f98f-147">That rule hasn't changed.</span></span> <span data-ttu-id="1f98f-148">若要调用在接口中声明和实现的任何方法，该变量的类型必须是接口的类型，在本示例中为 `ICustomer`。</span><span class="sxs-lookup"><span data-stu-id="1f98f-148">In order to call any method declared and implemented in the interface, the variable must be the type of the interface, `ICustomer` in this example.</span></span>

## <a name="provide-parameterization"></a><span data-ttu-id="1f98f-149">提供参数化</span><span class="sxs-lookup"><span data-stu-id="1f98f-149">Provide parameterization</span></span>

<span data-ttu-id="1f98f-150">这是一个好的开始。</span><span class="sxs-lookup"><span data-stu-id="1f98f-150">That's a good start.</span></span> <span data-ttu-id="1f98f-151">但是，默认实现存在太多限制。</span><span class="sxs-lookup"><span data-stu-id="1f98f-151">But, the default implementation is too restrictive.</span></span> <span data-ttu-id="1f98f-152">此系统的许多使用者可能会选择不同的购买数量阈值、不同的会员资格时长或不同的折扣百分比。</span><span class="sxs-lookup"><span data-stu-id="1f98f-152">Many consumers of this system may choose different thresholds for number of purchases, a different length of membership, or a different percentage discount.</span></span> <span data-ttu-id="1f98f-153">通过提供用于设置这些参数的方法，可为更多客户提供更好的升级体验。</span><span class="sxs-lookup"><span data-stu-id="1f98f-153">You can provide a better upgrade experience for more customers by providing a way to set those parameters.</span></span> <span data-ttu-id="1f98f-154">让我们添加一个静态方法，该方法可设置控制默认实现的三个参数：</span><span class="sxs-lookup"><span data-stu-id="1f98f-154">Let's add a static method that sets those three parameters controlling the default implementation:</span></span>

[!code-csharp[VersionTwoImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetLoyaltyDiscountVersionTwo)]

<span data-ttu-id="1f98f-155">这个小代码片段中展示了许多新的语言功能。</span><span class="sxs-lookup"><span data-stu-id="1f98f-155">There are many new language capabilities shown in that small code fragment.</span></span> <span data-ttu-id="1f98f-156">接口现在可以包含静态成员，其中包括字段和方法。</span><span class="sxs-lookup"><span data-stu-id="1f98f-156">Interfaces can now include static members, including fields and methods.</span></span> <span data-ttu-id="1f98f-157">还启用了不同的访问修饰符。</span><span class="sxs-lookup"><span data-stu-id="1f98f-157">Different access modifiers are also enabled.</span></span> <span data-ttu-id="1f98f-158">其他字段是专用的，新方法是公共的。</span><span class="sxs-lookup"><span data-stu-id="1f98f-158">The additional fields are private, the new method is public.</span></span> <span data-ttu-id="1f98f-159">接口成员允许使用任何修饰符。</span><span class="sxs-lookup"><span data-stu-id="1f98f-159">Any of the modifiers are allowed on interface members.</span></span>

<span data-ttu-id="1f98f-160">使用常规公式计算忠实客户折扣但参数有所不同的应用程序不需要提供自定义实现；它们可以通过静态方法设置自变量。</span><span class="sxs-lookup"><span data-stu-id="1f98f-160">Applications that use the general formula for computing the loyalty discount, but different parameters, don't need to provide a custom implementation; they can set the arguments through a static method.</span></span> <span data-ttu-id="1f98f-161">例如，以下代码设置“客户答谢”，奖励任何成为会员超过一个月的客户：</span><span class="sxs-lookup"><span data-stu-id="1f98f-161">For example, the following code sets a "customer appreciation" that rewards any customer with more than one month's membership:</span></span>

[!code-csharp[SetLoyaltyThresholds](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetSetLoyaltyThresholds)]

## <a name="extend-the-default-implementation"></a><span data-ttu-id="1f98f-162">扩展默认实现</span><span class="sxs-lookup"><span data-stu-id="1f98f-162">Extend the default implementation</span></span>

<span data-ttu-id="1f98f-163">目前添加的代码提供了方便的实现，可用于用户需要类似默认实现的项目的方案，或用于提供一组不相关的规则。</span><span class="sxs-lookup"><span data-stu-id="1f98f-163">The code you've added so far has provided a convenient implementation for those scenarios where users want something like the default implementation, or to provide an unrelated set of rules.</span></span> <span data-ttu-id="1f98f-164">对于最后一个功能，让我们稍微重构一下代码，以实现用户可能需要基于默认实现进行生成的方案。</span><span class="sxs-lookup"><span data-stu-id="1f98f-164">For a final feature, let's refactor the code a bit to enable scenarios where users may want to build on the default implementation.</span></span>

<span data-ttu-id="1f98f-165">假设有一家想要吸引新客户的初创企业。</span><span class="sxs-lookup"><span data-stu-id="1f98f-165">Consider a startup that wants to attract new customers.</span></span> <span data-ttu-id="1f98f-166">他们为新客户的第一笔订单提供 50% 的折扣，</span><span class="sxs-lookup"><span data-stu-id="1f98f-166">They offer a 50% discount off a new customer's first order.</span></span> <span data-ttu-id="1f98f-167">而现有客户则会获得标准折扣。</span><span class="sxs-lookup"><span data-stu-id="1f98f-167">Otherwise, existing customers get the standard discount.</span></span> <span data-ttu-id="1f98f-168">库作者需要将默认实现移入 `protected static` 方法，以便实现此接口的任何类都可以在其实现中重用代码。</span><span class="sxs-lookup"><span data-stu-id="1f98f-168">The library author needs to move the default implementation into a `protected static` method so that any class implementing this interface can reuse the code in their implementation.</span></span> <span data-ttu-id="1f98f-169">接口成员的默认实现也调用此共享方法：</span><span class="sxs-lookup"><span data-stu-id="1f98f-169">The default implementation of the interface member calls this shared method as well:</span></span>

[!code-csharp[VersionTwoImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetFinalVersion)]

<span data-ttu-id="1f98f-170">在实现此接口的类的实现中，替代可以调用静态帮助程序方法，并扩展该逻辑以提供“新客户”折扣：</span><span class="sxs-lookup"><span data-stu-id="1f98f-170">In an implementation of a class that implements this interface, the override can call the static helper method, and extend that logic to provide the "new customer" discount:</span></span>

[!code-csharp[VersionTwoImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/SampleCustomer.cs?name=SnippetOverrideAndExtend)]

<span data-ttu-id="1f98f-171">可以在 [GitHub 上的示例存储库](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/finished/customer-relationship)中查看整个完成的代码。</span><span class="sxs-lookup"><span data-stu-id="1f98f-171">You can see the entire finished code in our [samples repo on GitHub](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/finished/customer-relationship).</span></span> <span data-ttu-id="1f98f-172">可以在 [GitHub 上的示例存储库](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/starter/customer-relationship)中获取入门应用程序。</span><span class="sxs-lookup"><span data-stu-id="1f98f-172">You can get the starter application on our [samples repo on GitHub](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/starter/customer-relationship).</span></span>

<span data-ttu-id="1f98f-173">这些新功能意味着，当这些新成员拥有合理的默认实现时，接口可以安全地更新。</span><span class="sxs-lookup"><span data-stu-id="1f98f-173">These new features mean that interfaces can be updated safely when there's a reasonable default implementation for those new members.</span></span> <span data-ttu-id="1f98f-174">精心设计接口，以表达可由多个类实现的单个功能概念。</span><span class="sxs-lookup"><span data-stu-id="1f98f-174">Carefully design interfaces to express single functional ideas that can be implemented by multiple classes.</span></span> <span data-ttu-id="1f98f-175">这样一来，在发现针对同一功能概念的新要求时，可以更轻松地升级这些接口定义。</span><span class="sxs-lookup"><span data-stu-id="1f98f-175">That makes it easier to upgrade those interface definitions when new requirements are discovered for that same functional idea.</span></span>
