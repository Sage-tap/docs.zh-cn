---
description: 了解详细信息：导入架构以生成类
title: 导入架构以生成类
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- WCF, schema import and export
- XsdDataContractImporter class
ms.assetid: b9170583-8c34-43bd-97bb-6c0c8dddeee0
ms.openlocfilehash: 787d2a40db6de8181c7e4d27df72fbc4ac032da2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99802861"
---
# <a name="importing-schema-to-generate-classes"></a><span data-ttu-id="ac16b-103">导入架构以生成类</span><span class="sxs-lookup"><span data-stu-id="ac16b-103">Importing Schema to Generate Classes</span></span>

<span data-ttu-id="ac16b-104">若要从与 Windows Communication Foundation (WCF) 一起使用的架构生成类，请使用 <xref:System.Runtime.Serialization.XsdDataContractImporter> 类。</span><span class="sxs-lookup"><span data-stu-id="ac16b-104">To generate classes from schemas that are usable with Windows Communication Foundation (WCF), use the <xref:System.Runtime.Serialization.XsdDataContractImporter> class.</span></span> <span data-ttu-id="ac16b-105">本主题描述该过程和变体。</span><span class="sxs-lookup"><span data-stu-id="ac16b-105">This topic describes the process and variations.</span></span>  
  
## <a name="the-import-process"></a><span data-ttu-id="ac16b-106">导入过程</span><span class="sxs-lookup"><span data-stu-id="ac16b-106">The Import Process</span></span>

 <span data-ttu-id="ac16b-107">架构导入过程以一个 <xref:System.Xml.Schema.XmlSchemaSet> 开始并生成一个 <xref:System.CodeDom.CodeCompileUnit>。</span><span class="sxs-lookup"><span data-stu-id="ac16b-107">The schema import process starts with an <xref:System.Xml.Schema.XmlSchemaSet> and produces a <xref:System.CodeDom.CodeCompileUnit>.</span></span>  
  
 <span data-ttu-id="ac16b-108">`XmlSchemaSet`是 .NET Framework 的架构对象模型的一部分 (SOM) ，它表示 (XSD) 架构文档的一组 XML 架构定义语言。</span><span class="sxs-lookup"><span data-stu-id="ac16b-108">The `XmlSchemaSet` is a part of the .NET Framework’s Schema Object Model (SOM) that represents a set of XML Schema definition language (XSD) schema documents.</span></span> <span data-ttu-id="ac16b-109">若要从 XSD 文档集创建一个 `XmlSchemaSet` 对象，则将每个文档反序列化到 <xref:System.Xml.Schema.XmlSchema> 对象中（使用 <xref:System.Xml.Serialization.XmlSerializer>），并将这些对象添加到新的 `XmlSchemaSet` 中。</span><span class="sxs-lookup"><span data-stu-id="ac16b-109">To create an `XmlSchemaSet` object from a set of XSD documents, deserialize each document into an <xref:System.Xml.Schema.XmlSchema> object (using the <xref:System.Xml.Serialization.XmlSerializer>) and add these objects to a new `XmlSchemaSet`.</span></span>  
  
 <span data-ttu-id="ac16b-110">`CodeCompileUnit`是 .NET Framework 代码文档对象模型的一部分 (CodeDOM) ，它以抽象方式表示 .NET Framework 代码。</span><span class="sxs-lookup"><span data-stu-id="ac16b-110">The `CodeCompileUnit` is part of the .NET Framework’s Code Document Object Model (CodeDOM) that represents .NET Framework code in an abstract way.</span></span> <span data-ttu-id="ac16b-111">若要从 `CodeCompileUnit` 生成实际代码，则使用 <xref:System.CodeDom.Compiler.CodeDomProvider> 类的一个子类，例如 <xref:Microsoft.CSharp.CSharpCodeProvider> 或 <xref:Microsoft.VisualBasic.VBCodeProvider> 类。</span><span class="sxs-lookup"><span data-stu-id="ac16b-111">To generate the actual code from a `CodeCompileUnit`, use a subclass of the <xref:System.CodeDom.Compiler.CodeDomProvider> class, such as the <xref:Microsoft.CSharp.CSharpCodeProvider> or <xref:Microsoft.VisualBasic.VBCodeProvider> class.</span></span>  
  
### <a name="to-import-a-schema"></a><span data-ttu-id="ac16b-112">导入架构</span><span class="sxs-lookup"><span data-stu-id="ac16b-112">To import a schema</span></span>  
  
1. <span data-ttu-id="ac16b-113">创建 <xref:System.Runtime.Serialization.XsdDataContractImporter> 的实例：</span><span class="sxs-lookup"><span data-stu-id="ac16b-113">Create an instance of the <xref:System.Runtime.Serialization.XsdDataContractImporter>.</span></span>  
  
2. <span data-ttu-id="ac16b-114">可选。</span><span class="sxs-lookup"><span data-stu-id="ac16b-114">Optional.</span></span> <span data-ttu-id="ac16b-115">在构造函数中传递一个 `CodeCompileUnit`。</span><span class="sxs-lookup"><span data-stu-id="ac16b-115">Pass a `CodeCompileUnit` in the constructor.</span></span> <span data-ttu-id="ac16b-116">将在架构导入期间生成的类型添加到此 `CodeCompileUnit` 实例中，而不是以空白 `CodeCompileUnit` 开始。</span><span class="sxs-lookup"><span data-stu-id="ac16b-116">The types generated during schema import are added to this `CodeCompileUnit` instance instead of starting with a blank `CodeCompileUnit`.</span></span>  
  
3. <span data-ttu-id="ac16b-117">可选。</span><span class="sxs-lookup"><span data-stu-id="ac16b-117">Optional.</span></span> <span data-ttu-id="ac16b-118">调用 <xref:System.Runtime.Serialization.XsdDataContractImporter.CanImport%2A> 方法之一。</span><span class="sxs-lookup"><span data-stu-id="ac16b-118">Call one of the <xref:System.Runtime.Serialization.XsdDataContractImporter.CanImport%2A> methods.</span></span> <span data-ttu-id="ac16b-119">该方法确定给定架构是否为有效的数据协定架构，以及是否可以被导入。</span><span class="sxs-lookup"><span data-stu-id="ac16b-119">The method determines whether the given schema is a valid data contract schema and can be imported.</span></span> <span data-ttu-id="ac16b-120">`CanImport` 方法具有与下一步中的 `Import` 相同的重载。</span><span class="sxs-lookup"><span data-stu-id="ac16b-120">The `CanImport` method has the same overloads as `Import` (the next step).</span></span>  
  
4. <span data-ttu-id="ac16b-121">调用重载的 `Import` 方法之一，例如 <xref:System.Runtime.Serialization.XsdDataContractImporter.Import%28System.Xml.Schema.XmlSchemaSet%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="ac16b-121">Call one of the overloaded `Import` methods, for example, the <xref:System.Runtime.Serialization.XsdDataContractImporter.Import%28System.Xml.Schema.XmlSchemaSet%29> method.</span></span>  
  
     <span data-ttu-id="ac16b-122">最简单的重载采用 `XmlSchemaSet` 并导入在架构集中找到的所有类型，包括匿名类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-122">The simplest overload takes an `XmlSchemaSet` and imports all types, including anonymous types, found in that schema set.</span></span> <span data-ttu-id="ac16b-123">使用其他重载可以指定 XSD 类型或要导入的类型列表（以 <xref:System.Xml.XmlQualifiedName> 或 `XmlQualifiedName` 对象集合的形式）。</span><span class="sxs-lookup"><span data-stu-id="ac16b-123">Other overloads allow you to specify the XSD type or a list of types to import (in the form of an <xref:System.Xml.XmlQualifiedName> or a collection of `XmlQualifiedName` objects).</span></span> <span data-ttu-id="ac16b-124">在此情况下，仅导入指定的类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-124">In this case, only the specified types are imported.</span></span> <span data-ttu-id="ac16b-125">存在一个重载，它采用 <xref:System.Xml.Schema.XmlSchemaElement> 导入 `XmlSchemaSet` 之外的特定元素，以及它的关联类型（无论类型是否为匿名）。</span><span class="sxs-lookup"><span data-stu-id="ac16b-125">An overload takes an <xref:System.Xml.Schema.XmlSchemaElement> that imports a particular element out of the `XmlSchemaSet`, as well as its associated type (whether it is anonymous or not).</span></span> <span data-ttu-id="ac16b-126">该重载返回一个 `XmlQualifiedName`，表示为此元素生成的类型的数据协定名称。</span><span class="sxs-lookup"><span data-stu-id="ac16b-126">This overload returns an `XmlQualifiedName`, which represents the data contract name of the type generated for this element.</span></span>  
  
     <span data-ttu-id="ac16b-127">多次调用 `Import` 方法会向同一个 `CodeCompileUnit` 添加多个项。</span><span class="sxs-lookup"><span data-stu-id="ac16b-127">Multiple calls of the `Import` method result in multiple items being added to the same `CodeCompileUnit`.</span></span> <span data-ttu-id="ac16b-128">如果某个类型已经存在于 `CodeCompileUnit` 中，则不会再在其中生成该类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-128">A type is not generated into the `CodeCompileUnit` if it already exists there.</span></span> <span data-ttu-id="ac16b-129">在同一个 `Import` 上多次调用 `XsdDataContractImporter`，而不是使用多个 `XsdDataContractImporter` 对象。</span><span class="sxs-lookup"><span data-stu-id="ac16b-129">Call `Import` multiple times on the same `XsdDataContractImporter` instead of using multiple `XsdDataContractImporter` objects.</span></span> <span data-ttu-id="ac16b-130">建议使用这种方法以避免生成重复的类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-130">This is the recommended way to avoid duplicate types being generated.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="ac16b-131">如果导入期间出现了故障，则 `CodeCompileUnit` 将处于不可预知的状态。</span><span class="sxs-lookup"><span data-stu-id="ac16b-131">If there is a failure during import, the `CodeCompileUnit` will be in an unpredictable state.</span></span> <span data-ttu-id="ac16b-132">使用从失败的导入中产生的 `CodeCompileUnit` 可能会使您暴露出安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ac16b-132">Using a `CodeCompileUnit` resulting from a failed import could expose you to security vulnerabilities.</span></span>  
  
5. <span data-ttu-id="ac16b-133">通过 `CodeCompileUnit` 属性访问 <xref:System.Runtime.Serialization.XsdDataContractImporter.CodeCompileUnit%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ac16b-133">Access the `CodeCompileUnit` through the <xref:System.Runtime.Serialization.XsdDataContractImporter.CodeCompileUnit%2A> property.</span></span>  
  
### <a name="import-options-customizing-the-generated-types"></a><span data-ttu-id="ac16b-134">导入选项：自定义生成的类型</span><span class="sxs-lookup"><span data-stu-id="ac16b-134">Import Options: Customizing the Generated Types</span></span>  

 <span data-ttu-id="ac16b-135">可以将 <xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A> 的 <xref:System.Runtime.Serialization.XsdDataContractImporter> 属性设置为 <xref:System.Runtime.Serialization.ImportOptions> 类的一个实例，以便控制导入过程的各个方面。</span><span class="sxs-lookup"><span data-stu-id="ac16b-135">You can set the <xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A> property of the <xref:System.Runtime.Serialization.XsdDataContractImporter> to an instance of the <xref:System.Runtime.Serialization.ImportOptions> class to control various aspects of the import process.</span></span> <span data-ttu-id="ac16b-136">许多选项会直接影响生成的类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-136">A number of options directly influence the types that are generated.</span></span>  
  
#### <a name="controlling-the-access-level-generateinternal-or-the-internal-switch"></a><span data-ttu-id="ac16b-137">控制访问级别（GenerateInternal 或 /internal 开关）</span><span class="sxs-lookup"><span data-stu-id="ac16b-137">Controlling the Access Level (GenerateInternal or the /internal switch)</span></span>  

 <span data-ttu-id="ac16b-138">这对应于 " **/internal** " [元数据实用工具工具上的开关 ( # A0)](../servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="ac16b-138">This corresponds to the **/internal** switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span>  
  
 <span data-ttu-id="ac16b-139">通常情况下，公共类型是从架构生成的，具有私有字段和匹配的公共数据成员属性。</span><span class="sxs-lookup"><span data-stu-id="ac16b-139">Normally, public types are generated from schema, with private fields and matching public data member properties.</span></span> <span data-ttu-id="ac16b-140">若要生成内部类型，则将 <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="ac16b-140">To generate internal types instead, set the <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> property to `true`.</span></span>  
  
 <span data-ttu-id="ac16b-141">下面的示例演示在将 <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> 属性设置为 `true.` 时转换为内部类的架构。</span><span class="sxs-lookup"><span data-stu-id="ac16b-141">The following example shows a schema transformed into an internal class when the <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> property is set to `true.`</span></span>  
  
 [!code-csharp[c_SchemaImportExport#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#2)]
 [!code-vb[c_SchemaImportExport#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#2)]  
  
#### <a name="controlling-namespaces-namespaces-or-the-namespace-switch"></a><span data-ttu-id="ac16b-142">控制命名空间（Namespaces 或 /namespace 开关）</span><span class="sxs-lookup"><span data-stu-id="ac16b-142">Controlling Namespaces (Namespaces or the /namespace switch)</span></span>  

 <span data-ttu-id="ac16b-143">这对应于工具中的 **/namespace** 开关 `Svcutil.exe` 。</span><span class="sxs-lookup"><span data-stu-id="ac16b-143">This corresponds to the **/namespace** switch on the `Svcutil.exe` tool.</span></span>  
  
 <span data-ttu-id="ac16b-144">通常，从架构生成的类型将生成到 .NET Framework 命名空间中，每个 XSD 命名空间对应于特定 .NET Framework 命名空间，具体取决于 [数据协定架构引用](data-contract-schema-reference.md)中所述的映射。</span><span class="sxs-lookup"><span data-stu-id="ac16b-144">Normally, types generated from schema are generated into .NET Framework namespaces, with each XSD namespace corresponding to a particular .NET Framework namespace according to a mapping described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="ac16b-145">通过将 <xref:System.Runtime.Serialization.ImportOptions.Namespaces%2A> 属性设置为 <xref:System.Collections.Generic.Dictionary%602> 可以自定义此映射。</span><span class="sxs-lookup"><span data-stu-id="ac16b-145">You can customize this mapping by the <xref:System.Runtime.Serialization.ImportOptions.Namespaces%2A> property to a <xref:System.Collections.Generic.Dictionary%602>.</span></span> <span data-ttu-id="ac16b-146">如果在字典中找到给定的 XSD 命名空间，则也将从字典中获取匹配的 .NET Framework 命名空间。</span><span class="sxs-lookup"><span data-stu-id="ac16b-146">If a given XSD namespace is found in the dictionary, the matching .NET Framework namespace is also taken from your dictionary.</span></span>  
  
 <span data-ttu-id="ac16b-147">例如，考虑下面的架构。</span><span class="sxs-lookup"><span data-stu-id="ac16b-147">For example, consider the following schema.</span></span>  
  
 [!code-xml[c_SchemaImportExport#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#10)]  
  
 <span data-ttu-id="ac16b-148">下面的示例使用 `Namespaces` 属性将 `http://schemas.contoso.com/carSchema` 命名空间映射到 "Contoso"。</span><span class="sxs-lookup"><span data-stu-id="ac16b-148">The following example uses the `Namespaces` property to map the `http://schemas.contoso.com/carSchema` namespace to "Contoso.Cars".</span></span>  
  
 [!code-csharp[c_SchemaImportExport#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#8)]
 [!code-vb[c_SchemaImportExport#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#8)]  
  
#### <a name="adding-the-serializableattribute-generateserializable-or-the-serializable-switch"></a><span data-ttu-id="ac16b-149">添加 SerializableAttribute（GenerateSerializable 或 /serializable 开关）</span><span class="sxs-lookup"><span data-stu-id="ac16b-149">Adding the SerializableAttribute (GenerateSerializable or the /serializable switch)</span></span>  

 <span data-ttu-id="ac16b-150">这对应于工具中的 **/serializable** 开关 `Svcutil.exe` 。</span><span class="sxs-lookup"><span data-stu-id="ac16b-150">This corresponds to the **/serializable** switch on the `Svcutil.exe` tool.</span></span>  
  
 <span data-ttu-id="ac16b-151">有时，从架构生成的类型在 .NET Framework 运行时序列化引擎中可用 (例如， <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=nameWithType> 和类) ，这一点很重要 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="ac16b-151">Sometimes it is important for the types generated from the schema to be usable with .NET Framework runtime serialization engines (for example, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=nameWithType> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> classes).</span></span> <span data-ttu-id="ac16b-152">使用类型进行 .NET Framework 远程处理时，这非常有用。</span><span class="sxs-lookup"><span data-stu-id="ac16b-152">This is useful when using types for .NET Framework remoting.</span></span> <span data-ttu-id="ac16b-153">若要启用它，则除常规 <xref:System.SerializableAttribute> 属性除外，还必须将 <xref:System.Runtime.Serialization.DataContractAttribute> 属性应用于生成的类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-153">To enable this, you must apply the <xref:System.SerializableAttribute> attribute to the generated types in addition to the regular <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="ac16b-154">如果 `GenerateSerializable` 导入选项设置为 `true`，则将自动生成该属性。</span><span class="sxs-lookup"><span data-stu-id="ac16b-154">The attribute is generated automatically if the `GenerateSerializable` import option is set to `true`.</span></span>  
  
 <span data-ttu-id="ac16b-155">下面的示例演示在 `Vehicle` 导入选项设置为 `GenerateSerializable` 时生成的 `true` 类。</span><span class="sxs-lookup"><span data-stu-id="ac16b-155">The following example shows the `Vehicle` class generated with the `GenerateSerializable` import option set to `true`.</span></span>  
  
 [!code-csharp[c_SchemaImportExport#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#4)]
 [!code-vb[c_SchemaImportExport#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#4)]  
  
#### <a name="adding-data-binding-support-enabledatabinding-or-the-enabledatabinding-switch"></a><span data-ttu-id="ac16b-156">添加数据绑定支持（EnableDataBinding 或 /enableDataBinding 开关）</span><span class="sxs-lookup"><span data-stu-id="ac16b-156">Adding Data Binding Support (EnableDataBinding or the /enableDataBinding switch)</span></span>  

 <span data-ttu-id="ac16b-157">这对应于 Svcutil.exe 工具上的 **/enableDataBinding** 开关。</span><span class="sxs-lookup"><span data-stu-id="ac16b-157">This corresponds to the **/enableDataBinding** switch on the Svcutil.exe tool.</span></span>  
  
 <span data-ttu-id="ac16b-158">有时，可能需要将从架构生成的类型绑定到图形用户界面组件，这样这些类型实例的任何更新都将自动更新 UI。</span><span class="sxs-lookup"><span data-stu-id="ac16b-158">Sometimes, you may want to bind the types generated from the schema to graphical user interface components so that any update to instances of these types will automatically update the UI.</span></span> <span data-ttu-id="ac16b-159">`XsdDataContractImporter` 可以生成实现 <xref:System.ComponentModel.INotifyPropertyChanged> 接口的类型，以使任何属性更改都触发事件。</span><span class="sxs-lookup"><span data-stu-id="ac16b-159">The `XsdDataContractImporter` can generate types that implement the <xref:System.ComponentModel.INotifyPropertyChanged> interface in such a way that any property change triggers an event.</span></span> <span data-ttu-id="ac16b-160">如果要生成的类型适用于支持此接口的客户端 UI 编程环境 (例如 Windows Presentation Foundation (WPF) # A3，请将属性设置 <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> 为 `true` 以启用此功能。</span><span class="sxs-lookup"><span data-stu-id="ac16b-160">If you are generating types for use with a client UI programming environment that supports this interface (such as Windows Presentation Foundation (WPF)), set the <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> property to `true` to enable this feature.</span></span>  
  
 <span data-ttu-id="ac16b-161">下面的示例演示在 `Vehicle` 设置为 <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> 时生成的 `true` 类。</span><span class="sxs-lookup"><span data-stu-id="ac16b-161">The following example shows the `Vehicle` class generated with the <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> set to `true`.</span></span>  
  
 [!code-csharp[C_SchemaImportExport#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#5)]
 [!code-vb[C_SchemaImportExport#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#5)]  
  
### <a name="import-options-choosing-collection-types"></a><span data-ttu-id="ac16b-162">导入选项：选择集合类型</span><span class="sxs-lookup"><span data-stu-id="ac16b-162">Import Options: Choosing Collection Types</span></span>  

 <span data-ttu-id="ac16b-163">XML 中存在两种特殊的模式，用于表示项集合：项列表和项与项之间的关联。</span><span class="sxs-lookup"><span data-stu-id="ac16b-163">Two special patterns in XML represent collections of items: lists of items and associations between one item and another.</span></span> <span data-ttu-id="ac16b-164">下面是一个字符串列表示例。</span><span class="sxs-lookup"><span data-stu-id="ac16b-164">The following is an example of a list of strings.</span></span>  
  
 [!code-xml[C_SchemaImportExport#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#11)]  
  
 <span data-ttu-id="ac16b-165">下面是一个字符串与整数（`city name` 和 `population`）之间的关联示例。</span><span class="sxs-lookup"><span data-stu-id="ac16b-165">The following is an example of an association between a string and an integer (`city name` and `population`).</span></span>  
  
 [!code-xml[C_SchemaImportExport#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#12)]  
  
> [!NOTE]
> <span data-ttu-id="ac16b-166">也可将任何关联视为列表。</span><span class="sxs-lookup"><span data-stu-id="ac16b-166">Any association could also be considered a list.</span></span> <span data-ttu-id="ac16b-167">例如，可以将上面的关联视为一个复杂的 `city` 对象列表，这些对象碰巧有两个字段（一个字符串字段和一个整数字段）。</span><span class="sxs-lookup"><span data-stu-id="ac16b-167">For example, you can view the preceding association as a list of complex `city` objects that happen to have two fields (a string field and an integer field).</span></span> <span data-ttu-id="ac16b-168">这两种模式在 XSD 架构中都有一种表示形式。</span><span class="sxs-lookup"><span data-stu-id="ac16b-168">Both patterns have a representation in the XSD Schema.</span></span> <span data-ttu-id="ac16b-169">没有办法区分列表和关联，因此此类模式始终被视为列表，除非架构中存在特定于 WCF 的特殊批注。</span><span class="sxs-lookup"><span data-stu-id="ac16b-169">There is no way to differentiate between a list and an association, so such patterns are always treated as lists unless a special annotation specific to WCF is present in the schema.</span></span> <span data-ttu-id="ac16b-170">该批注指示给定模式表示一个关联。</span><span class="sxs-lookup"><span data-stu-id="ac16b-170">The annotation indicates that a given pattern represents an association.</span></span> <span data-ttu-id="ac16b-171">有关详细信息，请参阅 [数据协定架构参考](data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="ac16b-171">For more information, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="ac16b-172">通常情况下，列表将作为派生自泛型列表或 .NET Framework 数组的集合数据协定导入，具体取决于架构是否遵循集合的标准命名模式。</span><span class="sxs-lookup"><span data-stu-id="ac16b-172">Normally, a list is imported as a collection data contract that derives from a Generic List or as a .NET Framework array, depending on whether or not the schema follows the standard naming pattern for collections.</span></span> <span data-ttu-id="ac16b-173">[数据协定中的集合类型](collection-types-in-data-contracts.md)更详细地介绍了这种情况。</span><span class="sxs-lookup"><span data-stu-id="ac16b-173">This is described in more detail in [Collection Types in Data Contracts](collection-types-in-data-contracts.md).</span></span> <span data-ttu-id="ac16b-174">通常将关联作为 <xref:System.Collections.Generic.Dictionary%602> 或派生自字典对象的集合数据协定导入。</span><span class="sxs-lookup"><span data-stu-id="ac16b-174">Associations are normally imported as either a <xref:System.Collections.Generic.Dictionary%602> or a collection data contract that derives from the dictionary object.</span></span> <span data-ttu-id="ac16b-175">例如，考虑下面的架构。</span><span class="sxs-lookup"><span data-stu-id="ac16b-175">For example, consider the following schema.</span></span>  
  
 [!code-xml[c_SchemaImportExport#13](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#13)]  
  
 <span data-ttu-id="ac16b-176">这将按照下面的方式导入（出于可读性目的，显示的是字段而非属性）。</span><span class="sxs-lookup"><span data-stu-id="ac16b-176">This would be imported as follows (fields are shown instead of properties for readability).</span></span>  
  
 [!code-csharp[c_SchemaImportExport#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#6)]
 [!code-vb[c_SchemaImportExport#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#6)]  
  
 <span data-ttu-id="ac16b-177">可以自定义为此类架构模式生成的集合类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-177">It is possible to customize the collection types that are generated for such schema patterns.</span></span> <span data-ttu-id="ac16b-178">例如，可能需要生成派生自 <xref:System.ComponentModel.BindingList%601> 而非 <xref:System.Collections.Generic.List%601> 类的集合，以将此类型绑定到列表框并在集合内容更改时使其自动更新。</span><span class="sxs-lookup"><span data-stu-id="ac16b-178">For example, you may want to generate collections deriving from the <xref:System.ComponentModel.BindingList%601> instead of the <xref:System.Collections.Generic.List%601> class in order to bind the type to a list box and have it be automatically updated when the contents of the collection change.</span></span> <span data-ttu-id="ac16b-179">为此，将 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 类的 <xref:System.Runtime.Serialization.ImportOptions> 属性设置为要使用的集合类型（以后称为引用的类型）的列表。</span><span class="sxs-lookup"><span data-stu-id="ac16b-179">To do this, set the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> class to a list of collection types to be used (hereafter known as the referenced types).</span></span> <span data-ttu-id="ac16b-180">导入任何集合时，将扫描引用的集合类型的列表，并使用最佳匹配集合（如果能够找到）。</span><span class="sxs-lookup"><span data-stu-id="ac16b-180">When importing any collection, this list of referenced collection types is scanned and the best-matching collection is used if one is found.</span></span> <span data-ttu-id="ac16b-181">关联只能与实现泛型或非泛型 <xref:System.Collections.IDictionary> 接口的类型相匹配，而列表可与任何受支持的集合类型相匹配。</span><span class="sxs-lookup"><span data-stu-id="ac16b-181">Associations are matched only against types that implement either the generic or the nongeneric <xref:System.Collections.IDictionary> interface, while lists are matched against any supported collection type.</span></span>  
  
 <span data-ttu-id="ac16b-182">例如，如果 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 属性设置为 <xref:System.ComponentModel.BindingList%601>，则按下面的方式生成上面示例中的 `people` 类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-182">For example, if the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property is set to a <xref:System.ComponentModel.BindingList%601>, the `people` type in the preceding example is generated as follows.</span></span>  
  
 [!code-csharp[C_SchemaImportExport#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#7)]
 [!code-vb[C_SchemaImportExport#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#7)]  
  
 <span data-ttu-id="ac16b-183">将封闭式泛型视为最佳匹配。</span><span class="sxs-lookup"><span data-stu-id="ac16b-183">A closed generic is considered the best match.</span></span> <span data-ttu-id="ac16b-184">例如，如果将类型 `BindingList(Of Integer)` 和 <xref:System.Collections.ArrayList> 传递给引用的类型集合，则将在架构中找到的任何整数列表作为 `BindingList(Of Integer)` 导入。</span><span class="sxs-lookup"><span data-stu-id="ac16b-184">For example, if the types `BindingList(Of Integer)` and <xref:System.Collections.ArrayList> are passed to the collection of referenced types, any lists of integers found in schema are imported as a `BindingList(Of Integer)`.</span></span> <span data-ttu-id="ac16b-185">将任何其他列表（例如 `List(Of String)`）作为 `ArrayList` 导入。</span><span class="sxs-lookup"><span data-stu-id="ac16b-185">Any other lists, for example, a `List(Of String)`, are imported as an `ArrayList`.</span></span>  
  
 <span data-ttu-id="ac16b-186">如果将实现泛型 `IDictionary` 接口的一个类型添加到引用的类型集合，则其类型参数必须完全打开或完全封闭。</span><span class="sxs-lookup"><span data-stu-id="ac16b-186">If a type that implements the generic `IDictionary` interface is added to the collection of referenced types, its type parameters must either be fully open or fully closed.</span></span>  
  
 <span data-ttu-id="ac16b-187">不允许重复。</span><span class="sxs-lookup"><span data-stu-id="ac16b-187">Duplicates are not allowed.</span></span> <span data-ttu-id="ac16b-188">例如，不能同时向引用的类型添加 `List(Of Integer)` 和 `Collection(Of Integer)`。</span><span class="sxs-lookup"><span data-stu-id="ac16b-188">For example, you cannot add both a `List(Of Integer)` and a `Collection(Of Integer)` to the referenced types.</span></span> <span data-ttu-id="ac16b-189">这会使在架构中找到整数列表时无法确定应该使用哪一个整数。</span><span class="sxs-lookup"><span data-stu-id="ac16b-189">That would make it impossible to determine which should be used when a list of integers is found in schema.</span></span> <span data-ttu-id="ac16b-190">仅当架构中的某个类型暴露出重复问题时才能检测到重复项。</span><span class="sxs-lookup"><span data-stu-id="ac16b-190">Duplicates will be detected only if there is a type in schema that exposes the duplicates problem.</span></span> <span data-ttu-id="ac16b-191">例如，如果导入的架构中不包含整数列表，则允许引用的类型集合中同时具有 `List(Of Integer)` 和 `Collection(Of Integer)`，两者都不会产生任何影响。</span><span class="sxs-lookup"><span data-stu-id="ac16b-191">For example, if the imported schema does not contain lists of integers, it is allowed to have both the `List(Of Integer)` and the `Collection(Of Integer)` in the referenced types collection, but neither will have any effect.</span></span>  
  
 <span data-ttu-id="ac16b-192">引用的集合类型机制不仅适用于基元集合，也适用于复杂类型集合（包括其他集合的集合）。</span><span class="sxs-lookup"><span data-stu-id="ac16b-192">The referenced collection types mechanism works equally well for collections of complex types (including collections of other collections), and not just for collections of primitives.</span></span>  
  
 <span data-ttu-id="ac16b-193">`ReferencedCollectionTypes`属性对应于 SvcUtil.exe 工具上的 **/collectionType** 开关。</span><span class="sxs-lookup"><span data-stu-id="ac16b-193">The `ReferencedCollectionTypes` property corresponds to the **/collectionType** switch on the SvcUtil.exe tool.</span></span> <span data-ttu-id="ac16b-194">请注意，若要引用多个集合类型，必须多次指定 **/collectionType** 开关。</span><span class="sxs-lookup"><span data-stu-id="ac16b-194">Note that to reference multiple collection types, the **/collectionType** switch must be specified multiple times.</span></span> <span data-ttu-id="ac16b-195">如果该类型不在 MsCorLib.dll 中，则还必须使用 **/reference** 开关引用其程序集。</span><span class="sxs-lookup"><span data-stu-id="ac16b-195">If the type is not in the MsCorLib.dll, its assembly must also be referenced using the **/reference** switch.</span></span>  
  
#### <a name="import-options-referencing-existing-types"></a><span data-ttu-id="ac16b-196">导入选项：引用现有类型</span><span class="sxs-lookup"><span data-stu-id="ac16b-196">Import Options: Referencing Existing Types</span></span>  

 <span data-ttu-id="ac16b-197">有时，架构中的类型对应于现有 .NET Framework 类型，无需从头开始生成这些类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-197">Occasionally, types in schema correspond to existing .NET Framework types, and there is no need to generate these types from scratch.</span></span> <span data-ttu-id="ac16b-198">（本节仅适用于非集合类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-198">(This section applies only to noncollection types.</span></span> <span data-ttu-id="ac16b-199">有关集合类型，请参见上一节。）</span><span class="sxs-lookup"><span data-stu-id="ac16b-199">For collection types, see the preceding section.)</span></span>  
  
 <span data-ttu-id="ac16b-200">例如，您可能有一个标准公司范围内的“Person”数据协定类型，通常在表示人员时需要使用它。</span><span class="sxs-lookup"><span data-stu-id="ac16b-200">For example, you may have a standard company-wide "Person" data contract type that you always want used when representing a person.</span></span> <span data-ttu-id="ac16b-201">每当某个服务利用该类型且其架构显示在该服务元数据中时，在导入此架构时您可能需要重用现有的 `Person` 类型，而不需要为每个服务生成新的类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-201">Whenever some service makes use of this type, and its schema appears in the service metadata, you may want to reuse the existing `Person` type when importing this schema instead of generating a new one for every service.</span></span>  
  
 <span data-ttu-id="ac16b-202">为此，请将你想要重用的 .NET Framework 类型的列表传递到 <xref:System.Runtime.Serialization.ImportOptions.ReferencedTypes%2A> 属性在类上返回的集合中 <xref:System.Runtime.Serialization.ImportOptions> 。</span><span class="sxs-lookup"><span data-stu-id="ac16b-202">To do this, pass a list of .NET Framework types that you want to reuse into the collection the <xref:System.Runtime.Serialization.ImportOptions.ReferencedTypes%2A> property returns on the <xref:System.Runtime.Serialization.ImportOptions> class.</span></span> <span data-ttu-id="ac16b-203">如果任何这些类型的数据协定名称和命名空间与架构类型的名称和命名空间相匹配，则执行结构比较。</span><span class="sxs-lookup"><span data-stu-id="ac16b-203">If any of these types have a data contract name and namespace that matches the name and namespace of a schema type, a structural comparison is performed.</span></span> <span data-ttu-id="ac16b-204">如果确定这些类型同时具有匹配的名称和匹配结构，则将重用现有的 .NET Framework 类型，而不是生成新的类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-204">If it is determined that the types have both matching names and matching structures, the existing .NET Framework type is reused instead of generating a new one.</span></span> <span data-ttu-id="ac16b-205">如果仅名称匹配而构造不匹配，则引发异常。</span><span class="sxs-lookup"><span data-stu-id="ac16b-205">If only the name matches but not the structure, an exception is thrown.</span></span> <span data-ttu-id="ac16b-206">请注意，引用类型（例如，添加新的可选数据成员）时不允许进行版本管理。</span><span class="sxs-lookup"><span data-stu-id="ac16b-206">Note that there is no allowance for versioning when referencing types (for example, adding new optional data members).</span></span> <span data-ttu-id="ac16b-207">构造必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ac16b-207">The structures must match exactly.</span></span>  
  
 <span data-ttu-id="ac16b-208">向引用的类型集合添加多个具有相同数据协定名称和命名空间的类型是合法的，前提是不导入具有该名称和命名空间的架构类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-208">It is legal to add multiple types with the same data contract name and namespace to the referenced types collection, as long as no schema types are imported with that name and namespace.</span></span> <span data-ttu-id="ac16b-209">这样您就可以轻松地将程序集中的所有类型添加到集合中，而无需担心在架构中并未实际出现的类型重复项。</span><span class="sxs-lookup"><span data-stu-id="ac16b-209">This allows you to easily add all the types in an assembly to the collection without worrying about duplicates for types that do not actually occur in schema.</span></span>  
  
 <span data-ttu-id="ac16b-210">`ReferencedTypes`属性对应于在 Svcutil.exe 工具的某些操作模式下的 **/reference** 开关。</span><span class="sxs-lookup"><span data-stu-id="ac16b-210">The `ReferencedTypes` property corresponds to the **/reference** switch in certain modes of operation of the Svcutil.exe tool.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac16b-211">在 Visual Studio 中使用 Svcutil.exe 或 () **添加服务引用** 工具时，将自动引用 MsCorLib.dll 中的所有类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-211">When using the Svcutil.exe or (in Visual Studio) the **Add Service Reference** tools, all of the types in MsCorLib.dll are automatically referenced.</span></span>  
  
#### <a name="import-options-importing-non-datacontract-schema-as-ixmlserializable-types"></a><span data-ttu-id="ac16b-212">导入选项：将 Non-DataContract 架构作为 IXmlSerializable 类型导入</span><span class="sxs-lookup"><span data-stu-id="ac16b-212">Import Options: Importing Non-DataContract Schema as IXmlSerializable types</span></span>  

 <span data-ttu-id="ac16b-213"><xref:System.Runtime.Serialization.XsdDataContractImporter> 支持架构的有限子集。</span><span class="sxs-lookup"><span data-stu-id="ac16b-213">The <xref:System.Runtime.Serialization.XsdDataContractImporter> supports a limited subset of the schema.</span></span> <span data-ttu-id="ac16b-214">如果出现不受支持的架构构造（例如，XML 属性），导入尝试会失败并引发异常。</span><span class="sxs-lookup"><span data-stu-id="ac16b-214">If unsupported schema constructs are present (for example, XML attributes), the import attempt fails with an exception.</span></span> <span data-ttu-id="ac16b-215">但是，将 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 属性设置为 `true` 可扩展受支持架构的范围。</span><span class="sxs-lookup"><span data-stu-id="ac16b-215">However, setting the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> property to `true` extends the range of schema supported.</span></span> <span data-ttu-id="ac16b-216">设置为 `true` 时，<xref:System.Runtime.Serialization.XsdDataContractImporter> 生成可实现 <xref:System.Xml.Serialization.IXmlSerializable> 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="ac16b-216">When set to `true`, the <xref:System.Runtime.Serialization.XsdDataContractImporter> generates types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span> <span data-ttu-id="ac16b-217">这样可直接访问这些类型的 XML 表示形式。</span><span class="sxs-lookup"><span data-stu-id="ac16b-217">This enables direct access to the XML representation of these types.</span></span>  
  
##### <a name="design-considerations"></a><span data-ttu-id="ac16b-218">设计注意事项</span><span class="sxs-lookup"><span data-stu-id="ac16b-218">Design Considerations</span></span>  
  
- <span data-ttu-id="ac16b-219">直接使用弱类型 XML 表示形式可能有些困难。</span><span class="sxs-lookup"><span data-stu-id="ac16b-219">It may be difficult to work with the weakly typed XML representation directly.</span></span> <span data-ttu-id="ac16b-220">可以考虑使用其他序列化引擎（例如 <xref:System.Xml.Serialization.XmlSerializer>），以便以强类型方式使用与数据协定不兼容的架构。</span><span class="sxs-lookup"><span data-stu-id="ac16b-220">Consider using an alternative serialization engine, such as the <xref:System.Xml.Serialization.XmlSerializer>, to work with schema not compatible with data contracts in a strongly typed way.</span></span> <span data-ttu-id="ac16b-221">有关详细信息，请参阅 [使用 XmlSerializer 类](using-the-xmlserializer-class.md)。</span><span class="sxs-lookup"><span data-stu-id="ac16b-221">For more information, see [Using the XmlSerializer Class](using-the-xmlserializer-class.md).</span></span>  
  
- <span data-ttu-id="ac16b-222">某些架构构造不能通过 <xref:System.Runtime.Serialization.XsdDataContractImporter> 事件导入，即使是 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="ac16b-222">Some schema constructs cannot be imported by the <xref:System.Runtime.Serialization.XsdDataContractImporter> even when the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> property is set to `true`.</span></span> <span data-ttu-id="ac16b-223">此外，在此情况下可以考虑使用 <xref:System.Xml.Serialization.XmlSerializer>。</span><span class="sxs-lookup"><span data-stu-id="ac16b-223">Again, consider using the <xref:System.Xml.Serialization.XmlSerializer> for such cases.</span></span>  
  
- <span data-ttu-id="ac16b-224">当 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 是 `true` 或 `false` 在 [数据协定架构引用](data-contract-schema-reference.md)中描述时，支持的确切架构构造。</span><span class="sxs-lookup"><span data-stu-id="ac16b-224">The exact schema constructs that are supported both when <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> is `true` or `false` are described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>  
  
- <span data-ttu-id="ac16b-225">生成的 <xref:System.Xml.Serialization.IXmlSerializable> 类型的架构在导入和导出时不保留保真。</span><span class="sxs-lookup"><span data-stu-id="ac16b-225">Schema for generated <xref:System.Xml.Serialization.IXmlSerializable> types do not retain fidelity when imported and exported.</span></span> <span data-ttu-id="ac16b-226">也就是说，从生成的类型导出架构或作为类导入时不返回原始架构。</span><span class="sxs-lookup"><span data-stu-id="ac16b-226">That is, exporting the schema from the generated types and importing as classes does not return the original schema.</span></span>  
  
 <span data-ttu-id="ac16b-227">可以结合使用 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 选项和上述 <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> 选项。</span><span class="sxs-lookup"><span data-stu-id="ac16b-227">It is possible to combine the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> option with the <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> option previously described.</span></span> <span data-ttu-id="ac16b-228">对于那些必须作为 <xref:System.Xml.Serialization.IXmlSerializable> 实现生成的类型，使用 <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> 功能时将跳过结构检查。</span><span class="sxs-lookup"><span data-stu-id="ac16b-228">For types that have to be generated as <xref:System.Xml.Serialization.IXmlSerializable> implementations, the structural check is skipped when using the <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> feature.</span></span>  
  
 <span data-ttu-id="ac16b-229"><xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A>选项对应于 Svcutil.exe 工具上的 **/importXmlTypes** 开关。</span><span class="sxs-lookup"><span data-stu-id="ac16b-229">The <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> option corresponds to the **/importXmlTypes** switch on the Svcutil.exe tool.</span></span>  
  
##### <a name="working-with-generated-ixmlserializable-types"></a><span data-ttu-id="ac16b-230">使用生成的 IXmlSerializable 类型</span><span class="sxs-lookup"><span data-stu-id="ac16b-230">Working with Generated IXmlSerializable Types</span></span>  

 <span data-ttu-id="ac16b-231">生成的 `IXmlSerializable` 类型包含名为“nodesField”的私有字段，该字段返回一个 <xref:System.Xml.XmlNode> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="ac16b-231">The generated `IXmlSerializable` types contain a private field, named "nodesField," that returns an array of <xref:System.Xml.XmlNode> objects.</span></span> <span data-ttu-id="ac16b-232">反序列化此类的实例时，可以使用 XML 文档对象模型直接通过该字段访问 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="ac16b-232">When deserializing an instance of such a type, you can access the XML data directly through this field by using the XML Document Object Model.</span></span> <span data-ttu-id="ac16b-233">序列化此类的实例时，可以将该字段设置为所需的 XML 数据，然后它将被序列化。</span><span class="sxs-lookup"><span data-stu-id="ac16b-233">When serializing an instance of this type, you can set this field to the desired XML data and it will be serialized.</span></span>  
  
 <span data-ttu-id="ac16b-234">这是通过 `IXmlSerializable` 实现完成的。</span><span class="sxs-lookup"><span data-stu-id="ac16b-234">This is accomplished through the `IXmlSerializable` implementation.</span></span> <span data-ttu-id="ac16b-235">在生成的 `IXmlSerializable` 类型中，<xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 实现调用 <xref:System.Runtime.Serialization.XmlSerializableServices.ReadNodes%2A> 类的 <xref:System.Runtime.Serialization.XmlSerializableServices> 方法。</span><span class="sxs-lookup"><span data-stu-id="ac16b-235">In the generated `IXmlSerializable` type, the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> implementation calls the <xref:System.Runtime.Serialization.XmlSerializableServices.ReadNodes%2A> method of the <xref:System.Runtime.Serialization.XmlSerializableServices> class.</span></span> <span data-ttu-id="ac16b-236">该方法是一个帮助器方法，将所提供的 XML 通过 <xref:System.Xml.XmlReader> 转换为一个 <xref:System.Xml.XmlNode> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="ac16b-236">The method is a helper method that converts XML provided through an <xref:System.Xml.XmlReader> to an array of <xref:System.Xml.XmlNode> objects.</span></span> <span data-ttu-id="ac16b-237"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 实现执行相反操作，将 `XmlNode` 对象数组转换为一个 <xref:System.Xml.XmlWriter> 调用序列。</span><span class="sxs-lookup"><span data-stu-id="ac16b-237">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation does the opposite and converts the array of `XmlNode` objects to a sequence of <xref:System.Xml.XmlWriter> calls.</span></span> <span data-ttu-id="ac16b-238">这是使用 <xref:System.Runtime.Serialization.XmlSerializableServices.WriteNodes%2A> 方法完成的。</span><span class="sxs-lookup"><span data-stu-id="ac16b-238">This is accomplished using the <xref:System.Runtime.Serialization.XmlSerializableServices.WriteNodes%2A> method.</span></span>  
  
 <span data-ttu-id="ac16b-239">可以在生成的 `IXmlSerializable` 类上运行架构导出过程。</span><span class="sxs-lookup"><span data-stu-id="ac16b-239">It is possible to run the schema export process on the generated `IXmlSerializable` classes.</span></span> <span data-ttu-id="ac16b-240">如上所述，您将不会重新获得原始架构。</span><span class="sxs-lookup"><span data-stu-id="ac16b-240">As previously stated, you will not get the original schema back.</span></span> <span data-ttu-id="ac16b-241">相反，你将获得 "anyType" 标准 XSD 类型，它是任何 XSD 类型的通配符。</span><span class="sxs-lookup"><span data-stu-id="ac16b-241">Instead, you will get the "anyType" standard XSD type, which is a wildcard for any XSD type.</span></span>  
  
 <span data-ttu-id="ac16b-242">这是通过将属性应用 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 到生成的 `IXmlSerializable` 类并指定调用 <xref:System.Runtime.Serialization.XmlSerializableServices.AddDefaultSchema%2A> 方法以生成 "anyType" 类型的方法来实现的。</span><span class="sxs-lookup"><span data-stu-id="ac16b-242">This is accomplished by applying the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to the generated `IXmlSerializable` classes and specifying a method that calls the <xref:System.Runtime.Serialization.XmlSerializableServices.AddDefaultSchema%2A> method to generate the "anyType" type.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac16b-243"><xref:System.Runtime.Serialization.XmlSerializableServices> 类型存在的目的只是为了支持此特定功能。</span><span class="sxs-lookup"><span data-stu-id="ac16b-243">The <xref:System.Runtime.Serialization.XmlSerializableServices> type exists solely to support this particular feature.</span></span> <span data-ttu-id="ac16b-244">建议不将其用于任何其他目的。</span><span class="sxs-lookup"><span data-stu-id="ac16b-244">It is not recommended for use for any other purpose.</span></span>  
  
#### <a name="import-options-advanced-options"></a><span data-ttu-id="ac16b-245">导入选项：高级选项</span><span class="sxs-lookup"><span data-stu-id="ac16b-245">Import Options: Advanced Options</span></span>  

 <span data-ttu-id="ac16b-246">下面介绍高级导入选项：</span><span class="sxs-lookup"><span data-stu-id="ac16b-246">The following are advanced import options:</span></span>  
  
- <span data-ttu-id="ac16b-247"><xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ac16b-247"><xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> property.</span></span> <span data-ttu-id="ac16b-248">指定用于为生成的类生成代码的 <xref:System.CodeDom.Compiler.CodeDomProvider>。</span><span class="sxs-lookup"><span data-stu-id="ac16b-248">Specify the <xref:System.CodeDom.Compiler.CodeDomProvider> to use to generate the code for the generated classes.</span></span> <span data-ttu-id="ac16b-249">导入机制尝试避免不受 <xref:System.CodeDom.Compiler.CodeDomProvider> 支持的功能。</span><span class="sxs-lookup"><span data-stu-id="ac16b-249">The import mechanism attempts to avoid features that the <xref:System.CodeDom.Compiler.CodeDomProvider> does not support.</span></span> <span data-ttu-id="ac16b-250">如果 <xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> 未设置，则使用一组完整的 .NET Framework 功能，无任何限制。</span><span class="sxs-lookup"><span data-stu-id="ac16b-250">If the <xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> is not set, the full set of .NET Framework features is used with no restrictions.</span></span>  
  
- <span data-ttu-id="ac16b-251"><xref:System.Runtime.Serialization.ImportOptions.DataContractSurrogate%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ac16b-251"><xref:System.Runtime.Serialization.ImportOptions.DataContractSurrogate%2A> property.</span></span> <span data-ttu-id="ac16b-252">一个可用此属性指定的 <xref:System.Runtime.Serialization.IDataContractSurrogate> 实现。</span><span class="sxs-lookup"><span data-stu-id="ac16b-252">An <xref:System.Runtime.Serialization.IDataContractSurrogate> implementation can be specified with this property.</span></span> <span data-ttu-id="ac16b-253"><xref:System.Runtime.Serialization.IDataContractSurrogate> 自定义导入过程。</span><span class="sxs-lookup"><span data-stu-id="ac16b-253">The <xref:System.Runtime.Serialization.IDataContractSurrogate> customizes the import process.</span></span> <span data-ttu-id="ac16b-254">有关详细信息，请参阅 [数据协定代理](../extending/data-contract-surrogates.md)项。</span><span class="sxs-lookup"><span data-stu-id="ac16b-254">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span> <span data-ttu-id="ac16b-255">默认情况下，不使用代理项。</span><span class="sxs-lookup"><span data-stu-id="ac16b-255">By default, no surrogate is used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ac16b-256">请参阅</span><span class="sxs-lookup"><span data-stu-id="ac16b-256">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.XsdDataContractImporter>
- <xref:System.Runtime.Serialization.XsdDataContractExporter>
- <xref:System.Runtime.Serialization.ImportOptions>
- [<span data-ttu-id="ac16b-257">数据协定架构参考</span><span class="sxs-lookup"><span data-stu-id="ac16b-257">Data Contract Schema Reference</span></span>](data-contract-schema-reference.md)
- [<span data-ttu-id="ac16b-258">数据协定代理项</span><span class="sxs-lookup"><span data-stu-id="ac16b-258">Data Contract Surrogates</span></span>](../extending/data-contract-surrogates.md)
- [<span data-ttu-id="ac16b-259">架构导入和导出</span><span class="sxs-lookup"><span data-stu-id="ac16b-259">Schema Import and Export</span></span>](schema-import-and-export.md)
- [<span data-ttu-id="ac16b-260">从类导出架构</span><span class="sxs-lookup"><span data-stu-id="ac16b-260">Exporting Schemas from Classes</span></span>](exporting-schemas-from-classes.md)
- [<span data-ttu-id="ac16b-261">数据协定架构参考</span><span class="sxs-lookup"><span data-stu-id="ac16b-261">Data Contract Schema Reference</span></span>](data-contract-schema-reference.md)
