---
title: C# 9.0 中的新增功能 - C# 指南
description: 简要介绍 C# 9.0 中提供的新功能。
ms.date: 09/04/2020
ms.openlocfilehash: 49170b123f612c06f22b70e44b29ad7be5f382ea
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/23/2021
ms.locfileid: "104876040"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="58424-103">C# 9.0 中的新增功能</span><span class="sxs-lookup"><span data-stu-id="58424-103">What's new in C# 9.0</span></span>

<span data-ttu-id="58424-104">C# 9.0 向 C# 语言添加了以下功能和增强功能：</span><span class="sxs-lookup"><span data-stu-id="58424-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="58424-105">记录</span><span class="sxs-lookup"><span data-stu-id="58424-105">Records</span></span>](#record-types)
- [<span data-ttu-id="58424-106">仅限 Init 的资源库</span><span class="sxs-lookup"><span data-stu-id="58424-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="58424-107">顶级语句</span><span class="sxs-lookup"><span data-stu-id="58424-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="58424-108">模式匹配增强功能</span><span class="sxs-lookup"><span data-stu-id="58424-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="58424-109">本机大小的整数</span><span class="sxs-lookup"><span data-stu-id="58424-109">Native sized integers</span></span>
- <span data-ttu-id="58424-110">函数指针</span><span class="sxs-lookup"><span data-stu-id="58424-110">Function pointers</span></span>
- <span data-ttu-id="58424-111">禁止发出 localsinit 标志</span><span class="sxs-lookup"><span data-stu-id="58424-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="58424-112">目标类型的新表达式</span><span class="sxs-lookup"><span data-stu-id="58424-112">Target-typed new expressions</span></span>
- <span data-ttu-id="58424-113">静态匿名函数</span><span class="sxs-lookup"><span data-stu-id="58424-113">static anonymous functions</span></span>
- <span data-ttu-id="58424-114">目标类型的条件表达式</span><span class="sxs-lookup"><span data-stu-id="58424-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="58424-115">协变返回类型</span><span class="sxs-lookup"><span data-stu-id="58424-115">Covariant return types</span></span>
- <span data-ttu-id="58424-116">扩展 `GetEnumerator` 支持 `foreach` 循环</span><span class="sxs-lookup"><span data-stu-id="58424-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="58424-117">Lambda 弃元参数</span><span class="sxs-lookup"><span data-stu-id="58424-117">Lambda discard parameters</span></span>
- <span data-ttu-id="58424-118">本地函数的属性</span><span class="sxs-lookup"><span data-stu-id="58424-118">Attributes on local functions</span></span>
- <span data-ttu-id="58424-119">模块初始值设定项</span><span class="sxs-lookup"><span data-stu-id="58424-119">Module initializers</span></span>
- <span data-ttu-id="58424-120">分部方法的新功能</span><span class="sxs-lookup"><span data-stu-id="58424-120">New features for partial methods</span></span>

<span data-ttu-id="58424-121">.NET 5 支持 C# 9.0。</span><span class="sxs-lookup"><span data-stu-id="58424-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="58424-122">有关详细信息，请参阅 [C# 语言版本控制](../language-reference/configure-language-version.md)。</span><span class="sxs-lookup"><span data-stu-id="58424-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="58424-123">可以从 [.NET 下载页](https://dotnet.microsoft.com/download)下载最新 .NET SDK。</span><span class="sxs-lookup"><span data-stu-id="58424-123">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="58424-124">记录类型</span><span class="sxs-lookup"><span data-stu-id="58424-124">Record types</span></span>

<span data-ttu-id="58424-125">C# 9.0 引入了记录类型，这是一种引用类型，它提供合成方法来提供值语义，从而实现相等性。</span><span class="sxs-lookup"><span data-stu-id="58424-125">C# 9.0 introduces ***record types***, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="58424-126">默认情况下，记录是不可变的。</span><span class="sxs-lookup"><span data-stu-id="58424-126">Records are immutable by default.</span></span>

<span data-ttu-id="58424-127">使用记录类型可在 .NET 中轻松创建不可变的引用类型。</span><span class="sxs-lookup"><span data-stu-id="58424-127">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="58424-128">以前，.NET 类型主要分为引用类型（包括类和匿名类型）和值类型（包括结构和元组）。</span><span class="sxs-lookup"><span data-stu-id="58424-128">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="58424-129">虽然建议使用不可变的值类型，但可变的值类型通常不会引入错误。</span><span class="sxs-lookup"><span data-stu-id="58424-129">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="58424-130">值类型变量可保存值，因此在将值类型传递给方法时，会对原始数据的副本进行更改。</span><span class="sxs-lookup"><span data-stu-id="58424-130">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="58424-131">不可变的引用类型也有许多优点。</span><span class="sxs-lookup"><span data-stu-id="58424-131">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="58424-132">这些优点在使用共享数据的并发程序中更为明显。</span><span class="sxs-lookup"><span data-stu-id="58424-132">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="58424-133">遗憾的是，C# 强制编写大量额外的代码来创建不可变的引用类型。</span><span class="sxs-lookup"><span data-stu-id="58424-133">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="58424-134">记录为不可变的引用类型提供类型声明，该引用类型使用值语义实现相等性。</span><span class="sxs-lookup"><span data-stu-id="58424-134">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="58424-135">如果用于实现相等性的合成方法的属性和哈希代码的属性都相等，则认为两条记录相等。</span><span class="sxs-lookup"><span data-stu-id="58424-135">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="58424-136">请考虑以下定义：</span><span class="sxs-lookup"><span data-stu-id="58424-136">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="58424-137">记录定义会创建一个包含两个只读属性（`FirstName` 和 `LastName`）的 `Person` 类型。</span><span class="sxs-lookup"><span data-stu-id="58424-137">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="58424-138">`Person` 类型是引用类型。</span><span class="sxs-lookup"><span data-stu-id="58424-138">The `Person` type is a reference type.</span></span> <span data-ttu-id="58424-139">如果查看 IL，它就是一个类。</span><span class="sxs-lookup"><span data-stu-id="58424-139">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="58424-140">它是不可变的，因为在创建它后，无法修改任何属性。</span><span class="sxs-lookup"><span data-stu-id="58424-140">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="58424-141">定义记录类型时，编译器会合成其他几种方法：</span><span class="sxs-lookup"><span data-stu-id="58424-141">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="58424-142">基于值的相等性比较方法</span><span class="sxs-lookup"><span data-stu-id="58424-142">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="58424-143">替代 <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="58424-143">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="58424-144">复制和克隆成员</span><span class="sxs-lookup"><span data-stu-id="58424-144">Copy and Clone members</span></span>
- <span data-ttu-id="58424-145">`PrintMembers` 和 <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="58424-145">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="58424-146">记录支持继承。</span><span class="sxs-lookup"><span data-stu-id="58424-146">Records support inheritance.</span></span> <span data-ttu-id="58424-147">可声明派生自 `Person` 的新记录，如下所示：</span><span class="sxs-lookup"><span data-stu-id="58424-147">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="58424-148">还可密封记录以防止进一步派生：</span><span class="sxs-lookup"><span data-stu-id="58424-148">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="58424-149">编译器会合成上述方法的不同版本。</span><span class="sxs-lookup"><span data-stu-id="58424-149">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="58424-150">方法签名取决于记录类型是否密封以及直接基类是否为对象。</span><span class="sxs-lookup"><span data-stu-id="58424-150">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="58424-151">记录应具有以下功能：</span><span class="sxs-lookup"><span data-stu-id="58424-151">Records should have the following capabilities:</span></span>

- <span data-ttu-id="58424-152">相等性是基于值的，包括检查类型是否匹配。</span><span class="sxs-lookup"><span data-stu-id="58424-152">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="58424-153">例如，即使两条记录的名称相同，`Student` 也不能等于 `Person`。</span><span class="sxs-lookup"><span data-stu-id="58424-153">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="58424-154">记录具有为你生成的一致的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="58424-154">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="58424-155">记录支持副本构造。</span><span class="sxs-lookup"><span data-stu-id="58424-155">Records support copy construction.</span></span> <span data-ttu-id="58424-156">正确的副本构造必须包括继承层次结构和开发人员添加的属性。</span><span class="sxs-lookup"><span data-stu-id="58424-156">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="58424-157">可通过修改复制记录。</span><span class="sxs-lookup"><span data-stu-id="58424-157">Records can be copied with modification.</span></span> <span data-ttu-id="58424-158">这些复制和修改操作支持非破坏性转变。</span><span class="sxs-lookup"><span data-stu-id="58424-158">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="58424-159">除了熟悉的 `Equals` 重载、`operator ==` 和 `operator !=` 外，编译器还会合成新的 `EqualityContract` 属性。</span><span class="sxs-lookup"><span data-stu-id="58424-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="58424-160">该属性返回与记录类型匹配的 `Type` 对象。</span><span class="sxs-lookup"><span data-stu-id="58424-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="58424-161">如果基类型为 `object`，则属性为 `virtual`。</span><span class="sxs-lookup"><span data-stu-id="58424-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="58424-162">如果基类型是其他记录类型，则属性为 `override`。</span><span class="sxs-lookup"><span data-stu-id="58424-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="58424-163">如果记录类型为 `sealed`，则属性为 `sealed`。</span><span class="sxs-lookup"><span data-stu-id="58424-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="58424-164">合成的 `GetHashCode` 使用基类型和记录类型中声明的所有属性和字段中的 `GetHashCode`。</span><span class="sxs-lookup"><span data-stu-id="58424-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="58424-165">这些合成方法在整个继承层次结构中强制执行基于值的相等性。</span><span class="sxs-lookup"><span data-stu-id="58424-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="58424-166">这意味着，绝不会将 `Student` 视为与同名的 `Person` 相等。</span><span class="sxs-lookup"><span data-stu-id="58424-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="58424-167">两条记录的类型必须匹配，而且记录类型之间共享的所有属性也必须相等。</span><span class="sxs-lookup"><span data-stu-id="58424-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="58424-168">记录还具有合成的构造函数和用于创建副本的“克隆”方法。</span><span class="sxs-lookup"><span data-stu-id="58424-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="58424-169">合成的构造函数有一个记录类型的参数。</span><span class="sxs-lookup"><span data-stu-id="58424-169">The synthesized constructor has a single parameter of the record type.</span></span> <span data-ttu-id="58424-170">该函数会为记录的所有属性生成具有相同值的新记录。</span><span class="sxs-lookup"><span data-stu-id="58424-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="58424-171">如果记录是密封的，则此构造函数是专用函数；否则它将受到保护。</span><span class="sxs-lookup"><span data-stu-id="58424-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="58424-172">合成的“克隆”方法支持用于记录层次结构的副本构造。</span><span class="sxs-lookup"><span data-stu-id="58424-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="58424-173">“克隆”一词用引号引起来，因为实际名称是编译器生成的。</span><span class="sxs-lookup"><span data-stu-id="58424-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="58424-174">无法在记录类型中创建名为 `Clone` 的方法。</span><span class="sxs-lookup"><span data-stu-id="58424-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="58424-175">合成的“克隆”方法返回使用虚拟调度复制的记录类型。</span><span class="sxs-lookup"><span data-stu-id="58424-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="58424-176">编译器根据 `record` 上的访问修饰符为“克隆”方法添加不同的修饰符：</span><span class="sxs-lookup"><span data-stu-id="58424-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="58424-177">如果记录类型为 `abstract`，则“克隆”方法也为 `abstract`。</span><span class="sxs-lookup"><span data-stu-id="58424-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="58424-178">如果基类型不是 `object`，则方法也是 `override`。</span><span class="sxs-lookup"><span data-stu-id="58424-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="58424-179">当基类型为 `object` 时，对于不是 `abstract` 的记录类型：</span><span class="sxs-lookup"><span data-stu-id="58424-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="58424-180">如果记录为 `sealed`，则不向“克隆”方法添加其他修饰符（这意味着它不是 `virtual`）。</span><span class="sxs-lookup"><span data-stu-id="58424-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="58424-181">如果记录不是 `sealed`，则“克隆”方法为 `virtual`。</span><span class="sxs-lookup"><span data-stu-id="58424-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="58424-182">当基类型不是 `object` 时，对于不是 `abstract` 的记录类型：</span><span class="sxs-lookup"><span data-stu-id="58424-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="58424-183">如果记录是 `sealed`，则“克隆”方法也是 `sealed`。</span><span class="sxs-lookup"><span data-stu-id="58424-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="58424-184">如果记录不是 `sealed`，则“克隆”方法为 `override`。</span><span class="sxs-lookup"><span data-stu-id="58424-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="58424-185">所有这些规则的结果都是，跨记录类型的任何层次结构一致地实现了相等性。</span><span class="sxs-lookup"><span data-stu-id="58424-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="58424-186">如果两条记录的属性相等且类型相同，则它们彼此相等，如下例所示：</span><span class="sxs-lookup"><span data-stu-id="58424-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="58424-187">编译器合成了两种支持打印输出的方法：<xref:System.Object.ToString> 替代和 `PrintMembers`。</span><span class="sxs-lookup"><span data-stu-id="58424-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="58424-188">`PrintMembers` 采用 <xref:System.Text.StringBuilder?displayProperty=nameWithType> 作为其参数。</span><span class="sxs-lookup"><span data-stu-id="58424-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="58424-189">它对记录类型中的所有属性追加一个用逗号分隔的属性名称和值的列表。</span><span class="sxs-lookup"><span data-stu-id="58424-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="58424-190">`PrintMembers` 会调用派生自其他记录的任何记录的基本实现。</span><span class="sxs-lookup"><span data-stu-id="58424-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="58424-191"><xref:System.Object.ToString> 替代会返回由 `PrintMembers` 生成的字符串，并将其括在 `{` 和 `}` 内。</span><span class="sxs-lookup"><span data-stu-id="58424-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="58424-192">例如，`Student` 的 <xref:System.Object.ToString> 方法返回一个 `string`，类似于以下代码：</span><span class="sxs-lookup"><span data-stu-id="58424-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="58424-193">截至目前显示的示例都使用传统语法声明属性。</span><span class="sxs-lookup"><span data-stu-id="58424-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="58424-194">还有一种更简洁的格式，称为“位置记录”。</span><span class="sxs-lookup"><span data-stu-id="58424-194">There's a more concise form called ***positional records***.</span></span>  <span data-ttu-id="58424-195">下面是先前定义为位置记录的 3 种记录类型：</span><span class="sxs-lookup"><span data-stu-id="58424-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="58424-196">这些声明创建的功能与早期版本相同（以下部分介绍了几项额外的功能）。</span><span class="sxs-lookup"><span data-stu-id="58424-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="58424-197">这些声明以分号而不是方括号结尾，因为这些记录没有添加其他方法。</span><span class="sxs-lookup"><span data-stu-id="58424-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="58424-198">可添加正文，还可包括其他任何方法：</span><span class="sxs-lookup"><span data-stu-id="58424-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="58424-199">编译器为位置记录生成 `Deconstruct` 方法。</span><span class="sxs-lookup"><span data-stu-id="58424-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="58424-200">`Deconstruct` 方法的参数与记录类型中所有公共属性的名称匹配。</span><span class="sxs-lookup"><span data-stu-id="58424-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="58424-201">`Deconstruct` 方法可用于将记录析构为其组件属性：</span><span class="sxs-lookup"><span data-stu-id="58424-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="58424-202">最后，记录支持 [`with` 表达式](../language-reference/operators/with-expression.md)。</span><span class="sxs-lookup"><span data-stu-id="58424-202">Finally, records support [`with` expressions](../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="58424-203">`with` 表达式指示编译器创建一个记录的副本，但要修改指定的属性：</span><span class="sxs-lookup"><span data-stu-id="58424-203">A ***`with` expression** _ instructs the compiler to create a copy of a record, but _with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="58424-204">上一行创建新的 `Person` 记录，其中 `LastName` 属性是 `person` 的副本，`FirstName` 为 `"Paul"`。</span><span class="sxs-lookup"><span data-stu-id="58424-204">The previous line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is `"Paul"`.</span></span> <span data-ttu-id="58424-205">可在 `with` 表达式中设置任意数量的属性。</span><span class="sxs-lookup"><span data-stu-id="58424-205">You can set any number of properties in a `with` expression.</span></span> <span data-ttu-id="58424-206">还可以使用 `with` 表达式来创建精确的副本。</span><span class="sxs-lookup"><span data-stu-id="58424-206">You can also use `with` expressions to create an exact copy.</span></span> <span data-ttu-id="58424-207">为要修改的属性指定空集：</span><span class="sxs-lookup"><span data-stu-id="58424-207">You specify the empty set for the properties to modify:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="WithCopy":::

<span data-ttu-id="58424-208">你可编写除“克隆”方法以外的任何合成成员。</span><span class="sxs-lookup"><span data-stu-id="58424-208">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="58424-209">如果记录类型的方法与任何合成方法的签名匹配，则编译器不会合成该方法。</span><span class="sxs-lookup"><span data-stu-id="58424-209">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="58424-210">较早的 `Dog` 记录示例包含手动编码的 <xref:System.String.ToString> 方法作为示例。</span><span class="sxs-lookup"><span data-stu-id="58424-210">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

<span data-ttu-id="58424-211">了解有关此[浏览记录](../whats-new/tutorials/records.md)教程中记录类型的详细信息。</span><span class="sxs-lookup"><span data-stu-id="58424-211">Learn more about record types in this [exploration of records](../whats-new/tutorials/records.md) tutorial.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="58424-212">仅限 Init 的资源库</span><span class="sxs-lookup"><span data-stu-id="58424-212">Init only setters</span></span>

<span data-ttu-id="58424-213">仅限 init 的资源库提供一致的语法来初始化对象的成员。</span><span class="sxs-lookup"><span data-stu-id="58424-213">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="58424-214">属性初始值设定项可明确哪个值正在设置哪个属性。</span><span class="sxs-lookup"><span data-stu-id="58424-214">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="58424-215">缺点是这些属性必须是可设置的。</span><span class="sxs-lookup"><span data-stu-id="58424-215">The downside is that those properties must be settable.</span></span> <span data-ttu-id="58424-216">从 C# 9.0 开始，可为属性和索引器创建 `init` 访问器，而不是 `set` 访问器。</span><span class="sxs-lookup"><span data-stu-id="58424-216">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="58424-217">调用方可使用属性初始化表达式语法在创建表达式中设置这些值，但构造完成后，这些属性将变为只读。</span><span class="sxs-lookup"><span data-stu-id="58424-217">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="58424-218">仅限 init 的资源库提供了一个窗口用来更改状态。</span><span class="sxs-lookup"><span data-stu-id="58424-218">Init only setters provide a window to change state.</span></span> <span data-ttu-id="58424-219">构造阶段结束时，该窗口关闭。</span><span class="sxs-lookup"><span data-stu-id="58424-219">That window closes when the construction phase ends.</span></span> <span data-ttu-id="58424-220">在完成所有初始化（包括属性初始化表达式和 with 表达式）之后，构造阶段实际上就结束了。</span><span class="sxs-lookup"><span data-stu-id="58424-220">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="58424-221">可在编写的任何类型中声明仅限 `init` 的资源库。</span><span class="sxs-lookup"><span data-stu-id="58424-221">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="58424-222">例如，以下结构定义了天气观察结构：</span><span class="sxs-lookup"><span data-stu-id="58424-222">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="58424-223">调用方可使用属性初始化表达式语法来设置值，同时仍保留不变性：</span><span class="sxs-lookup"><span data-stu-id="58424-223">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="58424-224">但在初始化后更改观察值是错误的，它会在初始化之外分配给仅限 init 的属性：</span><span class="sxs-lookup"><span data-stu-id="58424-224">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="58424-225">对于从派生类设置基类属性，仅限 init 的资源库很有用。</span><span class="sxs-lookup"><span data-stu-id="58424-225">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="58424-226">它们还可通过基类中的帮助程序来设置派生属性。</span><span class="sxs-lookup"><span data-stu-id="58424-226">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="58424-227">位置记录使用仅限 init 的资源库声明属性。</span><span class="sxs-lookup"><span data-stu-id="58424-227">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="58424-228">这些设置器可在 with 表达式中使用。</span><span class="sxs-lookup"><span data-stu-id="58424-228">Those setters are used in with-expressions.</span></span> <span data-ttu-id="58424-229">可为定义的任何 `class` 或 `struct` 声明仅限 init 的资源库。</span><span class="sxs-lookup"><span data-stu-id="58424-229">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="58424-230">顶级语句</span><span class="sxs-lookup"><span data-stu-id="58424-230">Top-level statements</span></span>

<span data-ttu-id="58424-231">顶级语句从许多应用程序中删除了不必要的流程。</span><span class="sxs-lookup"><span data-stu-id="58424-231">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="58424-232">请考虑规范的“Hello World!”</span><span class="sxs-lookup"><span data-stu-id="58424-232">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="58424-233">程序：</span><span class="sxs-lookup"><span data-stu-id="58424-233">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="58424-234">只有一行代码执行所有操作。</span><span class="sxs-lookup"><span data-stu-id="58424-234">There’s only one line of code that does anything.</span></span> <span data-ttu-id="58424-235">借助顶级语句，可使用 `using` 语句和执行操作的一行替换所有样本：</span><span class="sxs-lookup"><span data-stu-id="58424-235">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="58424-236">如果需要单行程序，可删除 `using` 指令，并使用完全限定的类型名称：</span><span class="sxs-lookup"><span data-stu-id="58424-236">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="58424-237">应用程序中只有一个文件可使用顶级语句。</span><span class="sxs-lookup"><span data-stu-id="58424-237">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="58424-238">如果编译器在多个源文件中找到顶级语句，则是错误的。</span><span class="sxs-lookup"><span data-stu-id="58424-238">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="58424-239">如果将顶级语句与声明的程序入口点方法（通常为 `Main` 方法）结合使用，也会出现错误。</span><span class="sxs-lookup"><span data-stu-id="58424-239">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="58424-240">从某种意义上讲，可认为一个文件包含通常位于 `Program` 类的 `Main` 方法中的语句。</span><span class="sxs-lookup"><span data-stu-id="58424-240">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="58424-241">此功能最常见的用途之一是创建材料。</span><span class="sxs-lookup"><span data-stu-id="58424-241">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="58424-242">C# 初级开发人员可以用一两行代码</span><span class="sxs-lookup"><span data-stu-id="58424-242">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="58424-243">编写规范的“Hello World!”。</span><span class="sxs-lookup"><span data-stu-id="58424-243">in one or two lines of code.</span></span> <span data-ttu-id="58424-244">不需要额外的工作。</span><span class="sxs-lookup"><span data-stu-id="58424-244">None of the extra ceremony is needed.</span></span> <span data-ttu-id="58424-245">不过，经验丰富的开发人员还会发现此功能的许多用途。</span><span class="sxs-lookup"><span data-stu-id="58424-245">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="58424-246">顶级语句可提供类似脚本的试验体验，这与 Jupyter 笔记本提供的很类似。</span><span class="sxs-lookup"><span data-stu-id="58424-246">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="58424-247">顶级语句非常适合小型控制台程序和实用程序。</span><span class="sxs-lookup"><span data-stu-id="58424-247">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="58424-248">Azure Functions 是顶级语句的理想用例。</span><span class="sxs-lookup"><span data-stu-id="58424-248">Azure Functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="58424-249">最重要的是，顶层语句不会限制应用程序的范围或复杂程度。</span><span class="sxs-lookup"><span data-stu-id="58424-249">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="58424-250">这些语句可访问或使用任何 .NET 类。</span><span class="sxs-lookup"><span data-stu-id="58424-250">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="58424-251">它们也不会限制你对命令行参数或返回值的使用。</span><span class="sxs-lookup"><span data-stu-id="58424-251">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="58424-252">顶级语句可访问名为 args 的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="58424-252">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="58424-253">如果顶级语句返回整数值，则该值将成为来自合成 `Main` 方法的整数返回代码。</span><span class="sxs-lookup"><span data-stu-id="58424-253">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="58424-254">顶级语句可能包含异步表达式。</span><span class="sxs-lookup"><span data-stu-id="58424-254">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="58424-255">在这种情况下，合成入口点将返回 `Task` 或 `Task<int>`。</span><span class="sxs-lookup"><span data-stu-id="58424-255">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="58424-256">模式匹配增强功能</span><span class="sxs-lookup"><span data-stu-id="58424-256">Pattern matching enhancements</span></span>

<span data-ttu-id="58424-257">C# 9 包括新的模式匹配改进：</span><span class="sxs-lookup"><span data-stu-id="58424-257">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="58424-258">类型模式要求在变量是一种类型时匹配</span><span class="sxs-lookup"><span data-stu-id="58424-258">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="58424-259">带圆括号的模式强制或强调模式组合的优先级</span><span class="sxs-lookup"><span data-stu-id="58424-259">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="58424-260">联合 `and` 模式要求两个模式都匹配</span><span class="sxs-lookup"><span data-stu-id="58424-260">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="58424-261">析取 `or` 模式要求任一模式匹配</span><span class="sxs-lookup"><span data-stu-id="58424-261">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="58424-262">求反 `not` 模式要求模式不匹配</span><span class="sxs-lookup"><span data-stu-id="58424-262">***Negated `not` patterns*** require that a pattern doesn’t match</span></span>
- <span data-ttu-id="58424-263">关系模式要求输入小于、大于、小于等于或大于等于给定常数。</span><span class="sxs-lookup"><span data-stu-id="58424-263">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="58424-264">这些模式丰富了模式的语法。</span><span class="sxs-lookup"><span data-stu-id="58424-264">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="58424-265">请考虑下列示例：</span><span class="sxs-lookup"><span data-stu-id="58424-265">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="58424-266">还可使用可选的括号来明确 `and` 的优先级高于 `or`：</span><span class="sxs-lookup"><span data-stu-id="58424-266">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="58424-267">最常见的用途之一是用于 NULL 检查的新语法：</span><span class="sxs-lookup"><span data-stu-id="58424-267">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="58424-268">这些模式中的任何一种都可在允许使用模式的任何上下文中使用：`is` 模式表达式、`switch` 表达式、嵌套模式以及 `switch` 语句的 `case` 标签的模式。</span><span class="sxs-lookup"><span data-stu-id="58424-268">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="58424-269">性能和互操作性</span><span class="sxs-lookup"><span data-stu-id="58424-269">Performance and interop</span></span>

<span data-ttu-id="58424-270">3 项新功能改进了对需要高性能的本机互操作性和低级别库的支持：本机大小的整数、函数指针和省略 `localsinit` 标志。</span><span class="sxs-lookup"><span data-stu-id="58424-270">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="58424-271">本机大小的整数 `nint` 和 `nuint` 是整数类型。</span><span class="sxs-lookup"><span data-stu-id="58424-271">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="58424-272">它们由基础类型 <xref:System.IntPtr?displayProperty=nameWithType> 和 <xref:System.UIntPtr?displayProperty=nameWithType> 表示。</span><span class="sxs-lookup"><span data-stu-id="58424-272">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58424-273">编译器将这些类型的其他转换和操作作为本机整数公开。</span><span class="sxs-lookup"><span data-stu-id="58424-273">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="58424-274">本机大小的整数定义 `MaxValue` 或 `MinValue` 的属性。</span><span class="sxs-lookup"><span data-stu-id="58424-274">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="58424-275">这些值不能表示为编译时编译时，因为它取决于目标计算机上整数的本机大小。</span><span class="sxs-lookup"><span data-stu-id="58424-275">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="58424-276">这些值在运行时是只读的。</span><span class="sxs-lookup"><span data-stu-id="58424-276">Those values are readonly at runtime.</span></span> <span data-ttu-id="58424-277">可在以下范围内对 `nint` 使用常量值：[`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="58424-277">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="58424-278">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="58424-278">`int.MaxValue`].</span></span> <span data-ttu-id="58424-279">可在以下范围内对 `nuint` 使用常量值：[`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="58424-279">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="58424-280">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="58424-280">`uint.MaxValue`].</span></span> <span data-ttu-id="58424-281">编译器使用 <xref:System.Int32?displayProperty=nameWithType> 和 <xref:System.UInt32?displayProperty=nameWithType> 类型为所有一元和二元运算符执行常量折叠。</span><span class="sxs-lookup"><span data-stu-id="58424-281">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="58424-282">如果结果不满足 32 位，操作将在运行时执行，且不会被视为常量。</span><span class="sxs-lookup"><span data-stu-id="58424-282">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="58424-283">在广泛使用整数数学且需要尽可能快的性能的情况下，本机大小的整数可提高性能。</span><span class="sxs-lookup"><span data-stu-id="58424-283">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="58424-284">函数指针提供了一种简单的语法来访问 IL 操作码 `ldftn` 和 `calli`。</span><span class="sxs-lookup"><span data-stu-id="58424-284">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="58424-285">可使用新的 `delegate*` 语法声明函数指针。</span><span class="sxs-lookup"><span data-stu-id="58424-285">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="58424-286">`delegate*` 类型是指针类型。</span><span class="sxs-lookup"><span data-stu-id="58424-286">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="58424-287">调用 `delegate*` 类型会使用 `calli`，而不是使用在 `Invoke()` 方法上采用 `callvirt` 的委托。</span><span class="sxs-lookup"><span data-stu-id="58424-287">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="58424-288">从语法上讲，调用是相同的。</span><span class="sxs-lookup"><span data-stu-id="58424-288">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="58424-289">函数指针调用使用 `managed` 调用约定。</span><span class="sxs-lookup"><span data-stu-id="58424-289">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="58424-290">在 `delegate*` 语法后面添加 `unmanaged` 关键字，以声明想要 `unmanaged` 调用约定。</span><span class="sxs-lookup"><span data-stu-id="58424-290">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="58424-291">可使用 `delegate*` 声明中的属性来指定其他调用约定。</span><span class="sxs-lookup"><span data-stu-id="58424-291">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="58424-292">最后，可添加 <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> 来指示编译器不要发出 `localsinit` 标志。</span><span class="sxs-lookup"><span data-stu-id="58424-292">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="58424-293">此标志指示 CLR 对所有局部变量进行零初始化。</span><span class="sxs-lookup"><span data-stu-id="58424-293">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="58424-294">从 1.0 开始，`localsinit` 标志一直是 C# 的默认行为。</span><span class="sxs-lookup"><span data-stu-id="58424-294">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="58424-295">但在某些情况下，额外的零初始化可能会对性能产生可衡量的影响，</span><span class="sxs-lookup"><span data-stu-id="58424-295">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="58424-296">特别是在使用 `stackalloc` 时。</span><span class="sxs-lookup"><span data-stu-id="58424-296">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="58424-297">在这些情况下，可添加 <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>。</span><span class="sxs-lookup"><span data-stu-id="58424-297">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="58424-298">可将它添加到单个方法或属性中，或者添加到 `class`、`struct`、`interface`，甚至是模块中。</span><span class="sxs-lookup"><span data-stu-id="58424-298">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="58424-299">此属性不会影响 `abstract` 方法，它会影响为实现生成的代码。</span><span class="sxs-lookup"><span data-stu-id="58424-299">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="58424-300">这些功能在某些情况下可提高性能。</span><span class="sxs-lookup"><span data-stu-id="58424-300">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="58424-301">仅应在采用前后对这些功能进行仔细的基准测试之后使用它们。</span><span class="sxs-lookup"><span data-stu-id="58424-301">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="58424-302">涉及本机大小整数的代码必须在使用不同整数大小的多个目标平台上进行测试。</span><span class="sxs-lookup"><span data-stu-id="58424-302">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="58424-303">其他功能需要不安全的代码。</span><span class="sxs-lookup"><span data-stu-id="58424-303">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="58424-304">调整和完成功能</span><span class="sxs-lookup"><span data-stu-id="58424-304">Fit and finish features</span></span>

<span data-ttu-id="58424-305">还有其他很多功能有助于更高效地编写代码。</span><span class="sxs-lookup"><span data-stu-id="58424-305">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="58424-306">在 C# 9.0 中，已知创建对象的类型时，可在 [`new`](../language-reference/operators/new-operator.md) 表达式中省略该类型。</span><span class="sxs-lookup"><span data-stu-id="58424-306">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="58424-307">最常见的用法是在字段声明中：</span><span class="sxs-lookup"><span data-stu-id="58424-307">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="58424-308">当需要创建新对象作为参数传递给方法时，也可使用目标类型 `new`。</span><span class="sxs-lookup"><span data-stu-id="58424-308">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="58424-309">请考虑使用以下签名的 `ForecastFor()` 方法：</span><span class="sxs-lookup"><span data-stu-id="58424-309">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="58424-310">可按如下所示调用该方法：</span><span class="sxs-lookup"><span data-stu-id="58424-310">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="58424-311">此功能还有一个不错的用途是，将其与仅限 init 的属性组合使用来初始化新对象：</span><span class="sxs-lookup"><span data-stu-id="58424-311">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="58424-312">可使用 `return new();` 语句返回由默认构造函数创建的实例。</span><span class="sxs-lookup"><span data-stu-id="58424-312">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="58424-313">类似的功能可改进[条件表达式](../language-reference/operators/conditional-operator.md)的目标类型解析。</span><span class="sxs-lookup"><span data-stu-id="58424-313">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="58424-314">进行此更改后，两个表达式无需从一个隐式转换到另一个，而是都可隐式转换为目标类型。</span><span class="sxs-lookup"><span data-stu-id="58424-314">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="58424-315">你可能不会注意到此更改。</span><span class="sxs-lookup"><span data-stu-id="58424-315">You likely won’t notice this change.</span></span> <span data-ttu-id="58424-316">你会注意到，某些以前需要强制转换或无法编译的条件表达式现在可以正常工作。</span><span class="sxs-lookup"><span data-stu-id="58424-316">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="58424-317">从 C# 9.0 开始，可将 `static` 修饰符添加到 [Lambda 表达式](../language-reference/operators/lambda-expressions.md)或[匿名方法](../language-reference/operators/delegate-operator.md)。</span><span class="sxs-lookup"><span data-stu-id="58424-317">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="58424-318">静态 Lambda 表达式类似于 `static` 局部函数：静态 Lambda 或匿名方法无法捕获局部变量或实例状态。</span><span class="sxs-lookup"><span data-stu-id="58424-318">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="58424-319">`static` 修饰符可防止意外捕获其他变量。</span><span class="sxs-lookup"><span data-stu-id="58424-319">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="58424-320">协变返回类型为[重写](../language-reference/keywords/override.md)方法的返回类型提供了灵活性。</span><span class="sxs-lookup"><span data-stu-id="58424-320">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="58424-321">重写方法可返回从重写基方法的返回类型派生的类型。</span><span class="sxs-lookup"><span data-stu-id="58424-321">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="58424-322">这对于记录和其他支持虚拟克隆或工厂方法的类型很有用。</span><span class="sxs-lookup"><span data-stu-id="58424-322">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="58424-323">此外，[`foreach` 循环](../language-reference/keywords/foreach-in.md)将识别并使用扩展方法 `GetEnumerator`，否则将满足 `foreach` 模式。</span><span class="sxs-lookup"><span data-stu-id="58424-323">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="58424-324">此更改意味着 `foreach` 与其他基于模式的构造（例如异步模式和基于模式的析构）一致。</span><span class="sxs-lookup"><span data-stu-id="58424-324">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="58424-325">实际上，此更改意味着可以为任何类型添加 `foreach` 支持。</span><span class="sxs-lookup"><span data-stu-id="58424-325">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="58424-326">在设计中，应将其限制为在枚举对象有意义时使用。</span><span class="sxs-lookup"><span data-stu-id="58424-326">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="58424-327">接下来，可使用弃元作为 Lambda 表达式的参数。</span><span class="sxs-lookup"><span data-stu-id="58424-327">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="58424-328">这样可免于为参数命名，并且编译器也可避免使用它。</span><span class="sxs-lookup"><span data-stu-id="58424-328">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="58424-329">可将 `_` 用于任何参数。</span><span class="sxs-lookup"><span data-stu-id="58424-329">You use the `_` for any argument.</span></span> <span data-ttu-id="58424-330">有关详细信息，请参阅 [Lambda 表达式](../language-reference/operators/lambda-expressions.md)一文中的 [Lambda 表达式的输入参数](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression)一节。</span><span class="sxs-lookup"><span data-stu-id="58424-330">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="58424-331">最后，现在可将属性应用于[本地函数](../programming-guide/classes-and-structs/local-functions.md)。</span><span class="sxs-lookup"><span data-stu-id="58424-331">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="58424-332">例如，可将[可为空的属性注释](../language-reference/attributes/nullable-analysis.md)应用于本地函数。</span><span class="sxs-lookup"><span data-stu-id="58424-332">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="58424-333">支持代码生成器</span><span class="sxs-lookup"><span data-stu-id="58424-333">Support for code generators</span></span>

<span data-ttu-id="58424-334">最后两项功能支持 C# 代码生成器。</span><span class="sxs-lookup"><span data-stu-id="58424-334">Two final features support C# code generators.</span></span> <span data-ttu-id="58424-335">C# 代码生成器是可编写的组件，类似于 roslyn 分析器或代码修补程序。</span><span class="sxs-lookup"><span data-stu-id="58424-335">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="58424-336">区别在于，代码生成器会在编译过程中分析代码并编写新的源代码文件。</span><span class="sxs-lookup"><span data-stu-id="58424-336">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="58424-337">典型的代码生成器会在代码中搜索属性或其他约定。</span><span class="sxs-lookup"><span data-stu-id="58424-337">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="58424-338">代码生成器使用 Roslyn 分析 API 读取属性或其他代码元素。</span><span class="sxs-lookup"><span data-stu-id="58424-338">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="58424-339">通过该信息，它将新代码添加到编译中。</span><span class="sxs-lookup"><span data-stu-id="58424-339">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="58424-340">源生成器只能添加代码，不能修改编译中的任何现有代码。</span><span class="sxs-lookup"><span data-stu-id="58424-340">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="58424-341">为代码生成器添加的两项功能是“分部方法语法”和“模块初始化表达式”的扩展。</span><span class="sxs-lookup"><span data-stu-id="58424-341">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*\*.</span></span> <span data-ttu-id="58424-342">首先是对分部方法的更改。</span><span class="sxs-lookup"><span data-stu-id="58424-342">First, the changes to partial methods.</span></span> <span data-ttu-id="58424-343">在 C# 9.0 之前，分部方法为 `private`，但不能指定访问修饰符、不能返回 `void`，也不能具有 `out` 参数。</span><span class="sxs-lookup"><span data-stu-id="58424-343">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="58424-344">这些限制意味着，如果未提供任何方法实现，编译器会删除对分部方法的所有调用。</span><span class="sxs-lookup"><span data-stu-id="58424-344">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="58424-345">C# 9.0 消除了这些限制，但要求分部方法声明必须具有实现。</span><span class="sxs-lookup"><span data-stu-id="58424-345">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="58424-346">代码生成器可提供这种实现。</span><span class="sxs-lookup"><span data-stu-id="58424-346">Code generators can provide that implementation.</span></span> <span data-ttu-id="58424-347">为了避免引入中断性变更，编译器会考虑没有访问修饰符的任何分部方法，以遵循旧规则。</span><span class="sxs-lookup"><span data-stu-id="58424-347">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="58424-348">如果分部方法包括 `private` 访问修饰符，则由新规则控制该分部方法。</span><span class="sxs-lookup"><span data-stu-id="58424-348">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="58424-349">代码生成器的第二项新功能是模块初始化表达式。</span><span class="sxs-lookup"><span data-stu-id="58424-349">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="58424-350">模块初始化表达式是附加了 <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> 属性的方法。</span><span class="sxs-lookup"><span data-stu-id="58424-350">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="58424-351">在整个模块中进行任何其他字段访问或方法调用之前，运行时将调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="58424-351">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="58424-352">模块初始化表达式方法：</span><span class="sxs-lookup"><span data-stu-id="58424-352">A module initializer method:</span></span>

- <span data-ttu-id="58424-353">必须是静态的</span><span class="sxs-lookup"><span data-stu-id="58424-353">Must be static</span></span>
- <span data-ttu-id="58424-354">必须没有参数</span><span class="sxs-lookup"><span data-stu-id="58424-354">Must be parameterless</span></span>
- <span data-ttu-id="58424-355">必须返回 void</span><span class="sxs-lookup"><span data-stu-id="58424-355">Must return void</span></span>
- <span data-ttu-id="58424-356">不能是泛型方法</span><span class="sxs-lookup"><span data-stu-id="58424-356">Must not be a generic method</span></span>
- <span data-ttu-id="58424-357">不能包含在泛型类中</span><span class="sxs-lookup"><span data-stu-id="58424-357">Must not be contained in a generic class</span></span>
- <span data-ttu-id="58424-358">必须能够从包含模块访问</span><span class="sxs-lookup"><span data-stu-id="58424-358">Must be accessible from the containing module</span></span>

<span data-ttu-id="58424-359">最后一个要点实际上意味着该方法及其包含类必须是内部的或公共的。</span><span class="sxs-lookup"><span data-stu-id="58424-359">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="58424-360">方法不能为本地函数。</span><span class="sxs-lookup"><span data-stu-id="58424-360">The method can't be a local function.</span></span>
