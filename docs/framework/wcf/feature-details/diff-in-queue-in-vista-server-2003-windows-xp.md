---
description: 了解详细信息： Windows Vista、Windows Server 2003 和 Windows XP 中的队列功能之间的差异
title: Windows Vista、Windows Server 2003 和 Windows XP 在排队功能方面的差异
ms.date: 03/30/2017
helpviewer_keywords:
- queues [WCF], differences in operating systems
ms.assetid: aa809d93-d0a3-4ae6-a726-d015cca37c04
ms.openlocfilehash: 6a6206b3033454528797f3c8f4276add9c35023d
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99756378"
---
# <a name="differences-in-queuing-features-in-windows-vista-windows-server-2003-and-windows-xp"></a><span data-ttu-id="a62e8-103">Windows Vista、Windows Server 2003 和 Windows XP 在排队功能方面的差异</span><span class="sxs-lookup"><span data-stu-id="a62e8-103">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>

<span data-ttu-id="a62e8-104">本主题概述了 Windows Vista、Windows Server 2003 和 Windows XP 之间 Windows Communication Foundation (WCF) 队列功能之间的差异。</span><span class="sxs-lookup"><span data-stu-id="a62e8-104">This topic summarizes the differences in the Windows Communication Foundation (WCF) queues feature between Windows Vista, Windows Server 2003, and Windows XP.</span></span>  
  
## <a name="application-specific-dead-letter-queue"></a><span data-ttu-id="a62e8-105">应用程序特定的死信队列</span><span class="sxs-lookup"><span data-stu-id="a62e8-105">Application-Specific Dead-Letter Queue</span></span>  

 <span data-ttu-id="a62e8-106">如果接收应用程序未及时读取排队消息，则这些消息可能会无限期保留在队列中。</span><span class="sxs-lookup"><span data-stu-id="a62e8-106">Queued messages can remain in the queue indefinitely if the receiving application does not read them in a timely fashion.</span></span> <span data-ttu-id="a62e8-107">如果消息的时效性较强则此行为是不适当的。</span><span class="sxs-lookup"><span data-stu-id="a62e8-107">This behavior is not advisable if the messages are time-sensitive.</span></span> <span data-ttu-id="a62e8-108">时效性较强的消息在排队绑定中设置了一个 `TimeToLive` 属性。</span><span class="sxs-lookup"><span data-stu-id="a62e8-108">Time-sensitive messages have a `TimeToLive` property set in the queued binding.</span></span> <span data-ttu-id="a62e8-109">此属性指示消息可以在队列中保留多久才会过期。</span><span class="sxs-lookup"><span data-stu-id="a62e8-109">This property indicates how long the messages can be in the queue before they expire.</span></span> <span data-ttu-id="a62e8-110">过期消息将发送到一个称为死信队列的特殊队列中。</span><span class="sxs-lookup"><span data-stu-id="a62e8-110">Expired messages are sent to a special queue called the dead-letter queue.</span></span> <span data-ttu-id="a62e8-111">消息也可能由于其他原因而在死信队列中终止，如超出队列配额或未通过身份验证。</span><span class="sxs-lookup"><span data-stu-id="a62e8-111">A message can also end up in a dead-letter queue for other reasons, such as exceeding a queue quota or experiencing an authentication failure.</span></span>  
  
 <span data-ttu-id="a62e8-112">通常，共享一个队列管理器的所有排队应用程序存在一个系统范围的死信队列。</span><span class="sxs-lookup"><span data-stu-id="a62e8-112">Typically, a single system-wide dead-letter queue exists for all queued applications that share a queue manager.</span></span> <span data-ttu-id="a62e8-113">使用每个应用程序的死信队列，共享一个队列管理器的各排队应用程序之间可以更好地隔离，方法是允许这些应用程序指定它们自己的应用程序特定的死信队列。</span><span class="sxs-lookup"><span data-stu-id="a62e8-113">A dead-letter queue for each application enables better isolation between queued applications that share a queue manager by allowing these applications to specify their own application-specific dead-letter queue.</span></span> <span data-ttu-id="a62e8-114">与其他应用程序共享一个死信队列的应用程序必须浏览该队列，以查找对其适用的消息。</span><span class="sxs-lookup"><span data-stu-id="a62e8-114">An application that shares a dead-letter queue with other applications has to browse the queue to find messages that are applicable to it.</span></span> <span data-ttu-id="a62e8-115">对于应用程序特定的死信队列，应用程序可以确保其死信队列中的所有消息都对其适用。</span><span class="sxs-lookup"><span data-stu-id="a62e8-115">With an application-specific dead-letter queue, the application can be assured that all messages in its dead-letter queue are applicable to it.</span></span>  
  
 <span data-ttu-id="a62e8-116">Windows Vista 提供特定于应用程序的死信队列。</span><span class="sxs-lookup"><span data-stu-id="a62e8-116">Windows Vista provides for application-specific dead-letter queues.</span></span> <span data-ttu-id="a62e8-117">应用程序特定的死信队列在 Windows Server 2003 和 Windows XP 中不可用，应用程序必须使用系统级死信队列。</span><span class="sxs-lookup"><span data-stu-id="a62e8-117">Application-specific dead-letter queues are not available in Windows Server 2003 and Windows XP, and applications must use the system-wide dead-letter queue.</span></span>  
  
## <a name="poison-message-handling"></a><span data-ttu-id="a62e8-118">病毒消息处理</span><span class="sxs-lookup"><span data-stu-id="a62e8-118">Poison-Message Handling</span></span>  

 <span data-ttu-id="a62e8-119">“病毒消息”是一类已超出向接收应用程序尝试进行传送的最大次数的消息。</span><span class="sxs-lookup"><span data-stu-id="a62e8-119">A poison message is a message that has exceeded the maximum number of delivery attempts to the receiving application.</span></span> <span data-ttu-id="a62e8-120">当从事务性队列中读取消息的应用程序因出错而无法立即处理消息时，可能会引出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a62e8-120">This situation can arise when an application that reads a message from a transactional queue cannot process the message immediately because of errors.</span></span> <span data-ttu-id="a62e8-121">如果应用程序中止从中接收排队消息的事务，则它会将该消息返回到队列。</span><span class="sxs-lookup"><span data-stu-id="a62e8-121">If the application aborts the transaction in which the queued message was received, it returns the message to the queue.</span></span> <span data-ttu-id="a62e8-122">然后，应用程序尝试在新的事务中再次检索该消息。</span><span class="sxs-lookup"><span data-stu-id="a62e8-122">The application then tries to retrieve the message again in a new transaction.</span></span> <span data-ttu-id="a62e8-123">如果引起错误的问题未得到纠正，则接收应用程序可能会停留在接收和中止同一条消息的循环中，直到超出最大传送尝试次数并生成病毒消息。</span><span class="sxs-lookup"><span data-stu-id="a62e8-123">If the problem that causes the error is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until it exceeds the maximum number of delivery attempts, and a poison message results.</span></span>  
  
 <span data-ttu-id="a62e8-124">Windows Vista、Windows Server 2003 和 Windows XP 上的消息队列 (MSMQ) 与病毒处理相关的主要区别包括：</span><span class="sxs-lookup"><span data-stu-id="a62e8-124">The key differences between Message Queuing (MSMQ) on Windows Vista, Windows Server 2003, and Windows XP that are relevant to poison handling include the following:</span></span>  
  
- <span data-ttu-id="a62e8-125">Windows Vista 中的 MSMQ 支持子队列，而 Windows Server 2003 和 Windows XP 不支持子队列。</span><span class="sxs-lookup"><span data-stu-id="a62e8-125">MSMQ in Windows Vista supports subqueues, while Windows Server 2003 and Windows XP do not support subqueues.</span></span> <span data-ttu-id="a62e8-126">子队列用于病毒消息处理。</span><span class="sxs-lookup"><span data-stu-id="a62e8-126">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="a62e8-127">重试队列和病毒队列是应用程序队列的子队列，是基于病毒消息处理设置创建的。</span><span class="sxs-lookup"><span data-stu-id="a62e8-127">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="a62e8-128">`MaxRetryCycles` 用于指示要创建的重试子队列的数量。</span><span class="sxs-lookup"><span data-stu-id="a62e8-128">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="a62e8-129">因此，在 Windows Server 2003 或 Windows XP 上运行时， `MaxRetryCycles` 将被忽略，并且 `ReceiveErrorHandling.Move` 不被允许。</span><span class="sxs-lookup"><span data-stu-id="a62e8-129">Therefore, when running on Windows Server 2003 or Windows XP, `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
- <span data-ttu-id="a62e8-130">Windows Vista 中的 MSMQ 支持否定确认，而 Windows Server 2003 和 Windows XP 则不支持。</span><span class="sxs-lookup"><span data-stu-id="a62e8-130">MSMQ in Windows Vista supports negative acknowledgment, while Windows Server 2003 and Windows XP do not.</span></span> <span data-ttu-id="a62e8-131">来自接收队列管理器的否定确认会致使发送队列管理器将被拒绝的消息放入死信队列。</span><span class="sxs-lookup"><span data-stu-id="a62e8-131">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="a62e8-132">同样， `ReceiveErrorHandling.Reject` Windows Server 2003 和 WINDOWS XP 不允许这样做。</span><span class="sxs-lookup"><span data-stu-id="a62e8-132">As such, `ReceiveErrorHandling.Reject` is not allowed with Windows Server 2003 and Windows XP.</span></span>  
  
- <span data-ttu-id="a62e8-133">Windows Vista 中的 MSMQ 支持消息属性，该属性保留尝试消息传递的次数。</span><span class="sxs-lookup"><span data-stu-id="a62e8-133">MSMQ in Windows Vista supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="a62e8-134">此中止计数属性在 Windows Server 2003 和 Windows XP 上不可用。</span><span class="sxs-lookup"><span data-stu-id="a62e8-134">This abort count property is not available on Windows Server 2003 and Windows XP.</span></span> <span data-ttu-id="a62e8-135">WCF 在内存中维护中止计数，因此当 Web 场中的多个 WCF 服务读取同一条消息时，此属性可能不会包含准确值。</span><span class="sxs-lookup"><span data-stu-id="a62e8-135">WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a Web farm.</span></span>  
  
## <a name="remote-transactional-read"></a><span data-ttu-id="a62e8-136">远程事务性读取</span><span class="sxs-lookup"><span data-stu-id="a62e8-136">Remote Transactional Read</span></span>  

 <span data-ttu-id="a62e8-137">Windows Vista 上的 MSMQ 支持远程事务读取。</span><span class="sxs-lookup"><span data-stu-id="a62e8-137">MSMQ on Windows Vista supports remote transactional reads.</span></span> <span data-ttu-id="a62e8-138">这允许从队列中进行读取的应用程序与该队列承载在不同的计算机上。</span><span class="sxs-lookup"><span data-stu-id="a62e8-138">This allows an application that is reading from a queue to be hosted on a computer that is different from the computer on which the queue is hosted.</span></span> <span data-ttu-id="a62e8-139">这样可以确保服务场能够从中心队列进行读取，从而增加系统的总体吞吐量。</span><span class="sxs-lookup"><span data-stu-id="a62e8-139">This ensures the ability to have a farm of services reading from a central queue, which increases the overall throughput of the system.</span></span> <span data-ttu-id="a62e8-140">另外，还可以确保在读取和处理消息时一旦出现故障，事务能够回滚并且消息保留在队列中以供以后处理。</span><span class="sxs-lookup"><span data-stu-id="a62e8-140">It also ensures that if a failure occurs when reading and processing the message, the transaction rolls back and the message remains in the queue for later processing.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a62e8-141">请参阅</span><span class="sxs-lookup"><span data-stu-id="a62e8-141">See also</span></span>

- [<span data-ttu-id="a62e8-142">使用死信队列处理消息传输故障</span><span class="sxs-lookup"><span data-stu-id="a62e8-142">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>](using-dead-letter-queues-to-handle-message-transfer-failures.md)
- [<span data-ttu-id="a62e8-143">病毒消息处理</span><span class="sxs-lookup"><span data-stu-id="a62e8-143">Poison Message Handling</span></span>](poison-message-handling.md)
