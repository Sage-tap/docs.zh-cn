---
title: CA3075：不安全的 DTD 处理（代码分析）
description: 了解代码分析规则 CA3075：不安全的 DTD 处理
ms.date: 03/18/2019
ms.topic: reference
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 9e48a4e7594b7f04c14510f509b46646786119db
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "99787625"
---
# <a name="ca3075-insecure-dtd-processing"></a><span data-ttu-id="a0b64-103">CA3075:不安全的 DTD 处理</span><span class="sxs-lookup"><span data-stu-id="a0b64-103">CA3075: Insecure DTD Processing</span></span>

| | <span data-ttu-id="a0b64-104">值</span><span class="sxs-lookup"><span data-stu-id="a0b64-104">Value</span></span> |
|-|-|
| <span data-ttu-id="a0b64-105">**规则 ID**</span><span class="sxs-lookup"><span data-stu-id="a0b64-105">**Rule ID**</span></span> |<span data-ttu-id="a0b64-106">CA3075</span><span class="sxs-lookup"><span data-stu-id="a0b64-106">CA3075</span></span>|
| <span data-ttu-id="a0b64-107">**类别**</span><span class="sxs-lookup"><span data-stu-id="a0b64-107">**Category**</span></span> |[<span data-ttu-id="a0b64-108">安全性</span><span class="sxs-lookup"><span data-stu-id="a0b64-108">Security</span></span>](security-warnings.md)|
| <span data-ttu-id="a0b64-109">修复是中断修复还是非中断修复</span><span class="sxs-lookup"><span data-stu-id="a0b64-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="a0b64-110">非中断</span><span class="sxs-lookup"><span data-stu-id="a0b64-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="a0b64-111">原因</span><span class="sxs-lookup"><span data-stu-id="a0b64-111">Cause</span></span>

<span data-ttu-id="a0b64-112">如果使用不安全的 <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 实例或引用外部实体源，分析器可能会接受不受信任的输入并将敏感信息泄露给攻击者。</span><span class="sxs-lookup"><span data-stu-id="a0b64-112">If you use insecure <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.</span></span>

## <a name="rule-description"></a><span data-ttu-id="a0b64-113">规则说明</span><span class="sxs-lookup"><span data-stu-id="a0b64-113">Rule description</span></span>

<span data-ttu-id="a0b64-114">XML 分析器可以通过两种方式确定文档有效性， *文档类型定义 (DTD)* 是其中一种（根据  [万维网联合会 (W3C) 可扩展标记语言 (XML) 1.0](https://www.w3.org/TR/2008/REC-xml-20081126/)的定义）。</span><span class="sxs-lookup"><span data-stu-id="a0b64-114">A *Document Type Definition (DTD)* is one of two ways an XML parser can determine the validity of a document, as defined by the  [World Wide Web Consortium (W3C) Extensible Markup Language (XML) 1.0](https://www.w3.org/TR/2008/REC-xml-20081126/).</span></span> <span data-ttu-id="a0b64-115">此规则会查找接受不受信任数据的属性和实例，以提醒开发人员潜在的[信息泄漏](../../../framework/wcf/feature-details/information-disclosure.md)威胁或[拒绝服务 (DoS)](../../../framework/wcf/feature-details/denial-of-service.md) 攻击。</span><span class="sxs-lookup"><span data-stu-id="a0b64-115">This rule seeks properties and instances where untrusted data is accepted to warn developers about potential [Information Disclosure](../../../framework/wcf/feature-details/information-disclosure.md) threats or [Denial of Service (DoS)](../../../framework/wcf/feature-details/denial-of-service.md) attacks.</span></span> <span data-ttu-id="a0b64-116">在以下情况下触发此规则：</span><span class="sxs-lookup"><span data-stu-id="a0b64-116">This rule triggers when:</span></span>

- <span data-ttu-id="a0b64-117">在 <xref:System.Xml.XmlReader> 实例上启用了 DtdProcessing，它使用 <xref:System.Xml.XmlUrlResolver>解析外部 XML 实体。</span><span class="sxs-lookup"><span data-stu-id="a0b64-117">DtdProcessing is enabled on the <xref:System.Xml.XmlReader> instance, which resolves external XML entities using <xref:System.Xml.XmlUrlResolver>.</span></span>

- <span data-ttu-id="a0b64-118">设置了 XML 中的 <xref:System.Xml.XmlNode.InnerXml%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0b64-118">The <xref:System.Xml.XmlNode.InnerXml%2A> property in the XML is set.</span></span>

- <span data-ttu-id="a0b64-119"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 属性设置为“分析”。</span><span class="sxs-lookup"><span data-stu-id="a0b64-119"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> property is set to Parse.</span></span>

- <span data-ttu-id="a0b64-120">使用 <xref:System.Xml.XmlResolver> 而不是 <xref:System.Xml.XmlSecureResolver> 处理不受信任的输入。</span><span class="sxs-lookup"><span data-stu-id="a0b64-120">Untrusted input is processed using <xref:System.Xml.XmlResolver> instead of <xref:System.Xml.XmlSecureResolver>.</span></span>

- <span data-ttu-id="a0b64-121">使用不安全的 <xref:System.Xml.XmlReaderSettings> 实例或根本不使用任何实例调用 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="a0b64-121">The <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> method is invoked with an insecure <xref:System.Xml.XmlReaderSettings> instance or no instance at all.</span></span>

- <span data-ttu-id="a0b64-122">使用不安全的默认设置或值创建 <xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="a0b64-122"><xref:System.Xml.XmlReader> is created with insecure default settings or values.</span></span>

<span data-ttu-id="a0b64-123">在这些情况下，结果均相同：来自文件系统或来自处理 XML 的计算机的网络共享的文件都将面临攻击，或 DTD 处理可用作 DoS 向量。</span><span class="sxs-lookup"><span data-stu-id="a0b64-123">In each of these cases, the outcome is the same: the contents from either the file system or network shares from the machine where the XML is processed will be exposed to the attacker, or DTD processing can be used as a DoS vector.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="a0b64-124">如何解决冲突</span><span class="sxs-lookup"><span data-stu-id="a0b64-124">How to fix violations</span></span>

- <span data-ttu-id="a0b64-125">正确捕获和处理所有 XmlTextReader 异常以避免路径信息泄露。</span><span class="sxs-lookup"><span data-stu-id="a0b64-125">Catch and process all XmlTextReader exceptions properly to avoid path information disclosure.</span></span>

- <span data-ttu-id="a0b64-126">使用 <xref:System.Xml.XmlSecureResolver> 来限制 XmlTextReader 可以访问的资源。</span><span class="sxs-lookup"><span data-stu-id="a0b64-126">Use the <xref:System.Xml.XmlSecureResolver> to restrict the resources that the XmlTextReader can access.</span></span>

- <span data-ttu-id="a0b64-127">通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlResolver> null **，不允许** 打开任何外部资源。</span><span class="sxs-lookup"><span data-stu-id="a0b64-127">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlResolver> property to **null**.</span></span>

- <span data-ttu-id="a0b64-128">确保从可信任的源赋值 <xref:System.Data.DataViewManager.DataViewSettingCollectionString%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0b64-128">Ensure that the <xref:System.Data.DataViewManager.DataViewSettingCollectionString%2A?displayProperty=nameWithType> property is assigned from a trusted source.</span></span>

### <a name="net-framework-35-and-earlier"></a><span data-ttu-id="a0b64-129">.NET Framework 3.5 及更早版本</span><span class="sxs-lookup"><span data-stu-id="a0b64-129">.NET Framework 3.5 and earlier</span></span>

- <span data-ttu-id="a0b64-130">如果正在处理不可信的源，请通过将 <xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A> 属性设置为“true”来禁用 DTD 处理。</span><span class="sxs-lookup"><span data-stu-id="a0b64-130">Disable DTD processing if you are dealing with untrusted sources by setting the <xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A> property to **true**.</span></span>

- <span data-ttu-id="a0b64-131">XmlTextReader 类具有完全信任继承要求。</span><span class="sxs-lookup"><span data-stu-id="a0b64-131">XmlTextReader class has a full trust inheritance demand.</span></span>

### <a name="net-framework-4-and-later"></a><span data-ttu-id="a0b64-132">.NET Framework 4 及更高版本</span><span class="sxs-lookup"><span data-stu-id="a0b64-132">.NET Framework 4 and later</span></span>

- <span data-ttu-id="a0b64-133">如果正在处理不可信的源，请通过将 <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> 属性设置为“禁止”或“忽略”来避免启用 DtdProcessing 。</span><span class="sxs-lookup"><span data-stu-id="a0b64-133">Avoid enabling DtdProcessing if you're dealing with untrusted sources by setting the <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> property to **Prohibit** or **Ignore**.</span></span>

- <span data-ttu-id="a0b64-134">确保在所有 InnerXml 用例中 load () 方法均采用 XmlReader 实例。</span><span class="sxs-lookup"><span data-stu-id="a0b64-134">Ensure that the Load() method takes an XmlReader instance in all InnerXml cases.</span></span>

> [!NOTE]
> <span data-ttu-id="a0b64-135">此规则可能会针对某些有效 XmlSecureResolver 实例进行误报。</span><span class="sxs-lookup"><span data-stu-id="a0b64-135">This rule might report false positives on some valid XmlSecureResolver instances.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="a0b64-136">何时禁止显示警告</span><span class="sxs-lookup"><span data-stu-id="a0b64-136">When to suppress warnings</span></span>

<span data-ttu-id="a0b64-137">除非确信已知道输入是来自受信任的源，否则请勿禁止显示此警告的规则。</span><span class="sxs-lookup"><span data-stu-id="a0b64-137">Unless you're sure that the input is known to be from a trusted source, do not suppress a rule from this warning.</span></span>

## <a name="pseudo-code-examples"></a><span data-ttu-id="a0b64-138">伪代码示例</span><span class="sxs-lookup"><span data-stu-id="a0b64-138">Pseudo-code examples</span></span>

### <a name="violation-1"></a><span data-ttu-id="a0b64-139">冲突 1</span><span class="sxs-lookup"><span data-stu-id="a0b64-139">Violation 1</span></span>

```csharp
using System.IO;
using System.Xml.Schema;

class TestClass
{
    public XmlSchema Test
    {
        get
        {
            var src = "";
            TextReader tr = new StreamReader(src);
            XmlSchema schema = XmlSchema.Read(tr, null); // warn
            return schema;
        }
    }
}
```

### <a name="solution-1"></a><span data-ttu-id="a0b64-140">解决方案 1</span><span class="sxs-lookup"><span data-stu-id="a0b64-140">Solution 1</span></span>

```csharp
using System.IO;
using System.Xml;
using System.Xml.Schema;

class TestClass
{
    public XmlSchema Test
    {
        get
        {
            var src = "";
            TextReader tr = new StreamReader(src);
            XmlReader reader = XmlReader.Create(tr, new XmlReaderSettings() { XmlResolver = null });
            XmlSchema schema = XmlSchema.Read(reader , null);
            return schema;
        }
    }
}
```

### <a name="violation-2"></a><span data-ttu-id="a0b64-141">冲突 2</span><span class="sxs-lookup"><span data-stu-id="a0b64-141">Violation 2</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public XmlReaderSettings settings = new XmlReaderSettings();
        public void TestMethod(string path)
        {
            var reader = XmlReader.Create(path, settings);  // warn
        }
    }
}
```

### <a name="solution-2"></a><span data-ttu-id="a0b64-142">解决方案 2</span><span class="sxs-lookup"><span data-stu-id="a0b64-142">Solution 2</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public XmlReaderSettings settings = new XmlReaderSettings()
        {
            DtdProcessing = DtdProcessing.Prohibit
        };

        public void TestMethod(string path)
        {
            var reader = XmlReader.Create(path, settings);
        }
    }
}
```

### <a name="violation-3"></a><span data-ttu-id="a0b64-143">冲突 3</span><span class="sxs-lookup"><span data-stu-id="a0b64-143">Violation 3</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class DoNotUseSetInnerXml
    {
        public void TestMethod(string xml)
        {
            XmlDocument doc = new XmlDocument() { XmlResolver = null };
            doc.InnerXml = xml; // warn
        }
    }
}
```

```csharp
using System.Xml;

namespace TestNamespace
{
    public class DoNotUseLoadXml
    {
        public void TestMethod(string xml)
        {
            XmlDocument doc = new XmlDocument(){ XmlResolver = null };
            doc.LoadXml(xml); // warn
        }
    }
}
```

### <a name="solution-3"></a><span data-ttu-id="a0b64-144">解决方法 3</span><span class="sxs-lookup"><span data-stu-id="a0b64-144">Solution 3</span></span>

```csharp
using System.Xml;

public static void TestMethod(string xml)
{
    XmlDocument doc = new XmlDocument() { XmlResolver = null };
    System.IO.StringReader sreader = new System.IO.StringReader(xml);
    XmlReader reader = XmlReader.Create(sreader, new XmlReaderSettings() { XmlResolver = null });
    doc.Load(reader);
}
```

### <a name="violation-4"></a><span data-ttu-id="a0b64-145">冲突 4</span><span class="sxs-lookup"><span data-stu-id="a0b64-145">Violation 4</span></span>

```csharp
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace TestNamespace
{
    public class UseXmlReaderForDeserialize
    {
        public void TestMethod(Stream stream)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(UseXmlReaderForDeserialize));
            serializer.Deserialize(stream); // warn
        }
    }
}
```

### <a name="solution-4"></a><span data-ttu-id="a0b64-146">解决方法 4</span><span class="sxs-lookup"><span data-stu-id="a0b64-146">Solution 4</span></span>

```csharp
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace TestNamespace
{
    public class UseXmlReaderForDeserialize
    {
        public void TestMethod(Stream stream)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(UseXmlReaderForDeserialize));
            XmlReader reader = XmlReader.Create(stream, new XmlReaderSettings() { XmlResolver = null });
            serializer.Deserialize(reader );
        }
    }
}
```

### <a name="violation-5"></a><span data-ttu-id="a0b64-147">冲突 5</span><span class="sxs-lookup"><span data-stu-id="a0b64-147">Violation 5</span></span>

```csharp
using System.Xml;
using System.Xml.XPath;

namespace TestNamespace
{
    public class UseXmlReaderForXPathDocument
    {
        public void TestMethod(string path)
        {
            XPathDocument doc = new XPathDocument(path); // warn
        }
    }
}
```

### <a name="solution-5"></a><span data-ttu-id="a0b64-148">解决方案 5</span><span class="sxs-lookup"><span data-stu-id="a0b64-148">Solution 5</span></span>

```csharp
using System.Xml;
using System.Xml.XPath;

namespace TestNamespace
{
    public class UseXmlReaderForXPathDocument
    {
        public void TestMethod(string path)
        {
            XmlReader reader = XmlReader.Create(path, new XmlReaderSettings() { XmlResolver = null });
            XPathDocument doc = new XPathDocument(reader);
        }
    }
}
```

### <a name="violation-6"></a><span data-ttu-id="a0b64-149">冲突 6</span><span class="sxs-lookup"><span data-stu-id="a0b64-149">Violation 6</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    class TestClass
    {
        public XmlDocument doc = new XmlDocument() { XmlResolver = new XmlUrlResolver() };
    }
}
```

### <a name="solution-6"></a><span data-ttu-id="a0b64-150">解决方案 6</span><span class="sxs-lookup"><span data-stu-id="a0b64-150">Solution 6</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    class TestClass
    {
        public XmlDocument doc = new XmlDocument() { XmlResolver = null }; // or set to a XmlSecureResolver instance
    }
}
```

### <a name="violation-7"></a><span data-ttu-id="a0b64-151">冲突 7</span><span class="sxs-lookup"><span data-stu-id="a0b64-151">Violation 7</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    class TestClass
    {
        private static void TestMethod()
        {
            var reader = XmlTextReader.Create(""doc.xml""); //warn
        }
    }
}
```

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public void TestMethod(string path)
        {
            try {
                XmlTextReader reader = new XmlTextReader(path); // warn
            }
            catch { throw ; }
            finally {}
        }
    }
}
```

### <a name="solution-7"></a><span data-ttu-id="a0b64-152">解决方案 7</span><span class="sxs-lookup"><span data-stu-id="a0b64-152">Solution 7</span></span>

```csharp
using System.Xml;

namespace TestNamespace
{
    public class TestClass
    {
        public void TestMethod(string path)
        {
            XmlReaderSettings settings = new XmlReaderSettings() { XmlResolver = null };
            XmlReader reader = XmlReader.Create(path, settings);
        }
    }
}
```

> [!NOTE]
> <span data-ttu-id="a0b64-153">尽管建议使用 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 来创建 <xref:System.Xml.XmlReader> 实例，但是其行为与 <xref:System.Xml.XmlTextReader> 有所不同。</span><span class="sxs-lookup"><span data-stu-id="a0b64-153">Although <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> is the recommended way to create an <xref:System.Xml.XmlReader> instance, there are behavior differences from <xref:System.Xml.XmlTextReader>.</span></span> <span data-ttu-id="a0b64-154"><xref:System.Xml.XmlReader.Create%2A> 中的 <xref:System.Xml.XmlReader> 在 XML 值中将 `\r\n` 规范化为 `\n`，而 <xref:System.Xml.XmlTextReader> 保留 `\r\n` 序列。</span><span class="sxs-lookup"><span data-stu-id="a0b64-154">An <xref:System.Xml.XmlReader> from <xref:System.Xml.XmlReader.Create%2A> normalizes `\r\n` to `\n` in XML values, while <xref:System.Xml.XmlTextReader> preserves the `\r\n` sequence.</span></span>
