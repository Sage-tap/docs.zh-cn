---
title: 迁移到 ASP.NET Core 时的部署方案
description: 在从 ASP.NET 迁移到 ASP.NET Core 时可以使用的不同部署方法的概述，允许并行和分阶段迁移。
author: ardalis
ms.date: 11/13/2020
ms.openlocfilehash: 589acd8c66baacc3aef5833dfaa24e2dcc5c1ee5
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/04/2021
ms.locfileid: "102401084"
---
# <a name="deployment-scenarios-when-migrating-to-aspnet-core"></a><span data-ttu-id="0f5ef-103">迁移到 ASP.NET Core 时的部署方案</span><span class="sxs-lookup"><span data-stu-id="0f5ef-103">Deployment scenarios when migrating to ASP.NET Core</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="0f5ef-104">现有的 ASP.NET MVC 和 Web API 应用在 IIS 和 Windows 上运行。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-104">Existing ASP.NET MVC and Web API apps run on IIS and Windows.</span></span> <span data-ttu-id="0f5ef-105">当移植到 ASP.NET Core 时，大型应用可能需要分阶段或并行方法。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-105">Large apps may require a phased or side-by-side approach when porting to ASP.NET Core.</span></span> <span data-ttu-id="0f5ef-106">在前面的章节中，你了解了许多用于将大型 .NET Framework 应用迁移到几个阶段 ASP.NET Core 的策略。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-106">In previous chapters, you learned a number of strategies for migrating large .NET Framework apps to ASP.NET Core in phases.</span></span> <span data-ttu-id="0f5ef-107">在本章中，你将了解如何实现不同的部署方案，以便在迁移部分应用程序时需要在生产中维护原始应用程序。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-107">In this chapter, you will see how different deployment scenarios can be achieved when there is a need to maintain the original app in production while migrating portions of it.</span></span>

## <a name="split-a-large-web-app"></a><span data-ttu-id="0f5ef-108">拆分大型 web 应用</span><span class="sxs-lookup"><span data-stu-id="0f5ef-108">Split a large web app</span></span>

<span data-ttu-id="0f5ef-109">请考虑当前在单个网站上的 IIS 中承载的大型 web 应用的常见方案。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-109">Consider the common scenario of a large web app that currently is hosted on IIS in a single web site.</span></span> <span data-ttu-id="0f5ef-110">在大型应用程序中，功能分为不同的路由和/或目录。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-110">Within the large app, functionality is segmented into different routes and/or directories.</span></span> <span data-ttu-id="0f5ef-111">该应用程序是 MVC 视图和 API 终结点的混合。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-111">The app is a mix of MVC views and API endpoints.</span></span> <span data-ttu-id="0f5ef-112">MVC 路由包含许多不同的路径，这些路径基于功能，并使用标准路由模板从应用程序的根开始 `/{controller}/{action}/{id?}` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-112">The MVC routes include many different paths based on functionality and all start from the root of the app using the standard `/{controller}/{action}/{id?}` route template.</span></span> <span data-ttu-id="0f5ef-113">API 终结点遵循类似的模式，但均位于根下 `/api` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-113">The API endpoints follow a similar pattern, but are all under an `/api` root.</span></span>

<span data-ttu-id="0f5ef-114">假定迁移应用的任务已拆分，以便将 MVC 功能或 API 功能迁移到 ASP.NET Core 首先，如何使原始站点继续与运行其他位置的新 ASP.NET Core 应用进行无缝协作？</span><span class="sxs-lookup"><span data-stu-id="0f5ef-114">Assuming the task of porting the app is split such that either the MVC functionality or the API functionality is migrated to ASP.NET Core first, how would the original site continue to function seamlessly with the new ASP.NET Core app running somewhere else?</span></span> <span data-ttu-id="0f5ef-115">系统的用户应继续查看在迁移之前执行的相同 Url，除非确实需要更改它们。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-115">Users of the system should continue to see the same URLs they did prior to the migration, unless it's absolutely necessary to change them.</span></span>

<span data-ttu-id="0f5ef-116">幸运的是，IIS 是一种功能丰富的 web 服务器，它有一段时间的两项功能是其 [URL 重写模块和应用程序请求路由](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing)。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-116">Fortunately, IIS is a very feature-rich web server, and two features it has had for some time are its [URL Rewrite module and Application Request Routing](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing).</span></span> <span data-ttu-id="0f5ef-117">IIS 可以使用这些功能作为 [反向代理](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing)，将客户端请求路由到相应的后端 web 应用。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-117">Using these features, IIS can act as a [reverse proxy](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing), routing client requests to the appropriate back-end web app.</span></span> <span data-ttu-id="0f5ef-118">若要将 IIS 配置为反向代理，请选中 "应用程序请求路由" 功能中的 " **启用代理** " 复选框，然后添加 URL 重写规则，如下所示：</span><span class="sxs-lookup"><span data-stu-id="0f5ef-118">To configure IIS as a reverse proxy, check the **Enable proxy** checkbox in the Application Request Routing feature, then add a URL Rewrite rule like this one:</span></span>

```xml
<rule name="NetCoreProxy">
  <match url="(.*)> />
  <action type="Rewrite" url="http://servername/{R:1}" />
</rule>
```

<span data-ttu-id="0f5ef-119">作为反向代理，IIS 可以将与特定模式匹配的流量路由到完全独立的应用，这可能会在不同服务器上。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-119">As a reverse proxy, IIS can route traffic matching certain patterns to entirely separate apps, potentially on different servers.</span></span>

<span data-ttu-id="0f5ef-120">如果只使用 URL 重写模块 (或许与主机标头结合) ，则 IIS 可以轻松支持多个网站，每个网站可能运行不同版本的 .NET。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-120">Using just the URL Rewrite module (perhaps combined with host headers), IIS can easily support multiple web sites, each potentially running different versions of .NET.</span></span> <span data-ttu-id="0f5ef-121">大型 web 应用可能部署为单个网站的集合，每个网站都响应不同的 IP 地址和/或主机标头，或者作为单个网站，其中的一个或多个子应用程序响应某些 URL 路径， (甚至不需要 URL 重写) 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-121">A large web app might be deployed as a collection of individual sites, each responding to different IP addresses and/or host headers, or as a single web site with one or more sub-applications in it responding to certain URL paths (which doesn't even require URL Rewrite).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0f5ef-122">子域通常指域中前两个级别前面的部分。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-122">Subdomains typically refer to the portion of a domain preceding the top two levels.</span></span> <span data-ttu-id="0f5ef-123">例如，在域中 `api.contoso.com` ， `api` 是域的子域 `contoso.com` (它本身由 `contoso` 域名和 `.com` 顶级域或 TLD) 组成。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-123">For example, in the domain `api.contoso.com`, `api` is a subdomain of the `contoso.com` domain (which itself is composed of the `contoso` domain name and the `.com` top-level domain or TLD).</span></span> <span data-ttu-id="0f5ef-124">URL 路径引用跟在域名后面的 URL 部分（从开始） `/` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-124">URL paths refer to portion of the URL that follows the domain name, starting with a `/`.</span></span> <span data-ttu-id="0f5ef-125">URL `https://contoso.com/api` 的路径为 `/api` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-125">The URL `https://contoso.com/api` has a path of `/api`.</span></span>

<span data-ttu-id="0f5ef-126">使用相同或不同的子域 (和域) 承载单个应用有一些优点和缺点。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-126">There are pros and cons to using the same or different subdomains (and domains) to host a single app.</span></span> <span data-ttu-id="0f5ef-127">Cookie 和应用内 [通信等功能可能需要](/aspnet/core/security/cors) 更多配置才能在分布式应用程序中正常工作。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-127">Features like cookies and intra-app communication using mechanisms like [CORS](/aspnet/core/security/cors) may require more configuration to work properly in distributed apps.</span></span> <span data-ttu-id="0f5ef-128">但是，使用不同子域的应用可以更轻松地使用 DNS 将请求路由到完全不同的网络目标，因此可以更轻松地将其部署到多个不同的服务器 (虚拟或其他) ，而无需 IIS 作为反向代理。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-128">However, apps that use different subdomains can more easily use DNS to route requests to entirely different network destinations, and so can more easily be deployed to many different servers (virtual or otherwise) without the need for IIS to act as a reverse proxy.</span></span>

<span data-ttu-id="0f5ef-129">在上述示例中，假定将 API 终结点指定为要移植到 ASP.NET Core 的应用程序的第一部分。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-129">In the example described above, assume the API endpoints are designated as the first part of the app to be ported to ASP.NET Core.</span></span> <span data-ttu-id="0f5ef-130">在这种情况下，将在 IIS 中创建一个新的 ASP.NET Core 应用程序，并将其作为单独的 web *应用程序* 承载在现有的 ASP.NET *MVC 网站中。*</span><span class="sxs-lookup"><span data-stu-id="0f5ef-130">In this case, a new ASP.NET Core app is created and hosted in IIS as a separate web *application* within the existing ASP.NET MVC web *site*.</span></span> <span data-ttu-id="0f5ef-131">由于它将作为原始网站的子网站添加并命名为 *api*，因此默认路由应该不会再以开头 `api/` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-131">Since it will be added as a child of the original web site and will be named *api*, its default route should no longer begin with `api/`.</span></span> <span data-ttu-id="0f5ef-132">保留此项将导致其与窗体的 Url 匹配 `/api/api/endpoint` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-132">Keeping this would result in it matching URLs of the form `/api/api/endpoint`.</span></span>

<span data-ttu-id="0f5ef-133">图5-1 显示了 ASP.NET Core 2.1 *api* 应用如何作为现有 *DotNetMvcApp* 站点的一部分显示在 IIS 管理器中。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-133">Figure 5-1 shows how the ASP.NET Core 2.1 *api* app appears in IIS Manager as a part of the existing *DotNetMvcApp* site.</span></span>

![在 .NET Framework 站点内显示 api 应用的 IIS 管理器](./media/Figure5-1.png)

<span data-ttu-id="0f5ef-135">**图 5-1**。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-135">**Figure 5-1**.</span></span> <span data-ttu-id="0f5ef-136">在 IIS 中通过 .NET Core 应用 .NET Framework 站点。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-136">.NET Framework Site with .NET Core app in IIS.</span></span>

<span data-ttu-id="0f5ef-137">*DotNetMvcApp* 站点托管为在 .NET Framework 4.7.2 上运行的 MVC 5 应用。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-137">The *DotNetMvcApp* site is hosted as an MVC 5 app running on .NET Framework 4.7.2.</span></span> <span data-ttu-id="0f5ef-138">它在集成模式下配置了自己的 IIS 应用池，并运行了 .NET CLR 版本4.0.30319。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-138">It has its own IIS app pool configured in integrated mode and running .NET CLR version 4.0.30319.</span></span> <span data-ttu-id="0f5ef-139">*Api* 应用是在 .NET Framework 4.6.1 () 上运行的 ASP.NET Core 应用 `net461` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-139">The *api* app is an ASP.NET Core app running on .NET Framework 4.6.1 (`net461`).</span></span> <span data-ttu-id="0f5ef-140">它已作为新的 IIS 应用添加到 *DotNetMvcApp* ，并配置为使用其自己的应用程序池。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-140">It was added to the *DotNetMvcApp* as a new IIS app and configured to use its own Application Pool.</span></span> <span data-ttu-id="0f5ef-141">它的应用程序池也在集成模式下运行，但配置为 **不使用托管代码** 的 .net CLR 版本，因为它将使用 [ASP.NET Core 模块](/aspnet/core/host-and-deploy/aspnet-core-module?preserve-view=true&view=aspnetcore-2.1)来执行。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-141">Its Application Pool is also running in integrated mode but is configured with a .NET CLR version of **No Managed Code** since it will be executed using the [ASP.NET Core Module](/aspnet/core/host-and-deploy/aspnet-core-module?preserve-view=true&view=aspnetcore-2.1).</span></span> <span data-ttu-id="0f5ef-142">ASP.NET Core 应用程序的版本就是一个示例。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-142">The version of the ASP.NET Core app is just an example.</span></span> <span data-ttu-id="0f5ef-143">还可将其配置为在 .NET Core 3.1 或 .NET 5.0 上运行。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-143">It could also be configured to run on .NET Core 3.1 or .NET 5.0.</span></span> <span data-ttu-id="0f5ef-144">但此时，它无法再以 .NET Framework 库为目标 (请参阅 [选择正确的 .Net Core 版本](choose-net-core-version.md)) </span><span class="sxs-lookup"><span data-stu-id="0f5ef-144">Though at that point, it would no longer be able to target .NET Framework libraries (see [Choose the Right .NET Core Version](choose-net-core-version.md))</span></span>

<span data-ttu-id="0f5ef-145">以这种方式配置时，为正确路由 ASP.NET Core 应用的 Api 必须进行的唯一更改是将其默认路由模板从更改 `[Route("[api/controller]")]` 为 `[Route("[controller]")]` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-145">Configured in this manner, the only change that must be made in order for the ASP.NET Core app's APIs to be routed properly is to change its default route template from `[Route("[api/controller]")]` to `[Route("[controller]")]`.</span></span>

<span data-ttu-id="0f5ef-146">另外，ASP.NET Core 应用可以是 IIS 中的另一个顶级网站。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-146">Alternately the ASP.NET Core app can be another top-level web site in IIS.</span></span> <span data-ttu-id="0f5ef-147">在这种情况下，你可以将原始站点配置为使用重写规则 (使用 [URL 重写](https://www.iis.net/downloads/microsoft/url-rewrite)) ，如果路径以开头，则将重定向到另一个应用 `/api` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-147">In this case, you can configure the original site to use a rewrite rule (with [URL Rewrite](https://www.iis.net/downloads/microsoft/url-rewrite)) that will redirect to the other app if the path starts with `/api`.</span></span> <span data-ttu-id="0f5ef-148">ASP.NET Core 应用可以为其路由使用不同的主机标头，以便它不会与主应用发生冲突，但仍可使用基于根的路由对请求做出响应。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-148">The ASP.NET Core app can use a different host header for its route so that it doesn't conflict with the main app but can still respond to requests using root-based routes.</span></span>

<span data-ttu-id="0f5ef-149">例如，可以将图5-1 中使用的同一个 ASP.NET Core 应用部署到配置为 IIS 网站的另一个文件夹。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-149">As an example, the same ASP.NET Core app used in Figure 5-1 can be deployed to another folder configured as an IIS web site.</span></span> <span data-ttu-id="0f5ef-150">站点应使用配置的应用池，而 **不是托管代码**。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-150">The site should use an app pool configured just as before, with **No Managed Code**.</span></span> <span data-ttu-id="0f5ef-151">将其绑定配置为响应服务器上的唯一主机名，如 `api.contoso.com` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-151">Configure its bindings to respond to a unique host name on the server, such as `api.contoso.com`.</span></span> <span data-ttu-id="0f5ef-152">若要配置 URL 重写以重写请求匹配， `/api` 只需在 IIS 服务器上添加新的入站规则 (或单独的站点) 级别。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-152">To configure URL Rewrite to rewrite requests matching `/api` just add a new inbound rule at the IIS server (or individual site) level.</span></span> <span data-ttu-id="0f5ef-153">匹配模式 `^/api(.*)` 并指定的操作类型 `Rewrite` 和重写 URL `api.contoso.com/{R:1}` 。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-153">Match the pattern `^/api(.*)` and specify an Action type of `Rewrite` and a Rewrite URL of `api.contoso.com/{R:1}`.</span></span> <span data-ttu-id="0f5ef-154">`(.*)`在匹配模式和 `{R:1}` 重写 URL 中使用的组合将确保路径的其余部分与新的 url 一起使用。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-154">The combination of using `(.*)` in the matching pattern and `{R:1}` in the rewrite URL will ensure the rest of the path gets used with the new URL.</span></span> <span data-ttu-id="0f5ef-155">实现此目的后，同一个 IIS 服务器上的单独站点可以共存于运行不同版本的 .NET，但它们可以作为一个 web 应用显示到 Internet。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-155">With this in place, separate sites on the same IIS server can coexist running separate versions of .NET, but they can be made to appear to the Internet as one web app.</span></span> <span data-ttu-id="0f5ef-156">图5-2 显示了 IIS 中在单独的网站上配置的重写规则。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-156">Figure 5-2 shows the rewrite rule as configured in IIS with the separate web site.</span></span>

![显示 URL 重写规则的 IIS 管理器，用于将子文件夹请求路由到单独的网站](./media/Figure5-2.png)

<span data-ttu-id="0f5ef-158">**图 5-2**。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-158">**Figure 5-2**.</span></span> <span data-ttu-id="0f5ef-159">重写规则，将子文件夹请求重写到另一个网站。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-159">Rewrite rule to rewrite subfolder requests to another web site.</span></span>

<span data-ttu-id="0f5ef-160">如果你的应用需要在不同的网站或 IIS 内的应用之间进行单一登录，请参阅有关 [如何在 ASP.NET 应用中共享身份验证 cookie](/aspnet/core/host-and-deploy/iis/) 的文档，以获取有关支持此方案的详细说明。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-160">If your app requires single sign-on between different sites or apps within IIS, refer to the documentation on [how to share authentication cookies among ASP.NET apps](/aspnet/core/host-and-deploy/iis/) for detailed instructions on supporting this scenario.</span></span>

## <a name="summary"></a><span data-ttu-id="0f5ef-161">总结</span><span class="sxs-lookup"><span data-stu-id="0f5ef-161">Summary</span></span>

<span data-ttu-id="0f5ef-162">将大型应用程序从 .NET Framework 迁移到 ASP.NET Core 的常见方法是选择应用程序的各个部分逐个迁移。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-162">A common approach to porting large apps from .NET Framework to ASP.NET Core is to choose individual portions of the app to migrate one by one.</span></span> <span data-ttu-id="0f5ef-163">当应用程序的每个部分都处于移植状态时，整个应用程序将保持运行且可用，并且它的一些部分在其原始配置中运行，其他部分在某些版本的 .NET Core 上运行。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-163">As each piece of the app is ported, the entire app remains running and usable, with some parts of it running in its original configuration and other parts running on some version of .NET Core.</span></span> <span data-ttu-id="0f5ef-164">通过使用这种方法，可以以增量方式执行大规模的应用迁移。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-164">By following this approach, a large app migration can be performed incrementally.</span></span> <span data-ttu-id="0f5ef-165">此方法通过提供更多的反馈，并减少了测试所涉及的总面区，从而限制了风险。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-165">This approach results in limiting risk by providing more rapid feedback and reducing total surface area involved in testing.</span></span> <span data-ttu-id="0f5ef-166">它还允许更快地实现 .NET Core 的优点，例如性能增加。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-166">It also allows for more rapid realization of benefits of .NET Core, such as performance increases.</span></span> <span data-ttu-id="0f5ef-167">尽管不再需要在 IIS 上承载 ASP.NET Core 应用程序，但 IIS 仍是一个非常灵活且功能强大的 web 服务器，可将其配置为支持各种承载方案，这些方案涉及同一 IIS 实例上的 .NET Framework 和 ASP.NET Core 应用，甚至在不同服务器上承载。</span><span class="sxs-lookup"><span data-stu-id="0f5ef-167">Although ASP.NET Core apps are no longer required to be hosted on IIS, IIS remains a very flexible and powerful web server that can be configured to support a variety of hosting scenarios involving both .NET Framework and ASP.NET Core apps on the same IIS instance or even hosted on different servers.</span></span>

## <a name="references"></a><span data-ttu-id="0f5ef-168">参考</span><span class="sxs-lookup"><span data-stu-id="0f5ef-168">References</span></span>

- [<span data-ttu-id="0f5ef-169">使用 IIS 在 Windows 上托管 ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="0f5ef-169">Host ASP.NET Core on Windows with IIS</span></span>](/aspnet/core/host-and-deploy/iis/)
- [<span data-ttu-id="0f5ef-170">URL 重写模块和应用程序请求路由</span><span class="sxs-lookup"><span data-stu-id="0f5ef-170">URL Rewrite module and Application Request Routing</span></span>](/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing)
- [<span data-ttu-id="0f5ef-171">URL 重写</span><span class="sxs-lookup"><span data-stu-id="0f5ef-171">URL Rewrite</span></span>](https://www.iis.net/downloads/microsoft/url-rewrite)
- [<span data-ttu-id="0f5ef-172">ASP.NET Core 模块</span><span class="sxs-lookup"><span data-stu-id="0f5ef-172">ASP.NET Core Module</span></span>](/aspnet/core/host-and-deploy/aspnet-core-module?preserve-view=true&view=aspnetcore-2.1)
- [<span data-ttu-id="0f5ef-173">在 ASP.NET 应用中共享身份验证 cookie</span><span class="sxs-lookup"><span data-stu-id="0f5ef-173">Share authentication cookies among ASP.NET apps</span></span>](/aspnet/core/host-and-deploy/iis/)
- [<span data-ttu-id="0f5ef-174">本节中使用的示例</span><span class="sxs-lookup"><span data-stu-id="0f5ef-174">Samples used in this section</span></span>](https://github.com/ardalis/MigrateDotNetWithIIS)

>[!div class="step-by-step"]
><span data-ttu-id="0f5ef-175">[上一页](more-migration-scenarios.md)
>[下一页](summary.md)</span><span class="sxs-lookup"><span data-stu-id="0f5ef-175">[Previous](more-migration-scenarios.md)
[Next](summary.md)</span></span>
