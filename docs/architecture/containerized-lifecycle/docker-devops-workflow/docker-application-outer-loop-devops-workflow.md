---
title: Docker 应用程序的外部循环 DevOps 工作流步骤
description: 了解 DevOps 工作流的“外部循环”步骤
ms.date: 01/06/2021
ms.openlocfilehash: 8bca36d5aa0fef95d684a96a5c6017ec15956358
ms.sourcegitcommit: 5ce37699c2a51ed173171813be68ef7577b1aba5
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/23/2021
ms.locfileid: "104881089"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="92bbb-103">Docker 应用程序的外部循环 DevOps 工作流步骤</span><span class="sxs-lookup"><span data-stu-id="92bbb-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="92bbb-104">图 5-1 显示了包含 DevOps 外部循环工作流的步骤的端到端描述。</span><span class="sxs-lookup"><span data-stu-id="92bbb-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="92bbb-105">它显示了 DevOps 的“外部循环”。</span><span class="sxs-lookup"><span data-stu-id="92bbb-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="92bbb-106">将代码推送到存储库时，将启动 CI 管道，然后启动 CD 管道，在该管道中部署应用程序。</span><span class="sxs-lookup"><span data-stu-id="92bbb-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="92bbb-107">从已部署的应用程序中收集的指标将反馈到在其中发生“内部循环”的开发工作负载中，因此开发团队拥有实际数据来响应用户和业务需求。</span><span class="sxs-lookup"><span data-stu-id="92bbb-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![显示 DevOps 外部循环工作流的 6 个步骤的关系图。](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="92bbb-109">**图 5-1**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-109">**Figure 5-1**.</span></span> <span data-ttu-id="92bbb-110">使用 Microsoft 工具的 Docker 应用程序的 DevOps 外部循环工作流</span><span class="sxs-lookup"><span data-stu-id="92bbb-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="92bbb-111">现在，让我们更加详细地来研究这些步骤。</span><span class="sxs-lookup"><span data-stu-id="92bbb-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="92bbb-112">步骤 1：内部循环开发工作流</span><span class="sxs-lookup"><span data-stu-id="92bbb-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="92bbb-113">第 4 章详细介绍了此步骤，但概括来说，这是外部循环开始的地方，即开发人员将代码推送到源代码控制管理系统（如 Git）以启动 CI 管道操作的时刻。</span><span class="sxs-lookup"><span data-stu-id="92bbb-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="92bbb-114">步骤 2：使用 Azure DevOps Services 和 Git 进行源代码控制集成和管理</span><span class="sxs-lookup"><span data-stu-id="92bbb-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="92bbb-115">在此步骤中，你需要一个版本控制系统来收集来自团队中不同开发人员的所有代码的统一版本。</span><span class="sxs-lookup"><span data-stu-id="92bbb-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="92bbb-116">尽管源代码控制 (SCC) 和源代码管理对于大多数开发人员来说似乎是次要的，但在 DevOps 生命周期中创建 Docker 应用程序时，必须强调，不能从开发人员的计算机上直接将带有应用程序的 Docker 映像提交到全局 Docker 注册表（如 Azure 容器注册表或 Docker Hub）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="92bbb-117">相反，要发布和部署到生产环境中的 Docker 映像必须仅在基于源代码存储库（如 Git）集成到全局生成或 CI 管道的源代码上创建。</span><span class="sxs-lookup"><span data-stu-id="92bbb-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="92bbb-118">由开发人员生成的本地映像应仅供他们在自己的计算机中进行测试时使用。</span><span class="sxs-lookup"><span data-stu-id="92bbb-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="92bbb-119">这就是为什么从 SCC 代码激活 DevOps 管道至关重要的原因。</span><span class="sxs-lookup"><span data-stu-id="92bbb-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="92bbb-120">Azure DevOps Services 和 Team Foundation Server 支持 Git 和 Team Foundation 版本控制。</span><span class="sxs-lookup"><span data-stu-id="92bbb-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="92bbb-121">你可在它们之间进行选择，并将其用于端到端 Microsoft 体验。</span><span class="sxs-lookup"><span data-stu-id="92bbb-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="92bbb-122">但是，你还可以在外部存储库（如 GitHub、本地 Git 存储库或 Subversion）中管理代码，并且仍然能够连接到该存储库并获取代码作为 DevOps CI 管道的起点。</span><span class="sxs-lookup"><span data-stu-id="92bbb-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="92bbb-123">步骤 3：使用 Azure DevOps Services 和 Docker 生成、CI、集成和测试</span><span class="sxs-lookup"><span data-stu-id="92bbb-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="92bbb-124">CI 已成为新式软件测试和交付的标准。</span><span class="sxs-lookup"><span data-stu-id="92bbb-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="92bbb-125">Docker 解决方案在开发和运营团队之间保持着明确的关注点分离。</span><span class="sxs-lookup"><span data-stu-id="92bbb-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="92bbb-126">Docker 映像的不变性确保了在通过 CI 开发、测试的内容和在生产中运行的内容之间进行可重复部署。</span><span class="sxs-lookup"><span data-stu-id="92bbb-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="92bbb-127">跨开发人员便携式计算机和测试基础架构部署的 Docker 引擎使容器可以跨环境移植。</span><span class="sxs-lookup"><span data-stu-id="92bbb-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="92bbb-128">此时，在拥有提交了正确代码的版本控制系统后，需要“生成服务”来获取代码并运行全局生成和测试  。</span><span class="sxs-lookup"><span data-stu-id="92bbb-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="92bbb-129">此步骤（CI、构建、测试）的内部工作流关于 CI 管道的生成，该管道由代码存储库（Git 等）、生成服务器 (Azure DevOps Services)、Docker 引擎和 Docker 注册表组成。</span><span class="sxs-lookup"><span data-stu-id="92bbb-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="92bbb-130">可以使用 Azure DevOps Services 作为生成应用程序和设置 CI 管道的基础，并将生成的“项目”发布到“项目存储库”（这将在下一步中进行说明）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="92bbb-131">当使用 Docker 进行部署时，要部署的“最终项目”是其中嵌入了应用程序或服务的 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="92bbb-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="92bbb-132">这些映像被推送或发布到 Docker 注册表（一个如 Azure 容器注册表中的专用存储库，或者像 Docker Hub 注册表这样的公共存储库，通常用于官方基础映像）  。</span><span class="sxs-lookup"><span data-stu-id="92bbb-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="92bbb-133">下面是一个基本概念：CI 管道将通过到 Git 等的 SCC 存储库的提交来启动。</span><span class="sxs-lookup"><span data-stu-id="92bbb-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="92bbb-134">提交将导致 Azure DevOps Services 在 Docker 容器中运行生成作业，并在该作业成功完成后，将 Docker 映像推送到 Docker 注册表，如图 5-2 所示。</span><span class="sxs-lookup"><span data-stu-id="92bbb-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="92bbb-135">外部循环的第一部分涉及步骤 1 至 3，从代码、运行、调试和验证，到代码存储库，再一直到生成和测试 CI 步骤。</span><span class="sxs-lookup"><span data-stu-id="92bbb-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![显示 CI 工作流中所涉及的三个步骤的关系图。](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="92bbb-137">**图 5-2**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-137">**Figure 5-2**.</span></span> <span data-ttu-id="92bbb-138">CI 中涉及的步骤</span><span class="sxs-lookup"><span data-stu-id="92bbb-138">The steps involved in CI</span></span>

<span data-ttu-id="92bbb-139">以下是使用 Docker 和 Azure DevOps Services 的基本 CI 工作流步骤：</span><span class="sxs-lookup"><span data-stu-id="92bbb-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="92bbb-140">开发人员将提交推送到 SCC 存储库（Git/Azure DevOps Services、GitHub 等）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="92bbb-141">如果你使用的是 Azure DevOps Services 或 Git，则已内置 CI，这意味着它与在 Azure DevOps Services 中选择复选框一样简单。</span><span class="sxs-lookup"><span data-stu-id="92bbb-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="92bbb-142">如果使用外部 SCC（如 GitHub），则 `webhook` 将通知 Azure DevOps Services 更新或推送到 Git/GitHub。</span><span class="sxs-lookup"><span data-stu-id="92bbb-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="92bbb-143">Azure DevOps Services 拉取 SCC 存储库，包括描述映像的 Dockerfile，以及应用程序和测试代码。</span><span class="sxs-lookup"><span data-stu-id="92bbb-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="92bbb-144">Azure DevOps Services 生成 Docker 映像并使用生成号对其进行标记。</span><span class="sxs-lookup"><span data-stu-id="92bbb-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="92bbb-145">Azure DevOps Services 在配置的 Docker 主机中实例化 Docker 容器，并运行相应的测试。</span><span class="sxs-lookup"><span data-stu-id="92bbb-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="92bbb-146">如果测试成功，则首先将映像重新标记为有意义的名称，以便了解它是一个“幸运的生成”（类似于“/1.0.0”或任何其他标签），然后将其推送到 Docker 注册表（Docker Hub、Azure 容器注册表、DTR 等）</span><span class="sxs-lookup"><span data-stu-id="92bbb-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="92bbb-147">使用 Azure DevOps Services 和 Azure DevOps Services 的 Docker 扩展实现 CI 管道</span><span class="sxs-lookup"><span data-stu-id="92bbb-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="92bbb-148">Visual Studio Azure DevOps Services 包含可在 CI/CD 管道中使用的生成和发布模板，可以使用这些模板生成 Docker 映像、将 Docker 映像推送到经过身份验证的 Docker 注册表、运行 Docker 映像或运行 Docker CLI 提供的其他操作。</span><span class="sxs-lookup"><span data-stu-id="92bbb-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="92bbb-149">它还添加了 Docker Compose 任务，可使用该任务来生成、推送和运行多容器 Docker 应用程序，或者运行 Docker Compose CLI 提供的其他操作，如图 5-3 所示。</span><span class="sxs-lookup"><span data-stu-id="92bbb-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps 中 Docker CI 管道的屏幕截图。](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="92bbb-151">**图 5-3**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-151">**Figure 5-3**.</span></span> <span data-ttu-id="92bbb-152">Azure DevOps Services 中的 Docker CI 管道，包括生成和发布模板以及相关任务。</span><span class="sxs-lookup"><span data-stu-id="92bbb-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="92bbb-153">可以使用这些模板和任务构建 CI/CD 项目，以在 Azure Service Fabric、Azure Kubernetes 服务和类似产品/服务中生成/测试和部署。</span><span class="sxs-lookup"><span data-stu-id="92bbb-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="92bbb-154">通过这些 Visual Studio Team Services 任务、在 Azure 中预配的生成 Linux Docker 主机/VM 和首选 Docker 注册表（Azure 容器注册表、Docker Hub、专用 Docker DTR 或任何其他 Docker 注册表），你可以非常一致的方式来组装 Docker CI 管道。</span><span class="sxs-lookup"><span data-stu-id="92bbb-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="92bbb-155">***要求：***</span><span class="sxs-lookup"><span data-stu-id="92bbb-155">***Requirements:***</span></span>

- <span data-ttu-id="92bbb-156">Azure DevOps Services，或用于本地安装的 Team Foundation Server 2015 Update 3 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="92bbb-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="92bbb-157">具有 Docker 二进制文件的 Azure DevOps Services 代理。</span><span class="sxs-lookup"><span data-stu-id="92bbb-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="92bbb-158">创建其中某个代理的简单方法是使用 Docker 运行基于 Azure DevOps Services 代理 Docker 映像的容器。</span><span class="sxs-lookup"><span data-stu-id="92bbb-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!TIP]
> <span data-ttu-id="92bbb-159">要了解有关组装 Azure DevOps Services Docker CI 管道的详细信息和查看演练，请访问以下站点：</span><span class="sxs-lookup"><span data-stu-id="92bbb-159">To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="92bbb-160">将 Visual Studio Team Services（现在是 Azure DevOps Services）代理作为 Docker 容器运行：</span><span class="sxs-lookup"><span data-stu-id="92bbb-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="92bbb-161">使用 Azure DevOps Services 生成 .NET Linux Docker 映像：</span><span class="sxs-lookup"><span data-stu-id="92bbb-161">Building .NET Linux Docker images with Azure DevOps Services: \</span></span>
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="92bbb-162">使用 Docker 支持生成基于 Linux 的 Visual Studio Team Service 生成计算机：</span><span class="sxs-lookup"><span data-stu-id="92bbb-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <https://www.donovanbrown.com/post/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="92bbb-163">集成、测试和验证多容器 Docker 应用程序</span><span class="sxs-lookup"><span data-stu-id="92bbb-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="92bbb-164">通常，大多数 Docker 应用程序由多个容器而不是单个容器组成。</span><span class="sxs-lookup"><span data-stu-id="92bbb-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="92bbb-165">一个很好的示例就是每个微服务有一个容器的面向微服务的应用程序。</span><span class="sxs-lookup"><span data-stu-id="92bbb-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="92bbb-166">但是，即使没有严格遵循微服务方法模式，Docker 应用程序也可能由多个容器或服务组成。</span><span class="sxs-lookup"><span data-stu-id="92bbb-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="92bbb-167">因此，在 CI 管道中生成应用程序容器之后，还需要将应用程序与其在集成 Docker 主机中、甚至在容器分布的测试群集中的所有容器作为一个整体进行部署、集成和测试。</span><span class="sxs-lookup"><span data-stu-id="92bbb-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="92bbb-168">如果使用的是单个主机，则可以使用 Docker 命令（如 docker-compose）来生成和部署相关容器，以在单个 VM 中测试和验证 Docker 环境。</span><span class="sxs-lookup"><span data-stu-id="92bbb-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="92bbb-169">但是，如果你正在使用 DC/OS、Kubernetes 或 Docker Swarm 等业务流程协调程序群集，则需要通过不同的机制或业务流程协调程序部署容器，具体取决于所选择的群集/计划程序。</span><span class="sxs-lookup"><span data-stu-id="92bbb-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="92bbb-170">以下是可以针对 Docker 容器运行的几种类型的测试：</span><span class="sxs-lookup"><span data-stu-id="92bbb-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="92bbb-171">Docker 容器的单元测试</span><span class="sxs-lookup"><span data-stu-id="92bbb-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="92bbb-172">测试相互关联的应用程序或微服务组</span><span class="sxs-lookup"><span data-stu-id="92bbb-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="92bbb-173">在生产和“canary”发布中进行测试</span><span class="sxs-lookup"><span data-stu-id="92bbb-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="92bbb-174">重要的是，在运行集成和功能测试时，必须从容器外部运行这些测试。</span><span class="sxs-lookup"><span data-stu-id="92bbb-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="92bbb-175">测试不包含在你正在部署的容器中或者在其中运行，因为容器基于应与将要部署到生产中的映像完全相同的静态映像。</span><span class="sxs-lookup"><span data-stu-id="92bbb-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="92bbb-176">在测试更高级的方案（例如包含多个群集（测试群集、暂存群集和生产群集））时，一个实用选项是将映像发布到注册表，以便可以在不同群集中对其进行测试。</span><span class="sxs-lookup"><span data-stu-id="92bbb-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="92bbb-177">将自定义应用程序 Docker 映像推送到全局 Docker 注册表中</span><span class="sxs-lookup"><span data-stu-id="92bbb-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="92bbb-178">在对 Docker 映像进行测试和验证后，需要将它们标记并发布到 Docker 注册表中。</span><span class="sxs-lookup"><span data-stu-id="92bbb-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="92bbb-179">Docker 注册表是 Docker 应用程序生命周期中的一个关键部分，因为它是存储要部署到 QA 和生产环境中的自定义测试（也称为“幸运映像”）的中心位置。</span><span class="sxs-lookup"><span data-stu-id="92bbb-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="92bbb-180">与存储在 SCC 存储库（Git 等）中的应用程序代码是你的“事实来源”类似，Docker 注册表是要部署到 QA 或生产环境中的二进制应用程序或位的“事实来源”。</span><span class="sxs-lookup"><span data-stu-id="92bbb-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="92bbb-181">通常，你可能想要在 Azure 容器注册表中的专用存储库中或 Docker 受信注册表等本地注册表中，或在具有有限访问权限的公共云注册表（如 Docker Hub）中，保留自定义映像的专用存储库，虽然在最后一种情况下，如果代码不是开放源代码，则必须信任供应商的安全性。</span><span class="sxs-lookup"><span data-stu-id="92bbb-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="92bbb-182">不管怎样，所使用的方法都类似，并且基于 `docker push` 命令，如图 5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="92bbb-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![显示将自定义映像推送到容器注册表的关系图。](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="92bbb-184">**图 5-4**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-184">**Figure 5-4**.</span></span> <span data-ttu-id="92bbb-185">将自定义映像发布到 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="92bbb-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="92bbb-186">在步骤 3 中，对于生成集成和测试 (CI)，可以将生成的 Docker 映像发布到专用或公共注册表。</span><span class="sxs-lookup"><span data-stu-id="92bbb-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="92bbb-187">云供应商提供了多种 Docker 注册表产品/服务，如 Azure 容器注册表、Amazon Web Services 容器注册表、Google 容器注册表、Quay 注册表等。</span><span class="sxs-lookup"><span data-stu-id="92bbb-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="92bbb-188">使用 Docker 任务，可以将具有多个标记的 `docker-compose.yml` 文件定义的一组服务映像推送到经过身份验证的 Docker 注册表（如 Azure 容器注册表），如图 5-5 所示。</span><span class="sxs-lookup"><span data-stu-id="92bbb-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![显示将映像发布到注册表的步骤的屏幕截图。](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="92bbb-190">**图 5-5**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-190">**Figure 5-5**.</span></span> <span data-ttu-id="92bbb-191">使用 Azure DevOps Services 将自定义映像发布到 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="92bbb-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!TIP]
> <span data-ttu-id="92bbb-192">有关 Azure 容器注册表的详细信息，请参阅 <https://aka.ms/azurecontainerregistry>。</span><span class="sxs-lookup"><span data-stu-id="92bbb-192">For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="92bbb-193">步骤 4：CD、部署</span><span class="sxs-lookup"><span data-stu-id="92bbb-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="92bbb-194">Docker 映像的不变性确保了使用通过 CI 开发、测试的内容和在生产中运行的内容进行可重复部署。</span><span class="sxs-lookup"><span data-stu-id="92bbb-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="92bbb-195">在 Docker 注册表（专用或公共）中发布应用程序 Docker 映像之后，可以使用 Azure DevOps Services 管道任务或 Azure DevOps Services Release Management，将它们从 CD 管道部署到你可能具有的几个环境中（生产、QA、暂存等）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="92bbb-196">但是，此时它取决于正在部署的 Docker 应用程序类型。</span><span class="sxs-lookup"><span data-stu-id="92bbb-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="92bbb-197">部署简单的应用程序（例如包含几个容器或服务并部署到几个服务器或 VM 的整体式应用程序）（从组合和部署的角度来看）不同于部署更加复杂的应用程序（例如具有超大规模功能的面向微服务的应用程序）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="92bbb-198">以下部分将介绍这两种情况。</span><span class="sxs-lookup"><span data-stu-id="92bbb-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="92bbb-199">将组合的 Docker 应用程序部署到多个 Docker 环境</span><span class="sxs-lookup"><span data-stu-id="92bbb-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="92bbb-200">让我们首先来看一下不太复杂的情况：部署到单个环境或多个环境（QA、暂存和生产）中的简单 Docker 主机（VM 或服务器）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="92bbb-201">在此情况下，在内部，CD 管道可以使用 docker-compose（来自 Azure DevOps Services 部署任务）来部署 Docker 应用程序及其相关容器或服务集，如图 5-6 所示。</span><span class="sxs-lookup"><span data-stu-id="92bbb-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![显示部署到三个环境的 CD 部署步骤的示意图。](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="92bbb-203">**图 5-6**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-203">**Figure 5-6**.</span></span> <span data-ttu-id="92bbb-204">将应用程序容器部署到简单的 Docker 主机环境注册表</span><span class="sxs-lookup"><span data-stu-id="92bbb-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="92bbb-205">图 5-7 突出显示了如何通过单击“添加任务”对话框中的“Docker Compose”，通过 Azure DevOps Services 将生成 CI 连接到 QA/测试环境。</span><span class="sxs-lookup"><span data-stu-id="92bbb-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="92bbb-206">但是，在部署到暂存或生产环境时，通常会使用 Release Management 功能处理多个环境（如 QA、暂存和生产）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="92bbb-207">如果要部署到单个 Docker 主机，它将使用 Azure DevOps Services“Docker Compose”任务（在内部调用 `docker-compose up` 命令）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="92bbb-208">如果要部署到 Azure Kubernetes 服务 (AKS)，它将使用 Docker 部署任务，如以下部分所述。</span><span class="sxs-lookup"><span data-stu-id="92bbb-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![显示 Docker Compose 任务的“添加任务”对话框的屏幕截图。](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="92bbb-210">**图 5-7**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-210">**Figure 5-7**.</span></span> <span data-ttu-id="92bbb-211">在 Azure DevOps Services 管道中添加 Docker Compose 任务</span><span class="sxs-lookup"><span data-stu-id="92bbb-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="92bbb-212">在 Azure DevOps Services 中创建发布时，它会采用一组输入项目。</span><span class="sxs-lookup"><span data-stu-id="92bbb-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="92bbb-213">这些项目确定在发布生存期内在所有环境中都不可变。</span><span class="sxs-lookup"><span data-stu-id="92bbb-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="92bbb-214">引入容器时，输入项目会标识要部署的注册表中的映像。</span><span class="sxs-lookup"><span data-stu-id="92bbb-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="92bbb-215">根据这些映像的标识方式，无法保证它们在整个发布过程中保持不变，最明显的情况就是在从 `docker-compose` 文件引用 `myimage:latest` 时。</span><span class="sxs-lookup"><span data-stu-id="92bbb-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="92bbb-216">Azure DevOps Services 模板使你能够生成包含特定注册表映像摘要的生成项目，这些摘要可保证唯一标识相同映像二进制文件。</span><span class="sxs-lookup"><span data-stu-id="92bbb-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="92bbb-217">这些是你真正想要用作发布的输入的内容。</span><span class="sxs-lookup"><span data-stu-id="92bbb-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="92bbb-218">使用 Azure DevOps Services Release Management 管理到 Docker 环境的发布</span><span class="sxs-lookup"><span data-stu-id="92bbb-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="92bbb-219">通过 Azure DevOps Services 模板，可以生成新映像，将该映像发布到 Docker 注册表，在 Linux 或 Windows 主机上运行该映像，以及使用 `docker-compose` 等命令将多个容器部署为整个应用程序，所有这些都通过适用于多个环境的 Azure DevOps Services Release Management 功能实现，如图 5-8 所示。</span><span class="sxs-lookup"><span data-stu-id="92bbb-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![显示 Docker 撰写版配置的屏幕截图。](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="92bbb-221">**图 5-8**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-221">**Figure 5-8**.</span></span> <span data-ttu-id="92bbb-222">从 Azure DevOps Services Release Management 配置 Azure DevOps Services Docker Compose 任务</span><span class="sxs-lookup"><span data-stu-id="92bbb-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="92bbb-223">但是，请记住，图 5-6 中所示并于图 5-8 中实现的方案是一种简单方案（它部署到单个 Docker 主机和 VM，每个映像将有一个容器或实例），并且可能应仅用于开发或测试方案。</span><span class="sxs-lookup"><span data-stu-id="92bbb-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="92bbb-224">在大多数企业生产方案中，你可能想要通过跨多个节点、服务器和 VM 的负载均衡以及“智能故障转移”实现高可用性 (HA) 和易于管理的可伸缩性，以便在服务器或节点发生故障时，其服务和容器将移动到另一主机服务器或 VM。</span><span class="sxs-lookup"><span data-stu-id="92bbb-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="92bbb-225">此情况需要更高级的技术，例如容器群集、业务流程协调程序和计划程序。</span><span class="sxs-lookup"><span data-stu-id="92bbb-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="92bbb-226">因此，部署到这些群集的方法是处理下一部分中介绍的高级方案。</span><span class="sxs-lookup"><span data-stu-id="92bbb-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="92bbb-227">将 Docker 应用程序部署到 Docker 群集</span><span class="sxs-lookup"><span data-stu-id="92bbb-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="92bbb-228">分布式应用程序的本质需要也是分布式的计算资源。</span><span class="sxs-lookup"><span data-stu-id="92bbb-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="92bbb-229">要拥有生产规模功能，需要具有基于池资源提供高可伸缩性和高可用性的群集功能。</span><span class="sxs-lookup"><span data-stu-id="92bbb-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="92bbb-230">可从 CLI 工具或 Web UI 手动将容器部署到这些群集，但应保留这种手动工作，以发现部署测试或管理目的，例如横向扩展或监视。</span><span class="sxs-lookup"><span data-stu-id="92bbb-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="92bbb-231">从 CD（尤其是 Azure DevOps Services）的角度来看，可从 Azure DevOps Services Release Management 环境运行特制的部署任务，这些环境将容器化应用程序部署到容器服务中的分布式群集，如图 5-9 所示。</span><span class="sxs-lookup"><span data-stu-id="92bbb-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![显示部署到业务流程协调程序的 CD 部署步骤的示意图。](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="92bbb-233">**图 5-9**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-233">**Figure 5-9**.</span></span> <span data-ttu-id="92bbb-234">将分布式应用程序部署到容器服务</span><span class="sxs-lookup"><span data-stu-id="92bbb-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="92bbb-235">最初，当部署到特定群集或业务流程协调程序时，通常会为每个业务流程协调程序使用特定的部署脚本和机制（即 Kubernetes 和 Service Fabric 具有不同部署机制），而不是使用基于 `docker-compose.yml` 定义文件的简单易用的 `docker-compose` 工具。</span><span class="sxs-lookup"><span data-stu-id="92bbb-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="92bbb-236">但是，由于图 5-10 所示的 Azure DevOps Services Docker 部署任务，现在还可以通过使用熟悉的 `docker-compose.yml` 文件部署到受支持的业务流程协调程序，因为该工具会为你执行该“转换”（从 `docker-compose.yml` 文件转换为业务流程协调程序所需的格式）。</span><span class="sxs-lookup"><span data-stu-id="92bbb-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![显示“部署到 Kubernetes”任务的屏幕截图。](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="92bbb-238">**图 5-10**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-238">**Figure 5-10**.</span></span> <span data-ttu-id="92bbb-239">将“部署到 Kubernetes”任务添加到环境</span><span class="sxs-lookup"><span data-stu-id="92bbb-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="92bbb-240">图 5-11 演示了如何使用可用于配置的部分编辑“部署到 Kubernetes”任务。</span><span class="sxs-lookup"><span data-stu-id="92bbb-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="92bbb-241">此任务将检索要在群集中作为容器部署的即用型自定义 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="92bbb-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![显示“部署到 Kubernetes”任务配置的屏幕截图。](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="92bbb-243">**图 5-11**。</span><span class="sxs-lookup"><span data-stu-id="92bbb-243">**Figure 5-11**.</span></span> <span data-ttu-id="92bbb-244">部署到 ACS DC/OS 的 Docker 部署任务定义</span><span class="sxs-lookup"><span data-stu-id="92bbb-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [!TIP]
> <span data-ttu-id="92bbb-245">如需了解有关 Azure DevOps Services 和 Docker 的 CD 管道的更多信息，请访问 <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="92bbb-245">To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="92bbb-246">步骤 5：运行和管理</span><span class="sxs-lookup"><span data-stu-id="92bbb-246">Step 5: Run and manage</span></span>

<span data-ttu-id="92bbb-247">因为在企业生产级别运行和管理应用程序本身就是一个重要主题，并且由于操作类型和在该级别（IT 操作）工作的人员以及这一领域的广泛范围，整个下一章节将对其进行专门的介绍。</span><span class="sxs-lookup"><span data-stu-id="92bbb-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="92bbb-248">步骤 6：监视和诊断</span><span class="sxs-lookup"><span data-stu-id="92bbb-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="92bbb-249">下一章节还会将此主题作为 IT 在生产系统中执行的任务的一部分进行介绍；但是，务必要强调的是，在此步骤中获得的见解必须反馈给开发团队，以便不断改进应用程序。</span><span class="sxs-lookup"><span data-stu-id="92bbb-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="92bbb-250">从该角度来看，它也是 DevOps 的一部分，尽管任务和操作通常由 IT 执行。</span><span class="sxs-lookup"><span data-stu-id="92bbb-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="92bbb-251">只有 100% 在 DevOps 领域内进行监视和诊断时，开发团队才会针对测试或 beta 环境执行监视流程和分析。</span><span class="sxs-lookup"><span data-stu-id="92bbb-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="92bbb-252">这可以通过执行负载测试或监视 beta 或 QA 环境（其中 beta 测试人员正在尝试新版本）来完成。</span><span class="sxs-lookup"><span data-stu-id="92bbb-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="92bbb-253">[上一页](index.md)
>[下一页](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="92bbb-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
