---
description: 了解更多：有关数据的安全注意事项
title: 数据的安全考虑事项
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 6e0bf681ad8dd141ad030ef850c3e50c1d6e65c8
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99632615"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="0d14a-103">数据的安全考虑事项</span><span class="sxs-lookup"><span data-stu-id="0d14a-103">Security Considerations for Data</span></span>

<span data-ttu-id="0d14a-104">在处理 Windows Communication Foundation (WCF) 中的数据时，必须考虑许多威胁类别。</span><span class="sxs-lookup"><span data-stu-id="0d14a-104">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="0d14a-105">以下列表显示了与数据处理相关的最重要的威胁类。</span><span class="sxs-lookup"><span data-stu-id="0d14a-105">The following list shows the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="0d14a-106">WCF 提供了缓解这些威胁的工具。</span><span class="sxs-lookup"><span data-stu-id="0d14a-106">WCF provides tools to mitigate these threats.</span></span>

* <span data-ttu-id="0d14a-107">拒绝服务</span><span class="sxs-lookup"><span data-stu-id="0d14a-107">Denial of service</span></span>

  <span data-ttu-id="0d14a-108">当接收不受信任的数据时，这些数据可能导致非常耗时的计算，致使接收方访问数量过于巨大的各种资源，例如，内存、线程、可用连接或处理器周期。</span><span class="sxs-lookup"><span data-stu-id="0d14a-108">When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="0d14a-109">针对服务器的拒绝服务攻击可能导致它崩溃，从而无法处理来自其他合法客户端的消息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-109">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

* <span data-ttu-id="0d14a-110">恶意代码执行</span><span class="sxs-lookup"><span data-stu-id="0d14a-110">Malicious code execution</span></span>

  <span data-ttu-id="0d14a-111">传入的不受信任的数据会导致接收方运行它本不想运行的代码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-111">Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

* <span data-ttu-id="0d14a-112">信息泄露</span><span class="sxs-lookup"><span data-stu-id="0d14a-112">Information disclosure</span></span>

  <span data-ttu-id="0d14a-113">远程攻击方强制接收方以一种泄露它想要的更多信息的方式来响应它的请求。</span><span class="sxs-lookup"><span data-stu-id="0d14a-113">The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="0d14a-114">用户提供的代码和代码访问安全性</span><span class="sxs-lookup"><span data-stu-id="0d14a-114">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="0d14a-115">Windows Communication Foundation 中的多个位置 (WCF) 基础结构运行用户提供的代码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-115">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="0d14a-116">例如， <xref:System.Runtime.Serialization.DataContractSerializer> 序列化引擎可能调用用户提供的属性 `set` 访问器和 `get` 访问器。</span><span class="sxs-lookup"><span data-stu-id="0d14a-116">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="0d14a-117">WCF 信道基础结构还可以调入到用户提供的类的派生类 <xref:System.ServiceModel.Channels.Message> 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-117">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="0d14a-118">代码创作者应负责确保不存在任何安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="0d14a-118">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="0d14a-119">例如，如果您创建一个具有整数类型的数据成员属性的数据协定类型，并在 `set` 访问器实现中基于该属性值分配一个数组，则当恶意消息中包含该数据成员的一个极其庞大的值时，您可能会遭到拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-119">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="0d14a-120">通常，应当在用户提供的代码中避免任何基于传入数据或耗时处理的分配（尤其当耗时处理可以由少量的传入数据导致时）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-120">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="0d14a-121">当对用户提供的代码执行安全分析时，应确保同时考虑所有失败情况（即，引发异常的所有代码分支）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-121">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="0d14a-122">用户提供的代码的最终示例是每个操作的服务实现内部的代码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-122">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="0d14a-123">确保服务实现的安全是您的责任。</span><span class="sxs-lookup"><span data-stu-id="0d14a-123">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="0d14a-124">很容易意外创建可能导致拒绝服务漏洞的非安全操作实现。</span><span class="sxs-lookup"><span data-stu-id="0d14a-124">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="0d14a-125">例如这样一个操作：它接受一个字符串，并从数据库中返回名称以该字符串开头的客户列表。</span><span class="sxs-lookup"><span data-stu-id="0d14a-125">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="0d14a-126">如果您处理的是一个大型数据库，而所传递的字符串仅仅是一个字母，则您的代码可能会尝试创建一个大于所有可用内存的消息，从而导致整个服务失败</span><span class="sxs-lookup"><span data-stu-id="0d14a-126">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="0d14a-127"> (<xref:System.OutOfMemoryException> 在 .NET Framework 中是不可恢复的，并且总是会导致应用程序终止。 ) </span><span class="sxs-lookup"><span data-stu-id="0d14a-127">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="0d14a-128">您应当确保没有任何恶意代码插入各个扩展点。</span><span class="sxs-lookup"><span data-stu-id="0d14a-128">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="0d14a-129">在部分信任情况下运行时、处理部分受信任的程序集中的类型时或创建可由部分受信任的代码使用的组件时，这一点尤为重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-129">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="0d14a-130">有关更多信息，请参见后面一节中的“部分信任威胁”。</span><span class="sxs-lookup"><span data-stu-id="0d14a-130">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="0d14a-131">请注意，在部分信任情况下运行时，数据协定序列化基础结构仅支持数据协定编程模型的有限子集，例如，不支持使用 <xref:System.SerializableAttribute> 属性的私有数据成员或类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-131">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="0d14a-132">有关详细信息，请参阅 [部分信任](partial-trust.md)。</span><span class="sxs-lookup"><span data-stu-id="0d14a-132">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="0d14a-133">避免无意中的信息泄露</span><span class="sxs-lookup"><span data-stu-id="0d14a-133">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="0d14a-134">当在考虑到安全性的情况下设计可序列化类型时，信息泄露是一个可能需要考虑的问题。</span><span class="sxs-lookup"><span data-stu-id="0d14a-134">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="0d14a-135">请考虑以下几点：</span><span class="sxs-lookup"><span data-stu-id="0d14a-135">Consider the following points:</span></span>

- <span data-ttu-id="0d14a-136"><xref:System.Runtime.Serialization.DataContractSerializer> 编程模型允许在序列化期间，在类型或程序集的外部公开私有数据和内部数据。</span><span class="sxs-lookup"><span data-stu-id="0d14a-136">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="0d14a-137">此外，在导出架构的过程中也可以公开类型的形状。</span><span class="sxs-lookup"><span data-stu-id="0d14a-137">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="0d14a-138">请务必了解类型的序列化工程。</span><span class="sxs-lookup"><span data-stu-id="0d14a-138">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="0d14a-139">如果您不希望公开任何内容，应禁止对它进行序列化（例如，如果是数据协定，则不应用 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性即可实现此禁止）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-139">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="0d14a-140">请注意，同一类型可能有多个序列化工程，具体取决于使用的序列化程序。</span><span class="sxs-lookup"><span data-stu-id="0d14a-140">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="0d14a-141">同一类型可能存在这样的情况：与 <xref:System.Runtime.Serialization.DataContractSerializer> 一起使用时公开一组数据，而与 <xref:System.Xml.Serialization.XmlSerializer>一起使用时则公开另一组数据。</span><span class="sxs-lookup"><span data-stu-id="0d14a-141">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="0d14a-142">意外地使用错误的序列化程序可能导致信息泄露。</span><span class="sxs-lookup"><span data-stu-id="0d14a-142">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="0d14a-143">当在旧式的远程过程调用 (RPC)/编码模式下使用 <xref:System.Xml.Serialization.XmlSerializer> 时，可能意外地将发送方的对象图的形状公开给接收方。</span><span class="sxs-lookup"><span data-stu-id="0d14a-143">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="0d14a-144">防止拒绝服务攻击</span><span class="sxs-lookup"><span data-stu-id="0d14a-144">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="0d14a-145">配额</span><span class="sxs-lookup"><span data-stu-id="0d14a-145">Quotas</span></span>

<span data-ttu-id="0d14a-146">潜在的拒绝服务攻击导致接收方分配大量的内存。</span><span class="sxs-lookup"><span data-stu-id="0d14a-146">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="0d14a-147">虽然本节专门介绍因过大的消息而导致的内存消耗问题，但要提醒读者注意的是，还可能出现其他的攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-147">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="0d14a-148">例如，消息可能使用过长的处理时间。</span><span class="sxs-lookup"><span data-stu-id="0d14a-148">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="0d14a-149">通常使用配额来缓解拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-149">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="0d14a-150">当超过配额时，通常会引发 <xref:System.ServiceModel.QuotaExceededException> 异常。</span><span class="sxs-lookup"><span data-stu-id="0d14a-150">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="0d14a-151">如果没有配额，则恶意消息可能导致所有可用的内存都受到访问，从而产生 <xref:System.OutOfMemoryException> 异常，或者导致所有可用的堆栈都受到访问，从而产生 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="0d14a-151">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="0d14a-152">超过配额的情况是可恢复的；如果是在正在运行的服务中遇到此问题，则会丢弃当前正在处理的消息，服务继续运行并处理更多的消息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-152">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="0d14a-153">但是，内存不足和堆栈溢出方案在 .NET Framework 中的任何位置都是不可恢复的;如果此服务遇到此类异常，则该服务将终止。</span><span class="sxs-lookup"><span data-stu-id="0d14a-153">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="0d14a-154">WCF 中的配额不涉及任何预分配。</span><span class="sxs-lookup"><span data-stu-id="0d14a-154">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="0d14a-155">例如，如果 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 配额（在各个类中都可找到）设置为 128 KB，并不意味着会自动为每个消息分配 128 KB。</span><span class="sxs-lookup"><span data-stu-id="0d14a-155">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="0d14a-156">实际分配的量取决于实际的传入消息大小。</span><span class="sxs-lookup"><span data-stu-id="0d14a-156">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="0d14a-157">传输层有许多配额。</span><span class="sxs-lookup"><span data-stu-id="0d14a-157">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="0d14a-158">这些配额是由正在使用的特定传输通道（HTTP、TCP 等等）强制施加的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-158">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="0d14a-159">虽然本主题讨论其中的一些配额，但这些配额的详细介绍是在 [Transport Quotas](transport-quotas.md)中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-159">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="0d14a-160">哈希表漏洞</span><span class="sxs-lookup"><span data-stu-id="0d14a-160">Hashtable Vulnerability</span></span>

<span data-ttu-id="0d14a-161">当数据协定包含哈希表或集合时存在漏洞。</span><span class="sxs-lookup"><span data-stu-id="0d14a-161">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="0d14a-162">如果大量的值插入到哈希表，其中大量的这些值生成相同的哈希值，则会出现此问题。</span><span class="sxs-lookup"><span data-stu-id="0d14a-162">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="0d14a-163">这可用作 DOS 攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-163">This can be used as a DOS attack.</span></span>  <span data-ttu-id="0d14a-164">可以通过设置 MaxReceivedMessageSize 绑定配额来缓解此漏洞。</span><span class="sxs-lookup"><span data-stu-id="0d14a-164">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="0d14a-165">当设置此配额以避免此类攻击时，请务必小心。</span><span class="sxs-lookup"><span data-stu-id="0d14a-165">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="0d14a-166">此配额对 WCF 消息的大小设置一个上限。</span><span class="sxs-lookup"><span data-stu-id="0d14a-166">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="0d14a-167">此外，避免在数据协定中使用哈希表或集合。</span><span class="sxs-lookup"><span data-stu-id="0d14a-167">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="0d14a-168">在不使用流模式的情况下限制内存消耗</span><span class="sxs-lookup"><span data-stu-id="0d14a-168">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="0d14a-169">防止消息过大的安全模型取决于是否使用流模式。</span><span class="sxs-lookup"><span data-stu-id="0d14a-169">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="0d14a-170">在基本的非流模式的情况下，消息会缓冲到内存中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-170">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="0d14a-171">在这种情况下，使用 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 或系统提供的绑定的 <xref:System.ServiceModel.Channels.TransportBindingElement> 配额，可通过限制可访问的最大消息大小来防止消息过大。</span><span class="sxs-lookup"><span data-stu-id="0d14a-171">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="0d14a-172">请注意，服务可能同时处理多个消息，在这种情况下，所有这些消息都在内存中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-172">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="0d14a-173">使用遏制功能可缓解这种威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-173">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="0d14a-174">另外，请注意， `MaxReceivedMessageSize` 不对每个消息的内存消耗设置上限，但限制它不得超过一个常量系数。</span><span class="sxs-lookup"><span data-stu-id="0d14a-174">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="0d14a-175">例如，如果 `MaxReceivedMessageSize` 是 1 MB，那么当接收到一个 1 MB 的消息，之后又对它进行反序列化时，则需要额外的内存来存放反序列化的对象图，从而导致总内存消耗大大超过 1 MB。</span><span class="sxs-lookup"><span data-stu-id="0d14a-175">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="0d14a-176">为此，应避免创建无需过多传入数据即会导致消耗大量内存的可序列化类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-176">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="0d14a-177">例如，具有50可选数据成员字段和额外100私有字段的数据协定 "MyContract" 可使用 XML 构造 "" 实例化 \<MyContract/> 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-177">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="0d14a-178">此 XML 将导致为 150 个字段访问内存。</span><span class="sxs-lookup"><span data-stu-id="0d14a-178">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="0d14a-179">请注意数据成员默认情况下是可选的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-179">Note that data members are optional by default.</span></span> <span data-ttu-id="0d14a-180">当这样的类型是数组的一部分时，问题会变得更复杂。</span><span class="sxs-lookup"><span data-stu-id="0d14a-180">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="0d14a-181">仅仅`MaxReceivedMessageSize` 还不足以防止所有的拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-181">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="0d14a-182">例如，传入消息可能强制反序列化程序反序列化深度嵌套的对象图（一个对象包含另一个对象，而后者又包含另一个对象，依此类推）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-182">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="0d14a-183"><xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Xml.Serialization.XmlSerializer> 均以嵌套方式调用方法来反序列化此类对象图。</span><span class="sxs-lookup"><span data-stu-id="0d14a-183">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="0d14a-184">方法调用的深度嵌套可能导致不可恢复的 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="0d14a-184">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="0d14a-185">通过设置 <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> 配额来限制 XML 嵌套的级别（在本主题后面的“安全地使用 XML”一节中介绍），可以缓解这种威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-185">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="0d14a-186">当使用二进制 XML 编码时，将其他配额设置为 `MaxReceivedMessageSize` 尤为重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-186">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="0d14a-187">使用二进制编码有一点像压缩：传入消息中的一小组字节可表示大量的数据。</span><span class="sxs-lookup"><span data-stu-id="0d14a-187">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="0d14a-188">这样，即使消息不超过 `MaxReceivedMessageSize` 限制，其完全展开形式也可能占用多得多的内存。</span><span class="sxs-lookup"><span data-stu-id="0d14a-188">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="0d14a-189">要缓解 XML 特有的此类威胁，必须正确设置所有 XML 读取器配额，具体如本主题后面的“安全地使用 XML”一节所述。</span><span class="sxs-lookup"><span data-stu-id="0d14a-189">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="0d14a-190">在使用流模式的情况下限制内存消耗</span><span class="sxs-lookup"><span data-stu-id="0d14a-190">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="0d14a-191">当使用流模式时，您可能使用一个小的 `MaxReceivedMessageSize` 设置来防止拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-191">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="0d14a-192">但是，在流模式下可能出现更复杂的情况。</span><span class="sxs-lookup"><span data-stu-id="0d14a-192">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="0d14a-193">例如，文件上载服务接受大于所有可用内存的文件。</span><span class="sxs-lookup"><span data-stu-id="0d14a-193">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="0d14a-194">在这种情况下，应当将 `MaxReceivedMessageSize` 设置为一个非常大的值，此时预计的情况是：几乎不会有任何数据缓冲在内存中，并且消息将以流的形式直接传送到磁盘中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-194">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="0d14a-195">如果恶意消息可以通过某种方式强制 WCF 缓冲数据，而不是在这种情况下对其进行流式处理，则 `MaxReceivedMessageSize` 不再能阻止消息访问所有可用内存。</span><span class="sxs-lookup"><span data-stu-id="0d14a-195">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="0d14a-196">为了缓解这种威胁，限制缓冲的各种 WCF 数据处理组件上存在特定的配额设置。</span><span class="sxs-lookup"><span data-stu-id="0d14a-196">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="0d14a-197">其中最重要的一个设置是各个传输绑定元素和标准绑定的 `MaxBufferSize` 属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-197">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="0d14a-198">当采用流模式时，应当在考虑将为每个消息分配的最大内存量的情况下设置此配额。</span><span class="sxs-lookup"><span data-stu-id="0d14a-198">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="0d14a-199">与 `MaxReceivedMessageSize`一样，此设置也不对内存消耗施加一个绝对上限值，而只限定它不得超过某个常量系数。</span><span class="sxs-lookup"><span data-stu-id="0d14a-199">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="0d14a-200">此外，与 `MaxReceivedMessageSize`一样，也要注意同时处理多个消息的可能性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-200">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="0d14a-201">MaxBufferSize 详细信息</span><span class="sxs-lookup"><span data-stu-id="0d14a-201">MaxBufferSize Details</span></span>

<span data-ttu-id="0d14a-202">`MaxBufferSize`属性限制任何大容量缓冲 WCF 执行的工作。</span><span class="sxs-lookup"><span data-stu-id="0d14a-202">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="0d14a-203">例如，WCF 始终会缓冲 SOAP 标头和 SOAP 错误，并且在消息传输优化机制中找到的任何 MIME 部分均不处于自然读取顺序 (MTOM) 消息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-203">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="0d14a-204">此设置可限制所有这些情况下的缓冲量。</span><span class="sxs-lookup"><span data-stu-id="0d14a-204">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="0d14a-205">WCF 通过将 `MaxBufferSize` 值传递给可能会缓冲的各种组件来完成此工作。</span><span class="sxs-lookup"><span data-stu-id="0d14a-205">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="0d14a-206">例如， <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> 类的一些 <xref:System.ServiceModel.Channels.Message> 重载采用 `maxSizeOfHeaders` 参数。</span><span class="sxs-lookup"><span data-stu-id="0d14a-206">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="0d14a-207">WCF 将 `MaxBufferSize` 值传递给此参数以限制 SOAP 标头缓冲的量。</span><span class="sxs-lookup"><span data-stu-id="0d14a-207">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="0d14a-208">当直接使用 <xref:System.ServiceModel.Channels.Message> 类时，设置此参数非常重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-208">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="0d14a-209">通常，在使用采用配额参数的 WCF 中的组件时，必须了解这些参数的安全含义并正确地设置它们，这一点很重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-209">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="0d14a-210">MTOM 消息编码器也有一个 `MaxBufferSize` 设置。</span><span class="sxs-lookup"><span data-stu-id="0d14a-210">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="0d14a-211">当使用标准绑定时，它自动设置为传输层的 `MaxBufferSize` 值。</span><span class="sxs-lookup"><span data-stu-id="0d14a-211">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="0d14a-212">但是，当使用 MTOM 消息编码器绑定元素来构造一个自定义绑定时，在使用流模式的情况下应当将 `MaxBufferSize` 属性设置为一个安全值，这一点非常重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-212">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="0d14a-213">基于 XML 的流式攻击</span><span class="sxs-lookup"><span data-stu-id="0d14a-213">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="0d14a-214">`MaxBufferSize` 只需确保流式处理时，WCF 才能强制进入缓冲。</span><span class="sxs-lookup"><span data-stu-id="0d14a-214">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="0d14a-215">例如，WCF XML 读取器在开始读取新元素时，始终会缓冲整个 XML 元素开始标记。</span><span class="sxs-lookup"><span data-stu-id="0d14a-215">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="0d14a-216">这样做是为了正确处理命名空间和属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-216">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="0d14a-217">如果 `MaxReceivedMessageSize` 配置为一个很大的值（例如，为了启用直接到磁盘的大型文件流式传送方案），那么，当整个消息正文是一个大型的 XML 元素开始标记时，可能会构造恶意消息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-217">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="0d14a-218">尝试读取它会导致 <xref:System.OutOfMemoryException>。</span><span class="sxs-lookup"><span data-stu-id="0d14a-218">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="0d14a-219">这是许多可能的基于 XML 的拒绝服务攻击之一，可以使用 XML 读取器配额来缓解这些攻击，本主题后面的 "安全地使用 XML" 一节对此进行了讨论。</span><span class="sxs-lookup"><span data-stu-id="0d14a-219">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="0d14a-220">当使用流模式时，设置所有这些配额尤为重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-220">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="0d14a-221">混合流式和缓冲编程模型</span><span class="sxs-lookup"><span data-stu-id="0d14a-221">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="0d14a-222">许多可能的攻击都是因为在同一个服务中混合流式和非流式编程模型而引起的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-222">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="0d14a-223">假定存在一个具有两个操作的服务协定：一个操作采用一个 <xref:System.IO.Stream> ，另一个操作采用某个自定义类型的数组。</span><span class="sxs-lookup"><span data-stu-id="0d14a-223">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="0d14a-224">另外还假定 `MaxReceivedMessageSize` 设置为一个较大的值，以使第一个操作可以处理大型流。</span><span class="sxs-lookup"><span data-stu-id="0d14a-224">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="0d14a-225">遗憾的是，这意味着大型消息现在也可以发送给第二个操作，并且在调用该操作之前，反序列化程序将数据作为一个数组缓冲在内存中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-225">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="0d14a-226">这是潜在的拒绝服务攻击： `MaxBufferSize` 配额不限制反序列化程序所处理的消息正文的大小。</span><span class="sxs-lookup"><span data-stu-id="0d14a-226">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="0d14a-227">为此，应当避免在同一个协定中混合基于流的操作和非流式操作。</span><span class="sxs-lookup"><span data-stu-id="0d14a-227">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="0d14a-228">如果您确实需要混合两种编程模型，可以考虑以下预防措施：</span><span class="sxs-lookup"><span data-stu-id="0d14a-228">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="0d14a-229">将 <xref:System.Runtime.Serialization.IExtensibleDataObject> 的 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 属性设置为 <xref:System.ServiceModel.ServiceBehaviorAttribute> 以禁用 `true`功能。</span><span class="sxs-lookup"><span data-stu-id="0d14a-229">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="0d14a-230">这确保了只有作为协定一部分的成员才会反序列化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-230">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="0d14a-231">将 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> 的 <xref:System.Runtime.Serialization.DataContractSerializer> 属性设置为一个安全值。</span><span class="sxs-lookup"><span data-stu-id="0d14a-231">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="0d14a-232">此配额也可通过 <xref:System.ServiceModel.ServiceBehaviorAttribute> 属性或通过配置来进行设置。</span><span class="sxs-lookup"><span data-stu-id="0d14a-232">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="0d14a-233">此配额限制在一个反序列化段内可反序列化的对象数目。</span><span class="sxs-lookup"><span data-stu-id="0d14a-233">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="0d14a-234">通常，消息协定中的每个操作参数或消息正文部分都在一个段内反序列化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-234">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="0d14a-235">当反序列化数组时，每个数组项都计为一个单独的对象。</span><span class="sxs-lookup"><span data-stu-id="0d14a-235">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="0d14a-236">将所有的 XML 读取器配额设置为安全值。</span><span class="sxs-lookup"><span data-stu-id="0d14a-236">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="0d14a-237">注意 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>、 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>和 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> ，并避免在非流式操作中使用字符串。</span><span class="sxs-lookup"><span data-stu-id="0d14a-237">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="0d14a-238">检查已知类型列表，记住它们中的任何一个都可以随时实例化（请参见本主题后面的“防止加载意外类型”一节）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-238">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="0d14a-239">不要使用用于实现缓冲大量数据的 <xref:System.Xml.Serialization.IXmlSerializable> 接口的任何类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-239">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="0d14a-240">不要将这些类型添加到已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-240">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="0d14a-241">不要在协定中使用 <xref:System.Xml.XmlElement>、 <xref:System.Xml.XmlNode> 数组、 <xref:System.Byte> 数组或实现 <xref:System.Runtime.Serialization.ISerializable> 的类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-241">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="0d14a-242">不要在已知类型列表中使用 <xref:System.Xml.XmlElement>、 <xref:System.Xml.XmlNode> 数组、 <xref:System.Byte> 数组或实现 <xref:System.Runtime.Serialization.ISerializable> 的类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-242">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="0d14a-243">当非流式操作使用 <xref:System.Runtime.Serialization.DataContractSerializer>时，也可以采用前面的预防措施。</span><span class="sxs-lookup"><span data-stu-id="0d14a-243">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="0d14a-244">如果您使用的是 <xref:System.Xml.Serialization.XmlSerializer>，则切勿在同一服务中混合流式和非流式编程模型，因为它没有 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> 配额的保护。</span><span class="sxs-lookup"><span data-stu-id="0d14a-244">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="0d14a-245">慢速流式攻击</span><span class="sxs-lookup"><span data-stu-id="0d14a-245">Slow Stream Attacks</span></span>

<span data-ttu-id="0d14a-246">流式拒绝服务攻击类不涉及内存消耗。</span><span class="sxs-lookup"><span data-stu-id="0d14a-246">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="0d14a-247">此类攻击涉及数据的慢速发送方或接收方。</span><span class="sxs-lookup"><span data-stu-id="0d14a-247">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="0d14a-248">当等待发送或接收数据时，诸如线程和可用连接之类的资源将消耗殆尽。</span><span class="sxs-lookup"><span data-stu-id="0d14a-248">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="0d14a-249">恶意攻击或者慢速网络连接上的合法发送方/接收方均会导致这种情形的发生。</span><span class="sxs-lookup"><span data-stu-id="0d14a-249">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="0d14a-250">若要缓解这样的攻击，应正确设置传输超时时间。</span><span class="sxs-lookup"><span data-stu-id="0d14a-250">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="0d14a-251">有关详细信息，请参阅 [传输配额](transport-quotas.md)。</span><span class="sxs-lookup"><span data-stu-id="0d14a-251">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="0d14a-252">其次，在 `Read` `Write` WCF 中处理流时从不使用同步或操作。</span><span class="sxs-lookup"><span data-stu-id="0d14a-252">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="0d14a-253">安全地使用 XML</span><span class="sxs-lookup"><span data-stu-id="0d14a-253">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="0d14a-254">虽然本节是有关 XML 的内容，但是这些信息同样适用于 JavaScript 对象表示法 (JSON) 文档。</span><span class="sxs-lookup"><span data-stu-id="0d14a-254">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="0d14a-255">使用 [Mapping Between JSON and XML](mapping-between-json-and-xml.md)时，配额同样发挥作用。</span><span class="sxs-lookup"><span data-stu-id="0d14a-255">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="0d14a-256">安全的 XML 读取器</span><span class="sxs-lookup"><span data-stu-id="0d14a-256">Secure XML Readers</span></span>

<span data-ttu-id="0d14a-257">XML 信息集构成 WCF 中所有消息处理的基础。</span><span class="sxs-lookup"><span data-stu-id="0d14a-257">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="0d14a-258">当接受来自不受信任源的 XML 数据时，可能存在许多必须缓解的拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-258">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="0d14a-259">WCF 提供了特殊的安全 XML 读取器。</span><span class="sxs-lookup"><span data-stu-id="0d14a-259">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="0d14a-260">在 WCF 中使用标准编码之一时，会自动创建这些读取器 (文本、二进制或 MTOM) 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-260">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="0d14a-261">这些读取器上的一些安全功能始终处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="0d14a-261">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="0d14a-262">例如，这些读取器从不处理文档类型定义 (DTD)，这些定义是拒绝服务攻击的潜在来源，绝不应出现在合法的 SOAP 消息中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-262">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="0d14a-263">其他安全功能包括必须配置的读取器配额，这些在下一节介绍。</span><span class="sxs-lookup"><span data-stu-id="0d14a-263">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="0d14a-264">当直接处理 XML 读取器时 (例如编写自己的自定义编码器时，或直接使用 <xref:System.ServiceModel.Channels.Message> 类) 时，在有可能使用不受信任的数据时，请始终使用 WCF 安全读取器。</span><span class="sxs-lookup"><span data-stu-id="0d14a-264">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="0d14a-265">通过在 <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>类上调用 <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>、 <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> 或 <xref:System.Xml.XmlDictionaryReader> 的静态工厂方法重载之一来创建安全读取器。</span><span class="sxs-lookup"><span data-stu-id="0d14a-265">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="0d14a-266">创建读取器时，应传入安全的配额值。</span><span class="sxs-lookup"><span data-stu-id="0d14a-266">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="0d14a-267">不要调用 `Create` 方法重载。</span><span class="sxs-lookup"><span data-stu-id="0d14a-267">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="0d14a-268">它们不会创建 WCF 读取器。</span><span class="sxs-lookup"><span data-stu-id="0d14a-268">These do not create a WCF reader.</span></span> <span data-ttu-id="0d14a-269">而是创建不受本节所介绍的安全功能保护的读取器。</span><span class="sxs-lookup"><span data-stu-id="0d14a-269">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="0d14a-270">读取器配额</span><span class="sxs-lookup"><span data-stu-id="0d14a-270">Reader Quotas</span></span>

<span data-ttu-id="0d14a-271">安全的 XML 读取器具有五个可配置的配额。</span><span class="sxs-lookup"><span data-stu-id="0d14a-271">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="0d14a-272">这些配额通常是使用编码绑定元素或标准绑定的 `ReaderQuotas` 属性配置的，或者是使用在创建读取器时传入的 <xref:System.Xml.XmlDictionaryReaderQuotas> 对象创建的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-272">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="0d14a-273">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="0d14a-273">MaxBytesPerRead</span></span>

<span data-ttu-id="0d14a-274">此配额限制当读取元素开始标记及其属性时在一次 `Read` 操作中读取的字节数</span><span class="sxs-lookup"><span data-stu-id="0d14a-274">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="0d14a-275">（在非流模式情况下，不会根据配额对元素名称本身进行计数。） <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> 非常重要：</span><span class="sxs-lookup"><span data-stu-id="0d14a-275">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="0d14a-276">当读取元素名称及其属性时，总是将它们缓冲在内存中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-276">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="0d14a-277">因此，在流模式下必须正确地设置此配额以防止在预计使用流模式时进行过度缓冲，这一点非常重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-277">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="0d14a-278">有关发生的实际缓冲量的信息，请参见下面的 `MaxDepth` 配额部分。</span><span class="sxs-lookup"><span data-stu-id="0d14a-278">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="0d14a-279">具有太多的 XML 特性可能会耗用过长的处理时间，因为必须检查特性名称的唯一性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-279">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="0d14a-280">`MaxBytesPerRead` 可缓解这一威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-280">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="0d14a-281">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="0d14a-281">MaxDepth</span></span>

<span data-ttu-id="0d14a-282">此配额限制 XML 元素的最大嵌套深度。</span><span class="sxs-lookup"><span data-stu-id="0d14a-282">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="0d14a-283">例如，文档 "" 的 \<A> \<B> \<C/> \</B> \</A> 嵌套深度为3。</span><span class="sxs-lookup"><span data-stu-id="0d14a-283">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="0d14a-284">由于以下原因，<xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> 非常重要：</span><span class="sxs-lookup"><span data-stu-id="0d14a-284"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="0d14a-285">`MaxDepth` 与 `MaxBytesPerRead`交互：读取器始终在内存中保留当前元素以及它的所有上级的数据，因此读取器的最大内存消耗与这两个设置的积成比例。</span><span class="sxs-lookup"><span data-stu-id="0d14a-285">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="0d14a-286">当反序列化深度嵌套的对象图时，会迫使反序列化程序访问整个堆栈并引发一个不可恢复的 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="0d14a-286">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="0d14a-287">对于 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Xml.Serialization.XmlSerializer>，XML 嵌套和对象嵌套之间存在直接关联。</span><span class="sxs-lookup"><span data-stu-id="0d14a-287">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="0d14a-288">使用 `MaxDepth` 可缓解这一威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-288">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="0d14a-289">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="0d14a-289">MaxNameTableCharCount</span></span>

<span data-ttu-id="0d14a-290">此配额限制读取器的名称表 的大小。</span><span class="sxs-lookup"><span data-stu-id="0d14a-290">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="0d14a-291">名称表包含在处理 XML 文档时遇到的一些字符串（例如，命名空间和前缀）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-291">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="0d14a-292">因为这些字符串缓冲在内存中，所以设置此配额可防止在预计使用流模式时进行过度缓冲。</span><span class="sxs-lookup"><span data-stu-id="0d14a-292">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="0d14a-293">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="0d14a-293">MaxStringContentLength</span></span>

<span data-ttu-id="0d14a-294">此配额限制 XML 读取器返回的最大字符串大小。</span><span class="sxs-lookup"><span data-stu-id="0d14a-294">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="0d14a-295">此配额不限制 XML 读取器本身的内存消耗，但限制使用该读取器的组件中的内存消耗。</span><span class="sxs-lookup"><span data-stu-id="0d14a-295">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="0d14a-296">例如，当 <xref:System.Runtime.Serialization.DataContractSerializer> 使用一个以 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>保护的读取器时，将不会反序列化大于此配额的字符串。</span><span class="sxs-lookup"><span data-stu-id="0d14a-296">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="0d14a-297">当直接使用 <xref:System.Xml.XmlDictionaryReader> 类时，并不是所有的方法都将受此配额的约束，而只有专门设计用于读取字符串的方法（如 <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> 方法）才受此配额的约束。</span><span class="sxs-lookup"><span data-stu-id="0d14a-297">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="0d14a-298">读取器的 <xref:System.Xml.XmlReader.Value%2A> 属性不受此配额的影响，因此当需要此配额所提供的保护时，不应使用该属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-298">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="0d14a-299">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="0d14a-299">MaxArrayLength</span></span>

<span data-ttu-id="0d14a-300">此配额限制 XML 读取器返回的基元数组（包括字节数组）的最大大小。</span><span class="sxs-lookup"><span data-stu-id="0d14a-300">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="0d14a-301">此配额不限制 XML 读取器本身的内存消耗，但限制使用该读取器的所有组件的内存消耗。</span><span class="sxs-lookup"><span data-stu-id="0d14a-301">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="0d14a-302">例如，当 <xref:System.Runtime.Serialization.DataContractSerializer> 使用一个以 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>保护的读取器时，将不会反序列化大于此配额的字节数组。</span><span class="sxs-lookup"><span data-stu-id="0d14a-302">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="0d14a-303">当尝试在一个协定中混合流式编程模型和缓冲编程模型时，设置此配额非常重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-303">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="0d14a-304">请记住，当直接使用 <xref:System.Xml.XmlDictionaryReader> 类时，只有专门设计用于读取某些基元类型的任意大小数组的方法（如 <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>）才受此配额的约束。</span><span class="sxs-lookup"><span data-stu-id="0d14a-304">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="0d14a-305">二进制编码所特有的威胁</span><span class="sxs-lookup"><span data-stu-id="0d14a-305">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="0d14a-306">二进制 XML 编码 WCF 支持包含 *字典字符串* 功能。</span><span class="sxs-lookup"><span data-stu-id="0d14a-306">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="0d14a-307">可以仅仅使用几个字节对一个大型字符串进行编码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-307">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="0d14a-308">这会实现显著的性能改进，但也引入了必须缓解的新型拒绝服务威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-308">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="0d14a-309">有两种类型的字典： *静态* 字典和 *动态* 字典。</span><span class="sxs-lookup"><span data-stu-id="0d14a-309">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="0d14a-310">静态字典是可以使用二进制编码中的短代码表示的长字符串的内置列表。</span><span class="sxs-lookup"><span data-stu-id="0d14a-310">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="0d14a-311">当读取器已创建且无法修改时，这一字符串列表是固定的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-311">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="0d14a-312">默认情况下，WCF 使用的静态字典中的任何字符串都足以产生严重的拒绝服务威胁，但它们仍可能在字典扩展攻击中使用。</span><span class="sxs-lookup"><span data-stu-id="0d14a-312">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="0d14a-313">在您提供自己的静态字典的复杂情况下，在引入大型字典字符串时应谨慎。</span><span class="sxs-lookup"><span data-stu-id="0d14a-313">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="0d14a-314">动态字典功能使得消息可以定义它们自己的字符串，并将它们与短代码关联。</span><span class="sxs-lookup"><span data-stu-id="0d14a-314">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="0d14a-315">字符串与代码的这些映射在整个通信会话期间一直保留在内存中，这样后续消息就不必重新发送字符串，并且可以利用已经定义的代码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-315">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="0d14a-316">这些字符串可以是任意长度，因此造成了比静态字典中的字符串更严重的威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-316">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="0d14a-317">必须缓解的首要威胁是动态字典（字符串与代码映射表）变得过大的可能性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-317">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="0d14a-318">此类字典可以在几个消息的过程中展开，因此 `MaxReceivedMessageSize` 配额无法提供保护，因为该配额仅适用于各个单独的消息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-318">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="0d14a-319">因此，在 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> 上存在一个限制字典大小的单独的 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-319">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="0d14a-320">与其他大多数配额不同，此配额在编写消息时也适用。</span><span class="sxs-lookup"><span data-stu-id="0d14a-320">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="0d14a-321">如果在读取消息时超过此配额，将像通常一样引发 `QuotaExceededException` 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-321">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="0d14a-322">如果在编写消息时超过此配额，那么导致超过此配额的任何字符串都将按原样编写，而不使用动态字典功能。</span><span class="sxs-lookup"><span data-stu-id="0d14a-322">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="0d14a-323">字典展开威胁</span><span class="sxs-lookup"><span data-stu-id="0d14a-323">Dictionary Expansion Threats</span></span>

<span data-ttu-id="0d14a-324">二进制所特有的一类重要的攻击是因字典展开而引起的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-324">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="0d14a-325">一个小的二进制形式的消息如果大量使用了字符串字典功能，那么它的完全展开的文本形式可能是一个非常大的消息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-325">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="0d14a-326">动态字典字符串的展开系数受 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> 配额限制，因为不会有任何动态字典字符串超过整个字典的最大大小。</span><span class="sxs-lookup"><span data-stu-id="0d14a-326">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="0d14a-327"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>、 `MaxStringContentLength`和 `MaxArrayLength` 属性仅限制内存消耗。</span><span class="sxs-lookup"><span data-stu-id="0d14a-327">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="0d14a-328">在非流式使用模式下，通常不需要它们来缓解任何威胁，因为内存使用已受 `MaxReceivedMessageSize`限制。</span><span class="sxs-lookup"><span data-stu-id="0d14a-328">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="0d14a-329">但是， `MaxReceivedMessageSize` 计算的是展开前的字节数。</span><span class="sxs-lookup"><span data-stu-id="0d14a-329">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="0d14a-330">当使用的是二进制编码时，内存消耗可以超过 `MaxReceivedMessageSize`，而仅受 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>这一个因素的限制。</span><span class="sxs-lookup"><span data-stu-id="0d14a-330">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="0d14a-331">为此，当使用二进制编码时应总是设置所有的读取器配额（尤其是 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>），这一点非常重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-331">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="0d14a-332">当同时使用二进制编码和 <xref:System.Runtime.Serialization.DataContractSerializer>时， `IExtensibleDataObject` 接口可能被误用来发起字典展开攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-332">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="0d14a-333">此接口实质上是为并非属于协定一部分的任意数据提供不受限制的存储。</span><span class="sxs-lookup"><span data-stu-id="0d14a-333">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="0d14a-334">如果配额不能设置得足够低以使 `MaxSessionSize` 与 `MaxReceivedMessageSize` 的乘积不会造成问题，那么当使用二进制编码时应禁用 `IExtensibleDataObject` 功能。</span><span class="sxs-lookup"><span data-stu-id="0d14a-334">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="0d14a-335">为此，应当将 `IgnoreExtensionDataObject` 属性 (Attribute) 的 `true` 属性 (Property) 设置为 `ServiceBehaviorAttribute` 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-335">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="0d14a-336">或者，不实现 `IExtensibleDataObject` 接口。</span><span class="sxs-lookup"><span data-stu-id="0d14a-336">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="0d14a-337">有关详细信息，请参阅[向前兼容的数据协定](forward-compatible-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="0d14a-337">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="0d14a-338">配额概述</span><span class="sxs-lookup"><span data-stu-id="0d14a-338">Quotas Summary</span></span>

<span data-ttu-id="0d14a-339">下表概括了关于配额的指导信息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-339">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="0d14a-340">条件</span><span class="sxs-lookup"><span data-stu-id="0d14a-340">Condition</span></span>|<span data-ttu-id="0d14a-341">要设置的重要配额</span><span class="sxs-lookup"><span data-stu-id="0d14a-341">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="0d14a-342">非流式或流式小型消息、文本或 MTOM 编码</span><span class="sxs-lookup"><span data-stu-id="0d14a-342">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="0d14a-343">`MaxReceivedMessageSize`、`MaxBytesPerRead` 和 `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="0d14a-343">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="0d14a-344">非流式或流式小型消息或二进制编码</span><span class="sxs-lookup"><span data-stu-id="0d14a-344">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="0d14a-345">`MaxReceivedMessageSize`、 `MaxSessionSize`以及所有 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="0d14a-345">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="0d14a-346">流式大型消息、文本或 MTOM 编码</span><span class="sxs-lookup"><span data-stu-id="0d14a-346">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="0d14a-347">`MaxBufferSize` 和所有 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="0d14a-347">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="0d14a-348">流式大型消息或二进制编码</span><span class="sxs-lookup"><span data-stu-id="0d14a-348">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="0d14a-349">`MaxBufferSize`、 `MaxSessionSize`以及所有 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="0d14a-349">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="0d14a-350">必须总是设置传输层超时值，并且当使用流模式时切勿使用同步读/写，无论您是对大消息还是小消息进行流式处理，都是如此。</span><span class="sxs-lookup"><span data-stu-id="0d14a-350">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="0d14a-351">当对配额有疑问时，应将它设置为一个安全值，而不是将它留在那里不进行设置。</span><span class="sxs-lookup"><span data-stu-id="0d14a-351">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="0d14a-352">防止恶意代码执行</span><span class="sxs-lookup"><span data-stu-id="0d14a-352">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="0d14a-353">下面的常规威胁类可以执行代码并且具有意外的影响：</span><span class="sxs-lookup"><span data-stu-id="0d14a-353">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="0d14a-354">反序列化程序加载恶意的、不安全的或者安全性敏感类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-354">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="0d14a-355">传入消息导致反序列化程序以一种具有意外后果的方式构造一个通常而言很安全的类型的实例。</span><span class="sxs-lookup"><span data-stu-id="0d14a-355">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="0d14a-356">下面几节进一步讨论这些威胁类。</span><span class="sxs-lookup"><span data-stu-id="0d14a-356">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="0d14a-357">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="0d14a-357">DataContractSerializer</span></span>

<span data-ttu-id="0d14a-358"> (上的安全信息 <xref:System.Xml.Serialization.XmlSerializer> ，请参阅相关文档。 ) 的安全模型与的安全模型 <xref:System.Xml.Serialization.XmlSerializer> 类似 <xref:System.Runtime.Serialization.DataContractSerializer> ，并且主要在详细信息中有所不同。</span><span class="sxs-lookup"><span data-stu-id="0d14a-358">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="0d14a-359">例如，用于类型包括的是 <xref:System.Xml.Serialization.XmlIncludeAttribute> 属性，而不是 <xref:System.Runtime.Serialization.KnownTypeAttribute> 属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-359">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="0d14a-360">但是， <xref:System.Xml.Serialization.XmlSerializer> 特有的一些威胁将在本主题的后面部分讨论。</span><span class="sxs-lookup"><span data-stu-id="0d14a-360">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="0d14a-361">防止加载意外类型</span><span class="sxs-lookup"><span data-stu-id="0d14a-361">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="0d14a-362">加载意外类型可能具有非常严重的后果，无论该类型是恶意的，还是仅仅具有安全性敏感的负面影响，都有可能如此。</span><span class="sxs-lookup"><span data-stu-id="0d14a-362">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="0d14a-363">一个类型可能包含可利用的安全漏洞，在它的构造函数或类构造函数中执行安全性敏感操作，易于形成拒绝服务攻击的大内存需求量，或者可能引发不可恢复的异常。</span><span class="sxs-lookup"><span data-stu-id="0d14a-363">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="0d14a-364">类型可能具有在类型加载完成后、但在创建任何实例之前运行的类构造函数。</span><span class="sxs-lookup"><span data-stu-id="0d14a-364">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="0d14a-365">为此，必须控制反序列化程序可能加载的一组类型，这一点很重要。</span><span class="sxs-lookup"><span data-stu-id="0d14a-365">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="0d14a-366"><xref:System.Runtime.Serialization.DataContractSerializer> 以一种松散耦合的方式进行反序列化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-366">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="0d14a-367">它绝不从传入的数据中读取公共语言运行库 (CLR) 类型和程序集名称。</span><span class="sxs-lookup"><span data-stu-id="0d14a-367">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="0d14a-368">这与 <xref:System.Xml.Serialization.XmlSerializer>的行为类似，但与 <xref:System.Runtime.Serialization.NetDataContractSerializer>、 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>和 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>的行为不同。</span><span class="sxs-lookup"><span data-stu-id="0d14a-368">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="0d14a-369">松散耦合会引入一定程度的安全性，因为远程攻击者无法通过在消息中命名某个类型来指示首先加载该类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-369">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="0d14a-370">始终允许 <xref:System.Runtime.Serialization.DataContractSerializer> 加载按照协定当前预计加载的类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-370">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="0d14a-371">例如，如果数据协定具有一个 `Customer`类型的数据成员，则允许 <xref:System.Runtime.Serialization.DataContractSerializer> 在反序列化该数据成员时加载 `Customer` 类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-371">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="0d14a-372">此外， <xref:System.Runtime.Serialization.DataContractSerializer> 还支持多态性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-372">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="0d14a-373">一个数据成员可能声明为 <xref:System.Object>，但传入的数据可能包含一个 `Customer` 实例。</span><span class="sxs-lookup"><span data-stu-id="0d14a-373">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="0d14a-374">只有当已通过下面某种机制使反序列化程序“知晓” `Customer` 类型时，这种情况才是可能的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-374">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="0d14a-375">应用于类型的<xref:System.Runtime.Serialization.KnownTypeAttribute> 属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-375"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="0d14a-376">`KnownTypeAttribute` 属性，用于指定一个返回类型列表的方法。</span><span class="sxs-lookup"><span data-stu-id="0d14a-376">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="0d14a-377">`ServiceKnownTypeAttribute` 属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-377">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="0d14a-378">`KnownTypes` 配置节。</span><span class="sxs-lookup"><span data-stu-id="0d14a-378">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="0d14a-379">在构造期间向 <xref:System.Runtime.Serialization.DataContractSerializer> 显式传递的已知类型列表（如果直接使用序列化程序）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-379">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="0d14a-380">上述每个机制都引入了反序列化程序可加载的更多类型，从而增加了外围应用。</span><span class="sxs-lookup"><span data-stu-id="0d14a-380">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="0d14a-381">应控制其中的每个机制，确保不会有任何恶意类型或意外的类型添加到已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-381">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="0d14a-382">一旦已知类型在范围之内，那么即使协定实际禁止使用它，也可以随时加载它，并且可以创建该类型的实例。</span><span class="sxs-lookup"><span data-stu-id="0d14a-382">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="0d14a-383">例如，假定使用上述某个机制将类型“MyDangerousType”添加到了已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="0d14a-383">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="0d14a-384">这意味着：</span><span class="sxs-lookup"><span data-stu-id="0d14a-384">This means that:</span></span>

- <span data-ttu-id="0d14a-385">`MyDangerousType` 已加载并且它的类构造函数已运行。</span><span class="sxs-lookup"><span data-stu-id="0d14a-385">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="0d14a-386">即使当反序列化具有一个字符串数据成员的数据协定时，恶意消息也可能导致创建 `MyDangerousType` 的一个实例。</span><span class="sxs-lookup"><span data-stu-id="0d14a-386">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="0d14a-387">`MyDangerousType`中的代码（例如，属性 setter）可以运行。</span><span class="sxs-lookup"><span data-stu-id="0d14a-387">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="0d14a-388">完成此操作之后，反序列化程序会尝试将该实例指定给字符串数据成员，结果失败，并出现异常。</span><span class="sxs-lookup"><span data-stu-id="0d14a-388">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="0d14a-389">当编写返回已知类型列表的方法时，或者将一个列表直接传递给 <xref:System.Runtime.Serialization.DataContractSerializer> 构造函数时，应确保准备该列表的代码是安全的，并仅仅作用于受信任的数据。</span><span class="sxs-lookup"><span data-stu-id="0d14a-389">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="0d14a-390">如果在配置中指定已知类型，应确保配置文件是安全的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-390">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="0d14a-391">应始终在配置中使用强名称（通过指定该类型所在的已签名程序集的公钥），但不要指定要加载的类型的版本。</span><span class="sxs-lookup"><span data-stu-id="0d14a-391">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="0d14a-392">类型加载程序在可能的情况下会自动选取最新版本。</span><span class="sxs-lookup"><span data-stu-id="0d14a-392">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="0d14a-393">如果您在配置中指定特定版本，将面临以下风险：类型可能具有一个可在将来的版本中修复的安全漏洞，但仍然加载有漏洞的版本，因为在配置中显式指定了它。</span><span class="sxs-lookup"><span data-stu-id="0d14a-393">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="0d14a-394">具有过多的已知类型有另一个后果： <xref:System.Runtime.Serialization.DataContractSerializer> 将在应用程序域中创建序列化/反序列化代码的缓存，其中对于每个必须序列化和反序列化的类型，都有一个相应的项。</span><span class="sxs-lookup"><span data-stu-id="0d14a-394">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="0d14a-395">只要应用程序域在运行，就绝不会清除这一缓存。</span><span class="sxs-lookup"><span data-stu-id="0d14a-395">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="0d14a-396">因此，知道应用程序使用许多已知类型的攻击者可能导致所有这些类型都反序列化，从而导致缓存消耗了极大的内存量。</span><span class="sxs-lookup"><span data-stu-id="0d14a-396">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="0d14a-397">防止类型处于意外状态</span><span class="sxs-lookup"><span data-stu-id="0d14a-397">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="0d14a-398">类型可能具有必须强制执行的内部一致性约束。</span><span class="sxs-lookup"><span data-stu-id="0d14a-398">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="0d14a-399">在反序列化期间，必须小心，以避免破坏这些约束。</span><span class="sxs-lookup"><span data-stu-id="0d14a-399">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="0d14a-400">下面的类型示例代表太空飞船上的密封过渡仓的状态，并强制执行不能同时打开内门和外门的约束。</span><span class="sxs-lookup"><span data-stu-id="0d14a-400">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="0d14a-401">攻击者可能发送一个类似下面这样的恶意消息，以绕过此约束，而使对象进入无效状态，这可能造成意外的且不可预测的后果。</span><span class="sxs-lookup"><span data-stu-id="0d14a-401">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="0d14a-402">注意到下面几点就可以避免这种情形：</span><span class="sxs-lookup"><span data-stu-id="0d14a-402">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="0d14a-403">当 <xref:System.Runtime.Serialization.DataContractSerializer> 反序列化大多数类时，构造函数都不会运行。</span><span class="sxs-lookup"><span data-stu-id="0d14a-403">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="0d14a-404">因此，不要依赖在构造函数中执行的任何状态管理。</span><span class="sxs-lookup"><span data-stu-id="0d14a-404">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="0d14a-405">使用回调可确保对象处于有效状态。</span><span class="sxs-lookup"><span data-stu-id="0d14a-405">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="0d14a-406">标记有 <xref:System.Runtime.Serialization.OnDeserializedAttribute> 属性的回调尤其有用，因为它在反序列化完成后运行，有可能检查并更正整体状态。</span><span class="sxs-lookup"><span data-stu-id="0d14a-406">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="0d14a-407">有关详细信息，请参阅 [版本容错序列化回调](version-tolerant-serialization-callbacks.md)。</span><span class="sxs-lookup"><span data-stu-id="0d14a-407">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="0d14a-408">在设计数据协定类型时，不要使它依赖项属性 setter 的任何特定调用顺序。</span><span class="sxs-lookup"><span data-stu-id="0d14a-408">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="0d14a-409">使用标有 <xref:System.SerializableAttribute> 属性的旧式类型时应小心。</span><span class="sxs-lookup"><span data-stu-id="0d14a-409">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="0d14a-410">其中许多功能都设计为仅与受信任的数据一起使用 .NET Framework 远程处理。</span><span class="sxs-lookup"><span data-stu-id="0d14a-410">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="0d14a-411">标有此属性的现有类型在设计时可能并未考虑状态安全性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-411">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="0d14a-412">考虑到状态安全性，不要依赖 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 属性 (Attribute) 的 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性 (Property) 来保证数据的存在。</span><span class="sxs-lookup"><span data-stu-id="0d14a-412">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="0d14a-413">数据可能总是 `null`、 `zero`或 `invalid`。</span><span class="sxs-lookup"><span data-stu-id="0d14a-413">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="0d14a-414">在未首先验证的情况下，绝不要信任从不受信任的数据源反序列化的对象图。</span><span class="sxs-lookup"><span data-stu-id="0d14a-414">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="0d14a-415">每个单独的对象可能都处于一致状态，但对象图整体有可能处于不一致状态。</span><span class="sxs-lookup"><span data-stu-id="0d14a-415">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="0d14a-416">此外，即使禁用对象图保存模式，反序列化的对象图也可能具有对同一对象的多个引用或者具有循环引用。</span><span class="sxs-lookup"><span data-stu-id="0d14a-416">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="0d14a-417">有关详细信息，请参阅 [序列化和反序列](serialization-and-deserialization.md)化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-417">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="0d14a-418">安全地使用 NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="0d14a-418">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="0d14a-419"><xref:System.Runtime.Serialization.NetDataContractSerializer> 是一个序列化引擎，它使用类型的紧密耦合。</span><span class="sxs-lookup"><span data-stu-id="0d14a-419">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="0d14a-420">这类似于 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 和 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>。</span><span class="sxs-lookup"><span data-stu-id="0d14a-420">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="0d14a-421">也就是说，它通过从传入数据中读取 .NET Framework 程序集和类型名来确定要实例化的类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-421">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="0d14a-422">尽管它是 WCF 的一部分，但没有提供的方法来插入此序列化引擎;必须编写自定义代码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-422">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="0d14a-423">`NetDataContractSerializer`提供主要是为了简化从 .NET Framework 远程处理到 WCF 的迁移。</span><span class="sxs-lookup"><span data-stu-id="0d14a-423">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="0d14a-424">有关详细信息，请参阅 [序列化和反序列](serialization-and-deserialization.md)化中的相关部分。</span><span class="sxs-lookup"><span data-stu-id="0d14a-424">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="0d14a-425">因为消息本身可能指示可以加载的任何类型，所以 <xref:System.Runtime.Serialization.NetDataContractSerializer> 机制本质上是不安全的，应当仅与受信任的数据一起使用。</span><span class="sxs-lookup"><span data-stu-id="0d14a-425">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="0d14a-426">有关详细信息，请参阅 [BinaryFormatter security guide （安全指南](../../../standard/serialization/binaryformatter-security-guide.md)）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-426">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>

<span data-ttu-id="0d14a-427">即使与受信任的数据一起使用时，传入数据也可能不足以指定要加载的类型，尤其当 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 属性设置为 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>时更有可能如此。</span><span class="sxs-lookup"><span data-stu-id="0d14a-427">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="0d14a-428">可访问应用程序的目录或全局程序集缓存的任何人都可以用恶意类型来代替预计要加载的类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-428">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="0d14a-429">应始终通过正确地设置权限来确保应用程序的目录和全局程序集缓存的安全性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-429">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="0d14a-430">通常，如果您允许部分受信任的代码访问您的 `NetDataContractSerializer` 实例，或以其他方式控制代理项选择器 (<xref:System.Runtime.Serialization.ISurrogateSelector>) 或序列化联编程序 (<xref:System.Runtime.Serialization.SerializationBinder>)，则代码可能会对序列化/反序列化过程进行大量控制。</span><span class="sxs-lookup"><span data-stu-id="0d14a-430">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="0d14a-431">例如，它可能会插入任意类型、导致信息泄漏、篡改生成的对象图或序列化数据，或使产生的序列化流溢出。</span><span class="sxs-lookup"><span data-stu-id="0d14a-431">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="0d14a-432">关于 `NetDataContractSerializer` 的另外一个安全问题是拒绝服务，而不是恶意代码执行威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-432">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="0d14a-433">当使用 `NetDataContractSerializer`时，应始终将 <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> 配额设置为一个安全值。</span><span class="sxs-lookup"><span data-stu-id="0d14a-433">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="0d14a-434">很容易构造这样一个小的恶意消息：分配一个其大小仅受此配额限制的对象数组。</span><span class="sxs-lookup"><span data-stu-id="0d14a-434">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="0d14a-435">XmlSerializer 特有的威胁</span><span class="sxs-lookup"><span data-stu-id="0d14a-435">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="0d14a-436"><xref:System.Xml.Serialization.XmlSerializer> 安全模型与 <xref:System.Runtime.Serialization.DataContractSerializer>的安全模型类似。</span><span class="sxs-lookup"><span data-stu-id="0d14a-436">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="0d14a-437">但是，有几个威胁是 <xref:System.Xml.Serialization.XmlSerializer>特有的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-437">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="0d14a-438"><xref:System.Xml.Serialization.XmlSerializer> 在运行时生成序列化程序集  ，它们包含实际执行序列化和反序列化的代码；这些程序集是在临时文件目录中创建的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-438">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="0d14a-439">如果另外某个进程或用户对该目录拥有访问权限，可能用任意代码来覆盖序列化/反序列化代码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-439">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="0d14a-440">之后 <xref:System.Xml.Serialization.XmlSerializer> 将使用它的安全上下文来运行这些代码，而不是运行序列化/反序列化代码。</span><span class="sxs-lookup"><span data-stu-id="0d14a-440">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="0d14a-441">请确保在临时文件目录上正确地设置了权限，以防止这种情况的发生。</span><span class="sxs-lookup"><span data-stu-id="0d14a-441">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="0d14a-442"><xref:System.Xml.Serialization.XmlSerializer> 还具有这样一种模式，即：使用预先生成的序列化程序集，而不是在运行时生成这些程序集。</span><span class="sxs-lookup"><span data-stu-id="0d14a-442">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="0d14a-443">只要 <xref:System.Xml.Serialization.XmlSerializer> 可以找到一个合适的序列化程序集，就会触发这一模式。</span><span class="sxs-lookup"><span data-stu-id="0d14a-443">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="0d14a-444"><xref:System.Xml.Serialization.XmlSerializer> 检查对序列化程序集进行签名的密钥是否就是对包含所序列化的类型的程序集进行签名的密钥。</span><span class="sxs-lookup"><span data-stu-id="0d14a-444">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="0d14a-445">这有助于防止恶意程序集伪装成序列化程序集。</span><span class="sxs-lookup"><span data-stu-id="0d14a-445">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="0d14a-446">但是，如果包含可序列化类型的程序集未签名，则 <xref:System.Xml.Serialization.XmlSerializer> 将无法执行此检查，而使用具有正确名称的任何程序集。</span><span class="sxs-lookup"><span data-stu-id="0d14a-446">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="0d14a-447">这就使得运行恶意代码成为可能。</span><span class="sxs-lookup"><span data-stu-id="0d14a-447">This makes running malicious code possible.</span></span> <span data-ttu-id="0d14a-448">应始终对包含可序列化类型的程序集进行签名，或者严格控制对应用程序的目录和全局程序集缓存的访问，以防止引入恶意程序集。</span><span class="sxs-lookup"><span data-stu-id="0d14a-448">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="0d14a-449"><xref:System.Xml.Serialization.XmlSerializer> 可能遭到拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-449">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="0d14a-450"><xref:System.Xml.Serialization.XmlSerializer> 没有 `MaxItemsInObjectGraph` 所具有的 <xref:System.Runtime.Serialization.DataContractSerializer>配额。</span><span class="sxs-lookup"><span data-stu-id="0d14a-450">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="0d14a-451">这样，在消息大小所允许的范围内，它可以反序列化任意多的对象。</span><span class="sxs-lookup"><span data-stu-id="0d14a-451">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="0d14a-452">部分信任威胁</span><span class="sxs-lookup"><span data-stu-id="0d14a-452">Partial Trust Threats</span></span>

<span data-ttu-id="0d14a-453">关于与以部分信任运行的代码有关的威胁，请注意下面几点。</span><span class="sxs-lookup"><span data-stu-id="0d14a-453">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="0d14a-454">这些威胁包括恶意的部分受信任代码以及恶意的部分受信任代码与其他攻击情况（例如，构造特定字符串、然后对它进行反序列化的部分受信任代码）的组合。</span><span class="sxs-lookup"><span data-stu-id="0d14a-454">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="0d14a-455">使用任何序列化组件时，切勿在进行这样的使用之前断言任何权限，即使整个序列化方案是在断言的范围之内，并且您未处理任何不受信任的数据或对象，也不要进行这样的断言。</span><span class="sxs-lookup"><span data-stu-id="0d14a-455">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="0d14a-456">这样的使用可能导致安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="0d14a-456">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="0d14a-457">在部分受信任的代码可以通过扩展点（代理项）、要序列化的类型或其他方法控制序列化过程的情况下，部分受信任的代码可能会导致序列化程序将大量数据输出到序列化流中，这将导致此流的接收方会受到拒绝服务 (DoS) 攻击。</span><span class="sxs-lookup"><span data-stu-id="0d14a-457">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="0d14a-458">如果要序列化数据，而这些数据专用于易于遭到 DoS 威胁的目标，则不序列化部分受信任的类型，或以其他方式使部分受信任的代码控制序列化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-458">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="0d14a-459">如果允许部分受信任的代码访问 <xref:System.Runtime.Serialization.DataContractSerializer> 实例或控制 [数据协定代理](../extending/data-contract-surrogates.md)项，则可能会对序列化/反序列化过程进行大量控制。</span><span class="sxs-lookup"><span data-stu-id="0d14a-459">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="0d14a-460">例如，它可能会插入任意类型、导致信息泄漏、篡改生成的对象图或序列化数据，或使产生的序列化流溢出。</span><span class="sxs-lookup"><span data-stu-id="0d14a-460">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="0d14a-461">“安全地使用 NetDataContractSerializer”一节中介绍了等效的 <xref:System.Runtime.Serialization.NetDataContractSerializer> 威胁。</span><span class="sxs-lookup"><span data-stu-id="0d14a-461">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="0d14a-462">如果对类型应用了 <xref:System.Runtime.Serialization.DataContractAttribute> 属性（或者类型标记为 <xref:System.SerializableAttribute> ，但不是 <xref:System.Runtime.Serialization.ISerializable>），即使所有构造函数都不是公共的或者受需求保护，反序列化程序也可以创建这样一个类型的实例。</span><span class="sxs-lookup"><span data-stu-id="0d14a-462">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="0d14a-463">绝不要信任反序列化的结果，除非要反序列化的数据是受信任的，并且您确定所有已知类型都是您信任的类型。</span><span class="sxs-lookup"><span data-stu-id="0d14a-463">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="0d14a-464">请注意，在部分信任情况下运行时，已知类型不是从应用程序配置文件加载的（而是从计算机配置文件加载的）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-464">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="0d14a-465">如果您使用添加到部分受信任代码的代理项来传递 <xref:System.Runtime.Serialization.DataContractSerializer> 实例，则代码可以更改该代理项的任何可修改设置。</span><span class="sxs-lookup"><span data-stu-id="0d14a-465">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="0d14a-466">对于已反序列化的对象，如果 XML 读取器（或者其中的数据）来自部分受信任的代码，则会将所生成的反序列化对象视为不受信任的数据。</span><span class="sxs-lookup"><span data-stu-id="0d14a-466">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="0d14a-467"><xref:System.Runtime.Serialization.ExtensionDataObject> 类型没有公共成员，并不意味着它其中的数据是安全的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-467">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="0d14a-468">例如，如果从特权数据源反序列化为其中存在一些数据的对象，然后将该对象传递给部分受信任的代码，则这些部分受信任的代码可以通过序列化 `ExtensionDataObject` 来读取该对象中的数据。</span><span class="sxs-lookup"><span data-stu-id="0d14a-468">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="0d14a-469">当从具有特权的数据源反序列化为之后将传递给部分受信任的代码的对象时，应考虑将 <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> 设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-469">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="0d14a-470"><xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 以完全信任的方式支持对私有成员、受保护成员、内部成员和公共成员进行序列化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-470"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="0d14a-471">但在部分信任的情况下，只可序列化公共成员。</span><span class="sxs-lookup"><span data-stu-id="0d14a-471">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="0d14a-472">如果应用程序尝试序列化非公共成员，则会引发 <xref:System.Security.SecurityException> 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-472">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="0d14a-473">若要允许在部分信任的情况下序列化内部成员或受保护成员，则请使用 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 程序集属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-473">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="0d14a-474">此属性允许程序集声明其内部成员对其他程序集可见。</span><span class="sxs-lookup"><span data-stu-id="0d14a-474">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="0d14a-475">在此情况下，需要序列化其内部成员的程序集可声明其内部成员对 System.Runtime.Serialization.dll 可见。</span><span class="sxs-lookup"><span data-stu-id="0d14a-475">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="0d14a-476">此方法的优点是，不需要提升的代码生成路径。</span><span class="sxs-lookup"><span data-stu-id="0d14a-476">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="0d14a-477">不过，此方法还有两大缺点。</span><span class="sxs-lookup"><span data-stu-id="0d14a-477">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="0d14a-478">第一个缺点是， <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 特性的选择加入的属性是程序集范围的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-478">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="0d14a-479">也就是说，无法指定仅某个类可具有序列化的内部成员。</span><span class="sxs-lookup"><span data-stu-id="0d14a-479">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="0d14a-480">当然，仍可以通过不将 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性添加到某个特定的内部成员来选择不对该成员进行序列化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-480">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="0d14a-481">类似地，出于可见性方面的考虑，开发人员也可选择使某个成员成为内部成员而不是私有成员或受保护成员。</span><span class="sxs-lookup"><span data-stu-id="0d14a-481">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="0d14a-482">第二个缺点是，此方法仍不支持私有成员或受保护成员。</span><span class="sxs-lookup"><span data-stu-id="0d14a-482">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="0d14a-483">若要演示如何在部分信任的情况下使用 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 属性，请考虑以下程序：</span><span class="sxs-lookup"><span data-stu-id="0d14a-483">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="0d14a-484">在上面的示例中， `PermissionsHelper.InternetZone` 对应于部分信任情况下的 <xref:System.Security.PermissionSet> 。</span><span class="sxs-lookup"><span data-stu-id="0d14a-484">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="0d14a-485">现在，如果没有 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 属性，应用程序将失败，并引发， <xref:System.Security.SecurityException> 指示非公共成员不能在部分信任中序列化。</span><span class="sxs-lookup"><span data-stu-id="0d14a-485">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="0d14a-486">但如果将以下行添加到源文件，则程序将成功运行。</span><span class="sxs-lookup"><span data-stu-id="0d14a-486">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="0d14a-487">其他状态管理问题</span><span class="sxs-lookup"><span data-stu-id="0d14a-487">Other State Management Concerns</span></span>

<span data-ttu-id="0d14a-488">还有其他几个与对象状态管理的问题值得注意：</span><span class="sxs-lookup"><span data-stu-id="0d14a-488">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="0d14a-489">当将基于流的编程模型与流传输一起使用时，消息的处理会随着消息的到达而发生。</span><span class="sxs-lookup"><span data-stu-id="0d14a-489">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="0d14a-490">消息的发送方可能在流的传输过程中中止发送操作，从而在接收方期待更多内容的时候将代码置于了不可预测的状态。</span><span class="sxs-lookup"><span data-stu-id="0d14a-490">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="0d14a-491">通常，不要等待流完成，并且不要在基于流的操作中执行在流传输中止时无法回滚的任何工作。</span><span class="sxs-lookup"><span data-stu-id="0d14a-491">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="0d14a-492">这同样适用于在流正文之后消息格式有误的情况（例如，SOAP 信封缺少一个结束标记，或者有第二个消息正文）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-492">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="0d14a-493">使用 `IExtensibleDataObject` 功能可能导致发送敏感数据。</span><span class="sxs-lookup"><span data-stu-id="0d14a-493">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="0d14a-494">如果您将来自不受信任源的数据放入具有 `IExtensibleObjectData` 的数据协定中，之后在对消息进行签名的安全通道上重新发送这些数据，则可能表明您对这些数据一无所知。</span><span class="sxs-lookup"><span data-stu-id="0d14a-494">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="0d14a-495">此外，如果您同时考虑已知数据块和未知数据块，则所发送的整体状态可能是无效的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-495">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="0d14a-496">可以通过选择将扩展数据属性设置为 `null` 或者选择禁用 `IExtensibleObjectData` 功能来避免这种情况。</span><span class="sxs-lookup"><span data-stu-id="0d14a-496">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="0d14a-497">架构导入</span><span class="sxs-lookup"><span data-stu-id="0d14a-497">Schema Import</span></span>

<span data-ttu-id="0d14a-498">通常，导入架构以生成类型的过程只会在设计时发生，例如，当在 Web 服务上使用 [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) 来生成客户端类时就会发生此过程。</span><span class="sxs-lookup"><span data-stu-id="0d14a-498">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="0d14a-499">但是，在更复杂的情况下，也可能在运行时处理架构。</span><span class="sxs-lookup"><span data-stu-id="0d14a-499">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="0d14a-500">请注意，这样做可能会有遭到拒绝服务攻击的风险。</span><span class="sxs-lookup"><span data-stu-id="0d14a-500">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="0d14a-501">有些架构可能需要很长时间才能导入。</span><span class="sxs-lookup"><span data-stu-id="0d14a-501">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="0d14a-502">如果架构可能来自不受信任的源，那么在这种情况下绝不要使用 <xref:System.Xml.Serialization.XmlSerializer> 架构导入组件。</span><span class="sxs-lookup"><span data-stu-id="0d14a-502">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="0d14a-503">特定于 ASP.NET AJAX 集成的威胁</span><span class="sxs-lookup"><span data-stu-id="0d14a-503">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="0d14a-504">当用户实现 <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> 或时 <xref:System.ServiceModel.Description.WebHttpBehavior> ，WCF 公开可同时接受 XML 和 JSON 消息的终结点。</span><span class="sxs-lookup"><span data-stu-id="0d14a-504">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="0d14a-505">但是，只有一组读取器配额，供 XML 读取器和 JSON 读取器同时使用。</span><span class="sxs-lookup"><span data-stu-id="0d14a-505">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="0d14a-506">某些配额设置可能适合于一种读取器，但对另一种读取器而言太大。</span><span class="sxs-lookup"><span data-stu-id="0d14a-506">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="0d14a-507">实现 `WebScriptEnablingBehavior`时，用户可选择公开位于终结点的 JavaScript 代理。</span><span class="sxs-lookup"><span data-stu-id="0d14a-507">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="0d14a-508">必须考虑以下安全问题：</span><span class="sxs-lookup"><span data-stu-id="0d14a-508">The following security issues must be considered:</span></span>

- <span data-ttu-id="0d14a-509">可以通过检查 JavaScript 代理来获取有关服务的信息（操作名称和参数名称等）。</span><span class="sxs-lookup"><span data-stu-id="0d14a-509">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="0d14a-510">使用 JavaScript 终结点时，可能会在客户端的 Web 浏览器缓存中保留敏感信息和私有信息。</span><span class="sxs-lookup"><span data-stu-id="0d14a-510">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="0d14a-511">关于组件的说明</span><span class="sxs-lookup"><span data-stu-id="0d14a-511">A Note on Components</span></span>

<span data-ttu-id="0d14a-512">WCF 是一个灵活且可自定义的系统。</span><span class="sxs-lookup"><span data-stu-id="0d14a-512">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="0d14a-513">本主题中的大部分内容侧重于最常见的 WCF 使用方案。</span><span class="sxs-lookup"><span data-stu-id="0d14a-513">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="0d14a-514">但是，可以通过多种不同的方式撰写 WCF 提供的组件。</span><span class="sxs-lookup"><span data-stu-id="0d14a-514">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="0d14a-515">必须了解使用每个组件的安全含义。</span><span class="sxs-lookup"><span data-stu-id="0d14a-515">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="0d14a-516">具体而言：</span><span class="sxs-lookup"><span data-stu-id="0d14a-516">In particular:</span></span>

- <span data-ttu-id="0d14a-517">当您必须使用 XML 读取器时，应使用 <xref:System.Xml.XmlDictionaryReader> 类所提供的读取器，而不要使用其他任何读取器。</span><span class="sxs-lookup"><span data-stu-id="0d14a-517">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="0d14a-518">安全读取器是使用 <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>、 <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>或 <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> 方法创建的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-518">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="0d14a-519">不要使用 <xref:System.Xml.XmlReader.Create%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="0d14a-519">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="0d14a-520">应始终为读取器配置安全配额。</span><span class="sxs-lookup"><span data-stu-id="0d14a-520">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="0d14a-521">WCF 中的序列化引擎仅在与 WCF 中的安全 XML 读取器一起使用时才是安全的。</span><span class="sxs-lookup"><span data-stu-id="0d14a-521">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="0d14a-522">当使用 <xref:System.Runtime.Serialization.DataContractSerializer> 来反序列化可能不受信任的数据时，应总是设置 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="0d14a-522">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="0d14a-523">创建消息时，如果 `maxSizeOfHeaders` 不能提供足够的保护，应设置 `MaxReceivedMessageSize` 参数。</span><span class="sxs-lookup"><span data-stu-id="0d14a-523">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="0d14a-524">创建编码器时，应始终配额相关的配额，例如 `MaxSessionSize` 和 `MaxBufferSize`。</span><span class="sxs-lookup"><span data-stu-id="0d14a-524">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="0d14a-525">使用 XPath 消息筛选器时，应设置 <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> 以限制筛选器访问的 XML 节点数量。</span><span class="sxs-lookup"><span data-stu-id="0d14a-525">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="0d14a-526">不要使用 XPath 表达式，此类表达式即使不访问许多节点，可能也需要很长时间来计算。</span><span class="sxs-lookup"><span data-stu-id="0d14a-526">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="0d14a-527">通常，当使用接受配额的任何组件时，都应了解它的安全含义并将它设置为一个安全值。</span><span class="sxs-lookup"><span data-stu-id="0d14a-527">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="0d14a-528">请参阅</span><span class="sxs-lookup"><span data-stu-id="0d14a-528">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="0d14a-529">数据协定已知类型</span><span class="sxs-lookup"><span data-stu-id="0d14a-529">Data Contract Known Types</span></span>](data-contract-known-types.md)
