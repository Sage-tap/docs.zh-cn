---
title: 安全规则（代码分析）
description: 了解代码分析安全规则。
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 861827662a771ec7cc1827cdd8125be6c05bf05c
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "99719716"
---
# <a name="security-rules"></a><span data-ttu-id="35e78-103">安全规则</span><span class="sxs-lookup"><span data-stu-id="35e78-103">Security rules</span></span>

<span data-ttu-id="35e78-104">安全规则可实现更安全的库和应用程序。</span><span class="sxs-lookup"><span data-stu-id="35e78-104">Security rules support safer libraries and applications.</span></span> <span data-ttu-id="35e78-105">这些规则有助于防止程序中出现安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-105">These rules help prevent security flaws in your program.</span></span> <span data-ttu-id="35e78-106">如果禁用其中任何规则，你应该在代码中清除标记原因，并通知开发项目的指定安全负责人。</span><span class="sxs-lookup"><span data-stu-id="35e78-106">If you disable any of these rules, you should clearly mark the reason in code and also inform the designated security officer for your development project.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="35e78-107">在本节中</span><span class="sxs-lookup"><span data-stu-id="35e78-107">In this section</span></span>

|<span data-ttu-id="35e78-108">规则</span><span class="sxs-lookup"><span data-stu-id="35e78-108">Rule</span></span>|<span data-ttu-id="35e78-109">描述</span><span class="sxs-lookup"><span data-stu-id="35e78-109">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="35e78-110">CA2100:检查 SQL 查询是否存在安全漏洞</span><span class="sxs-lookup"><span data-stu-id="35e78-110">CA2100: Review SQL queries for security vulnerabilities</span></span>](ca2100.md)|<span data-ttu-id="35e78-111">一个方法使用按该方法的字符串参数生成的字符串设置 System.Data.IDbCommand.CommandText 属性。</span><span class="sxs-lookup"><span data-stu-id="35e78-111">A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method.</span></span> <span data-ttu-id="35e78-112">此规则假定字符串参数中包含用户输入。</span><span class="sxs-lookup"><span data-stu-id="35e78-112">This rule assumes that the string argument contains user input.</span></span> <span data-ttu-id="35e78-113">基于用户输入生成的 SQL 命令字符串易于受到 SQL 注入式攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-113">A SQL command string built from user input is vulnerable to SQL injection attacks.</span></span>|
|[<span data-ttu-id="35e78-114">CA2109:检查可见的事件处理程序</span><span class="sxs-lookup"><span data-stu-id="35e78-114">CA2109: Review visible event handlers</span></span>](ca2109.md)|<span data-ttu-id="35e78-115">检测到公共事件处理方法或受保护事件处理方法。</span><span class="sxs-lookup"><span data-stu-id="35e78-115">A public or protected event-handling method was detected.</span></span> <span data-ttu-id="35e78-116">除非绝对必要，否则不应公开事件处理方法。</span><span class="sxs-lookup"><span data-stu-id="35e78-116">Event-handling methods should not be exposed unless absolutely necessary.</span></span>|
|[<span data-ttu-id="35e78-117">CA2119:密封满足私有接口的方法</span><span class="sxs-lookup"><span data-stu-id="35e78-117">CA2119: Seal methods that satisfy private interfaces</span></span>](ca2119.md)|<span data-ttu-id="35e78-118">可继承的公共类型为 internal（在 Visual Basic 中为 Friend）接口提供可重写的方法实现。</span><span class="sxs-lookup"><span data-stu-id="35e78-118">An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface.</span></span> <span data-ttu-id="35e78-119">若要修复与此规则的冲突，请禁止方法在程序集外重写。</span><span class="sxs-lookup"><span data-stu-id="35e78-119">To fix a violation of this rule, prevent the method from being overridden outside the assembly.</span></span>|
|[<span data-ttu-id="35e78-120">CA2153：避免处理损坏状态异常</span><span class="sxs-lookup"><span data-stu-id="35e78-120">CA2153: Avoid Handling Corrupted State Exceptions</span></span>](ca2153.md)|<span data-ttu-id="35e78-121">[损坏状态异常 (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) 指示进程中存在内存损坏。</span><span class="sxs-lookup"><span data-stu-id="35e78-121">[Corrupted State Exceptions (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) indicate that memory corruption exists in your process.</span></span> <span data-ttu-id="35e78-122">如果攻击者可以将攻击放置到损坏的内存区域，则捕获它们（而非允许进程崩溃）可能导致安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-122">Catching these rather than allowing the process to crash can lead to security vulnerabilities if an attacker can place an exploit into the corrupted memory region.</span></span>|
|[<span data-ttu-id="35e78-123">CA2300：请勿使用不安全的反序列化程序 BinaryFormatte</span><span class="sxs-lookup"><span data-stu-id="35e78-123">CA2300: Do not use insecure deserializer BinaryFormatter</span></span>](ca2300.md)|<span data-ttu-id="35e78-124">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-124">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-125">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-125">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-126">CA2301：在未先设置 BinaryFormatter.Binder 的情况下，请不要调用 BinaryFormatter.Deserialize</span><span class="sxs-lookup"><span data-stu-id="35e78-126">CA2301: Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</span></span>](ca2301.md)|<span data-ttu-id="35e78-127">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-127">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-128">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-128">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-129">CA2302：在调用 BinaryFormatter.Deserialize 之前，确保设置 BinaryFormatter.Binder</span><span class="sxs-lookup"><span data-stu-id="35e78-129">CA2302: Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</span></span>](ca2302.md)|<span data-ttu-id="35e78-130">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-130">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-131">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-131">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-132">CA2305：请勿使用不安全的反序列化程序 LosFormatter</span><span class="sxs-lookup"><span data-stu-id="35e78-132">CA2305: Do not use insecure deserializer LosFormatter</span></span>](ca2305.md)|<span data-ttu-id="35e78-133">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-133">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-134">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-134">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-135">CA2310：请勿使用不安全的反序列化程序 NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="35e78-135">CA2310: Do not use insecure deserializer NetDataContractSerializer</span></span>](ca2310.md)|<span data-ttu-id="35e78-136">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-136">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-137">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-137">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-138">CA2311：在未先设置 NetDataContractSerializer.Binder 的情况下，请不要反序列化</span><span class="sxs-lookup"><span data-stu-id="35e78-138">CA2311: Do not deserialize without first setting NetDataContractSerializer.Binder</span></span>](ca2311.md)|<span data-ttu-id="35e78-139">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-139">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-140">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-140">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-141">CA2312：确保在反序列化之前设置 NetDataContractSerializer.Binder</span><span class="sxs-lookup"><span data-stu-id="35e78-141">CA2312: Ensure NetDataContractSerializer.Binder is set before deserializing</span></span>](ca2312.md)|<span data-ttu-id="35e78-142">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-142">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-143">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-143">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-144">CA2315：请勿使用不安全的反序列化程序 ObjectStateFormatter</span><span class="sxs-lookup"><span data-stu-id="35e78-144">CA2315: Do not use insecure deserializer ObjectStateFormatter</span></span>](ca2315.md)|<span data-ttu-id="35e78-145">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-145">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-146">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-146">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-147">CA2321：请勿使用 SimpleTypeResolver 对 JavaScriptSerializer 进行反序列化</span><span class="sxs-lookup"><span data-stu-id="35e78-147">CA2321: Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</span></span>](ca2321.md)|<span data-ttu-id="35e78-148">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-148">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-149">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-149">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-150">CA2322：确保在反序列化之前没有使用 SimpleTypeResolver 初始化 JavaScriptSerializer</span><span class="sxs-lookup"><span data-stu-id="35e78-150">CA2322: Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</span></span>](ca2322.md)|<span data-ttu-id="35e78-151">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-151">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-152">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-152">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-153">CA2326：请勿使用 None 以外的 TypeNameHandling 值</span><span class="sxs-lookup"><span data-stu-id="35e78-153">CA2326: Do not use TypeNameHandling values other than None</span></span>](ca2326.md)|<span data-ttu-id="35e78-154">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-154">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-155">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-155">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-156">CA2327：不要使用不安全的 JsonSerializerSettings</span><span class="sxs-lookup"><span data-stu-id="35e78-156">CA2327: Do not use insecure JsonSerializerSettings</span></span>](ca2327.md)|<span data-ttu-id="35e78-157">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-157">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-158">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-158">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-159">CA2328：确保 JsonSerializerSettings 是安全的</span><span class="sxs-lookup"><span data-stu-id="35e78-159">CA2328: Ensure that JsonSerializerSettings are secure</span></span>](ca2328.md)|<span data-ttu-id="35e78-160">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-160">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-161">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-161">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-162">CA2329：不要使用不安全的配置反序列化 JsonSerializer</span><span class="sxs-lookup"><span data-stu-id="35e78-162">CA2329: Do not deserialize with JsonSerializer using an insecure configuration</span></span>](ca2329.md)|<span data-ttu-id="35e78-163">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-163">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-164">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-164">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-165">CA2330：在反序列化时确保 JsonSerializer 具有安全配置</span><span class="sxs-lookup"><span data-stu-id="35e78-165">CA2330: Ensure that JsonSerializer has a secure configuration when deserializing</span></span>](ca2330.md)|<span data-ttu-id="35e78-166">反序列化不受信任的数据时，会对不安全的反序列化程序造成风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-166">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="35e78-167">攻击者可能会修改序列化数据，使其包含非预期类型，进而注入具有不良副作用的对象。</span><span class="sxs-lookup"><span data-stu-id="35e78-167">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="35e78-168">CA2350:确保 DataTable.ReadXml() 的输入受信任</span><span class="sxs-lookup"><span data-stu-id="35e78-168">CA2350: Ensure DataTable.ReadXml()'s input is trusted</span></span>](ca2350.md)|<span data-ttu-id="35e78-169">对包含不受信任的输入的 <xref:System.Data.DataTable> 执行反序列化时，攻击者可能通过创建恶意输入实施拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-169">When deserializing a <xref:System.Data.DataTable> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="35e78-170">有可能存在未知的远程代码执行漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-170">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="35e78-171">CA2351:确保 DataSet.ReadXml() 的输入受信任</span><span class="sxs-lookup"><span data-stu-id="35e78-171">CA2351: Ensure DataSet.ReadXml()'s input is trusted</span></span>](ca2351.md)|<span data-ttu-id="35e78-172">对包含不受信任的输入的 <xref:System.Data.DataSet> 执行反序列化时，攻击者可能通过创建恶意输入实施拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-172">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="35e78-173">有可能存在未知的远程代码执行漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-173">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="35e78-174">CA2352:可序列化类型中的不安全 DataSet 或 DataTable 容易受到远程代码执行攻击</span><span class="sxs-lookup"><span data-stu-id="35e78-174">CA2352: Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</span></span>](ca2352.md)|<span data-ttu-id="35e78-175">带有 <xref:System.SerializableAttribute> 标记的类或结构包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 字段或属性，但不具有 <xref:System.CodeDom.Compiler.GeneratedCodeAttribute>。</span><span class="sxs-lookup"><span data-stu-id="35e78-175">A class or struct marked with <xref:System.SerializableAttribute> contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property, and doesn't have a <xref:System.CodeDom.Compiler.GeneratedCodeAttribute>.</span></span>|
|[<span data-ttu-id="35e78-176">CA2353:可序列化类型中的不安全 DataSet 或 DataTable</span><span class="sxs-lookup"><span data-stu-id="35e78-176">CA2353: Unsafe DataSet or DataTable in serializable type</span></span>](ca2353.md)|<span data-ttu-id="35e78-177">使用 XML 序列化特性或数据协定特性进行了标记的类或结构包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 字段或属性。</span><span class="sxs-lookup"><span data-stu-id="35e78-177">A class or struct marked with an XML serialization attribute or a data contract attribute contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property.</span></span>|
|[<span data-ttu-id="35e78-178">CA2354:反序列化对象图中的不安全 DataSet 或 DataTable 可能容易受到远程代码执行攻击</span><span class="sxs-lookup"><span data-stu-id="35e78-178">CA2354: Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attack</span></span>](ca2354.md)|<span data-ttu-id="35e78-179">当使用序列化的 <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> 进行反序列化时，且强制转换的类型的对象图可能包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 时。</span><span class="sxs-lookup"><span data-stu-id="35e78-179">Deserializing with an <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serialized, and the casted type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="35e78-180">CA2355:反序列化对象图中的不安全 DataSet 或 DataTable</span><span class="sxs-lookup"><span data-stu-id="35e78-180">CA2355: Unsafe DataSet or DataTable in deserialized object graph</span></span>](ca2355.md)|<span data-ttu-id="35e78-181">当强制转换的或指定的类型的对象图可能包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 类时，进行反序列化。</span><span class="sxs-lookup"><span data-stu-id="35e78-181">Deserializing when the casted or specified type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="35e78-182">CA2356：Web 反序列化的对象图中不安全的 DataSet 或 DataTable</span><span class="sxs-lookup"><span data-stu-id="35e78-182">CA2356: Unsafe DataSet or DataTable in web deserialized object graph</span></span>](ca2356.md)|<span data-ttu-id="35e78-183">带有 <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> 或 <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> 的方法具有可能引用 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 的参数。</span><span class="sxs-lookup"><span data-stu-id="35e78-183">A method with a <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> or <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> has a parameter that may reference a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="35e78-184">CA2361：请确保包含 DataSet.ReadXml() 的自动生成的类没有与不受信任的数据一起使用</span><span class="sxs-lookup"><span data-stu-id="35e78-184">CA2361: Ensure autogenerated class containing DataSet.ReadXml() is not used with untrusted data</span></span>](ca2361.md)|<span data-ttu-id="35e78-185">对包含不受信任的输入的 <xref:System.Data.DataSet> 执行反序列化时，攻击者可能通过创建恶意输入实施拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-185">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="35e78-186">有可能存在未知的远程代码执行漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-186">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="35e78-187">CA2362：自动生成的可序列化类型中不安全的数据集或数据表易受远程代码执行攻击</span><span class="sxs-lookup"><span data-stu-id="35e78-187">CA2362: Unsafe DataSet or DataTable in autogenerated serializable type can be vulnerable to remote code execution attacks</span></span>](ca2362.md)|<span data-ttu-id="35e78-188">当反序列化具有 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 的不受信任的输入且反序列化的对象图包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 时，攻击者可能创建执行远程代码执行攻击的恶意有效负载。</span><span class="sxs-lookup"><span data-stu-id="35e78-188">When deserializing untrusted input with <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the deserialized object graph contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>, an attacker can craft a malicious payload to perform a remote code execution attack.</span></span>|
|[<span data-ttu-id="35e78-189">CA3001：查看 SQL 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-189">CA3001: Review code for SQL injection vulnerabilities</span></span>](ca3001.md)|<span data-ttu-id="35e78-190">使用不受信任的输入和 SQL 命令时，请注意防范 SQL 注入攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-190">When working with untrusted input and SQL commands, be mindful of SQL injection attacks.</span></span> <span data-ttu-id="35e78-191">SQL 注入攻击可以执行恶意的 SQL 命令，从而降低应用程序的安全性和完整性。</span><span class="sxs-lookup"><span data-stu-id="35e78-191">An SQL injection attack can execute malicious SQL commands, compromising the security and integrity of your application.</span></span>|
|[<span data-ttu-id="35e78-192">CA3002：查看 XSS 漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-192">CA3002: Review code for XSS vulnerabilities</span></span>](ca3002.md)|<span data-ttu-id="35e78-193">在处理来自 Web 请求的不受信任的输入时，请注意防范跨站脚本 (XSS) 攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-193">When working with untrusted input from web requests, be mindful of cross-site scripting (XSS) attacks.</span></span> <span data-ttu-id="35e78-194">XSS 攻击会将不受信任的输入注入原始 HTML 输出，使攻击者可以执行恶意脚本或恶意修改网页中的内容。</span><span class="sxs-lookup"><span data-stu-id="35e78-194">An XSS attack injects untrusted input into raw HTML output, allowing the attacker to execute malicious scripts or maliciously modify content in your web page.</span></span>|
|[<span data-ttu-id="35e78-195">CA3003:查看文件路径注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-195">CA3003: Review code for file path injection vulnerabilities</span></span>](ca3003.md)|<span data-ttu-id="35e78-196">在处理来自 Web 请求的不受信任的输入时，请谨慎使用用户控制的输入指定文件路径。</span><span class="sxs-lookup"><span data-stu-id="35e78-196">When working with untrusted input from web requests, be mindful of using user-controlled input when specifying paths to files.</span></span>|
|[<span data-ttu-id="35e78-197">CA3004：查看信息泄露漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-197">CA3004: Review code for information disclosure vulnerabilities</span></span>](ca3004.md)|<span data-ttu-id="35e78-198">泄漏异常信息可让攻击者深入了解应用程序的内部机制，从而帮助攻击者找到其他漏洞并利用这些漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-198">Disclosing exception information gives attackers insight into the internals of your application, which can help attackers find other vulnerabilities to exploit.</span></span>|
|[<span data-ttu-id="35e78-199">CA3006：查看进程命令注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-199">CA3006: Review code for process command injection vulnerabilities</span></span>](ca3006.md)|<span data-ttu-id="35e78-200">处理不受信任的输入时，请注意防范命令注入攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-200">When working with untrusted input, be mindful of command injection attacks.</span></span> <span data-ttu-id="35e78-201">命令注入攻击可在基础操作系统上执行恶意命令，从而降低服务器的安全和完整性。</span><span class="sxs-lookup"><span data-stu-id="35e78-201">A command injection attack can execute malicious commands on the underlying operating system, compromising the security and integrity of your server.</span></span>|
|[<span data-ttu-id="35e78-202">CA3007：查看公开重定向漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-202">CA3007: Review code for open redirect vulnerabilities</span></span>](ca3007.md)|<span data-ttu-id="35e78-203">处理不受信任的输入时，请注意防范开放重定向漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-203">When working with untrusted input, be mindful of open redirect vulnerabilities.</span></span> <span data-ttu-id="35e78-204">攻击者可以利用开放重定向漏洞，使用你的网站提供合法 URL 的外观，但将毫不知情的访客重定向到钓鱼网页或其他恶意网页。</span><span class="sxs-lookup"><span data-stu-id="35e78-204">An attacker can exploit an open redirect vulnerability to use your website to give the appearance of a legitimate URL, but redirect an unsuspecting visitor to a phishing or other malicious webpage.</span></span>|
|[<span data-ttu-id="35e78-205">CA3008：查看 XPath 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-205">CA3008: Review code for XPath injection vulnerabilities</span></span>](ca3008.md)|<span data-ttu-id="35e78-206">处理不受信任的输入时，请注意防范 XPath 注入攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-206">When working with untrusted input, be mindful of XPath injection attacks.</span></span> <span data-ttu-id="35e78-207">使用不受信任的输入构造 XPath 查询可能会允许攻击者恶意控制查询，使其返回一个意外的结果，并可能泄漏查询的 XML 的内容。</span><span class="sxs-lookup"><span data-stu-id="35e78-207">Constructing XPath queries using untrusted input may allow an attacker to maliciously manipulate the query to return an unintended result, and possibly disclose the contents of the queried XML.</span></span>|
|[<span data-ttu-id="35e78-208">CA3009：查看 XML 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-208">CA3009: Review code for XML injection vulnerabilities</span></span>](ca3009.md)|<span data-ttu-id="35e78-209">处理不受信任的输入时，请注意防范 XML 注入攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-209">When working with untrusted input, be mindful of XML injection attacks.</span></span>|
|[<span data-ttu-id="35e78-210">CA3010：查看 XAML 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-210">CA3010: Review code for XAML injection vulnerabilities</span></span>](ca3010.md)|<span data-ttu-id="35e78-211">处理不受信任的输入时，请注意防范 XAML 注入攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-211">When working with untrusted input, be mindful of XAML injection attacks.</span></span> <span data-ttu-id="35e78-212">XAML 是一种直接表示对象实例化和执行的标记语言。</span><span class="sxs-lookup"><span data-stu-id="35e78-212">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="35e78-213">这意味着 XAML 中创建的元素可以与系统资源（例如，网络访问和文件系统 IO）交互。</span><span class="sxs-lookup"><span data-stu-id="35e78-213">That means elements created in XAML can interact with system resources (for example, network access and file system IO).</span></span>|
|[<span data-ttu-id="35e78-214">CA3011：查看 DLL 注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-214">CA3011: Review code for DLL injection vulnerabilities</span></span>](ca3011.md)|<span data-ttu-id="35e78-215">处理不受信任的输入时，请谨慎加载不受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="35e78-215">When working with untrusted input, be mindful of loading untrusted code.</span></span> <span data-ttu-id="35e78-216">如果你的 Web 应用加载不受信任的代码，攻击者可能能够将恶意 DLL 注入到你的进程中，并执行恶意代码。</span><span class="sxs-lookup"><span data-stu-id="35e78-216">If your web application loads untrusted code, an attacker may be able to inject malicious DLLs into your process and execute malicious code.</span></span>|
|[<span data-ttu-id="35e78-217">CA3012：查看正则表达式注入漏洞的代码</span><span class="sxs-lookup"><span data-stu-id="35e78-217">CA3012: Review code for regex injection vulnerabilities</span></span>](ca3012.md)|<span data-ttu-id="35e78-218">处理不受信任的输入时，请注意防范正则表达式注入攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-218">When working with untrusted input, be mindful of regex injection attacks.</span></span> <span data-ttu-id="35e78-219">攻击者可以使用正则表达式注入恶意修改正则表达式，让正则表达式匹配非预期结果，或者让正则表达式占用过多 CPU，从而形成拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-219">An attacker can use regex injection to maliciously modify a regular expression, to make the regex match unintended results, or to make the regex consume excessive CPU resulting in a Denial of Service attack.</span></span>|
|[<span data-ttu-id="35e78-220">CA3061：请勿按 URL 添加架构</span><span class="sxs-lookup"><span data-stu-id="35e78-220">CA3061: Do not add schema by URL</span></span>](ca3061.md)|<span data-ttu-id="35e78-221">请勿使用不安全的“添加”方法重载，因为这可能会导致危险的外部引用。</span><span class="sxs-lookup"><span data-stu-id="35e78-221">Do not use the unsafe overload of the Add method because it may cause dangerous external references.</span></span>|
|[<span data-ttu-id="35e78-222">CA3075:不安全的 DTD 处理</span><span class="sxs-lookup"><span data-stu-id="35e78-222">CA3075: Insecure DTD Processing</span></span>](ca3075.md)|<span data-ttu-id="35e78-223">如果使用不安全的 DTDProcessing 实例或引用外部实体源，分析器可能会接受不受信任的输入并将敏感信息泄露给攻击者。</span><span class="sxs-lookup"><span data-stu-id="35e78-223">If you use insecure DTDProcessing instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.</span></span>|
|[<span data-ttu-id="35e78-224">CA3076:不安全的 XSLT 脚本执行</span><span class="sxs-lookup"><span data-stu-id="35e78-224">CA3076: Insecure XSLT Script Execution</span></span>](ca3076.md)|<span data-ttu-id="35e78-225">如果在 .NET 应用程序中不安全地执行可扩展样式表语言转换 (XSLT)，处理器可能会解析不受信任的 URI 引用，这种引用会把敏感信息泄露给攻击者，从而导致拒绝服务和跨站点攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-225">If you execute Extensible StyleSheet Language Transformations (XSLT) in .NET applications insecurely, the processor may resolve untrusted URI references that could disclose sensitive information to attackers, leading to Denial of Service and Cross-Site attacks.</span></span>|
|[<span data-ttu-id="35e78-226">CA3077:API 设计、XML 文档和 XML 文本读取器中的不安全处理</span><span class="sxs-lookup"><span data-stu-id="35e78-226">CA3077: Insecure Processing in API Design, XML Document and XML Text Reader</span></span>](ca3077.md)|<span data-ttu-id="35e78-227">当设计派生自 XMLDocument 和 XMLTextReader 的 API 时，请注意 DtdProcessing。</span><span class="sxs-lookup"><span data-stu-id="35e78-227">When designing an API derived from XMLDocument and XMLTextReader, be mindful of DtdProcessing.</span></span> <span data-ttu-id="35e78-228">当引用或解析外部实体源或设置 XML 中的不安全值时，使用不安全的 DTDProcessing 实例可能会导致信息泄露。</span><span class="sxs-lookup"><span data-stu-id="35e78-228">Using insecure DTDProcessing instances when referencing or resolving external entity sources or setting insecure values in the XML may lead to information disclosure.</span></span>|
|[<span data-ttu-id="35e78-229">CA3147:使用 ValidateAntiForgeryToken 标记谓词处理程序</span><span class="sxs-lookup"><span data-stu-id="35e78-229">CA3147: Mark verb handlers with ValidateAntiForgeryToken</span></span>](ca3147.md)|<span data-ttu-id="35e78-230">设计 ASP.NET MVC 控制器时，请注意防范跨网站请求伪造攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-230">When designing an ASP.NET MVC controller, be mindful of cross-site request forgery attacks.</span></span> <span data-ttu-id="35e78-231">跨网站请求伪造攻击可将来自经过身份验证的用户的恶意请求发送到 ASP.NET MVC 控制器。</span><span class="sxs-lookup"><span data-stu-id="35e78-231">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET MVC controller.</span></span>|
|[<span data-ttu-id="35e78-232">CA5350:请勿使用弱加密算法</span><span class="sxs-lookup"><span data-stu-id="35e78-232">CA5350: Do Not Use Weak Cryptographic Algorithms</span></span>](ca5350.md)|<span data-ttu-id="35e78-233">出于多种原因，现今使用弱加密算法和哈希函数，但不应使用它们来保证保密性或它们所保护的数据的完整性。</span><span class="sxs-lookup"><span data-stu-id="35e78-233">Weak encryption algorithms and hashing functions are used today for a number of reasons, but they should not be used to guarantee the confidentiality or integrity of the data they protect.</span></span> <span data-ttu-id="35e78-234">当此规则在代码中找到 TripleDES、SHA1、或 RIPEMD160 算法时，此规则将触发。</span><span class="sxs-lookup"><span data-stu-id="35e78-234">This rule triggers when it finds TripleDES, SHA1, or RIPEMD160 algorithms in the code.</span></span>|
|[<span data-ttu-id="35e78-235">CA5351：请勿使用已损坏的加密算法</span><span class="sxs-lookup"><span data-stu-id="35e78-235">CA5351: Do Not Use Broken Cryptographic Algorithms</span></span>](ca5351.md)|<span data-ttu-id="35e78-236">损坏的加密算法不安全，强烈建议不要使用。</span><span class="sxs-lookup"><span data-stu-id="35e78-236">Broken cryptographic algorithms are not considered secure and their use should be strongly discouraged.</span></span> <span data-ttu-id="35e78-237">当此规则在代码中找到 MD5 哈希算法，或者 DES 或 RC2 加密算法时，此规则将触发。</span><span class="sxs-lookup"><span data-stu-id="35e78-237">This rule triggers when it finds the MD5 hash algorithm or either the DES or RC2 encryption algorithms in code.</span></span>|
|[<span data-ttu-id="35e78-238">CA5358：请勿使用不安全的密码模式</span><span class="sxs-lookup"><span data-stu-id="35e78-238">CA5358: Do Not Use Unsafe Cipher Modes</span></span>](ca5358.md)|<span data-ttu-id="35e78-239">请勿使用不安全的密码模式</span><span class="sxs-lookup"><span data-stu-id="35e78-239">Do Not Use Unsafe Cipher Modes</span></span>|
|[<span data-ttu-id="35e78-240">CA5359:请勿禁用证书验证</span><span class="sxs-lookup"><span data-stu-id="35e78-240">CA5359: Do not disable certificate validation</span></span>](ca5359.md)|<span data-ttu-id="35e78-241">证书有助于对服务器的身份进行验证。</span><span class="sxs-lookup"><span data-stu-id="35e78-241">A certificate can help authenticate the identity of the server.</span></span> <span data-ttu-id="35e78-242">客户端应验证服务器证书，确保将请求发送到目标服务器。</span><span class="sxs-lookup"><span data-stu-id="35e78-242">Clients should validate the server certificate to ensure requests are sent to the intended server.</span></span> <span data-ttu-id="35e78-243">如果 ServerCertificateValidationCallback 始终返回 `true`，那么任何证书都将通过验证。</span><span class="sxs-lookup"><span data-stu-id="35e78-243">If the ServerCertificateValidationCallback always returns `true`, any certificate will pass validation.</span></span>|
|[<span data-ttu-id="35e78-244">CA5360:在反序列化中不要调用危险的方法</span><span class="sxs-lookup"><span data-stu-id="35e78-244">CA5360: Do not call dangerous methods in deserialization</span></span>](ca5360.md)|<span data-ttu-id="35e78-245">不安全的反序列化是一种漏洞。当使用不受信任的数据来损害应用程序的逻辑，造成拒绝服务 (DoS) 攻击，或甚至在反序列化时任意执行代码，就会出现该漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-245">Insecure deserialization is a vulnerability that occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized.</span></span> <span data-ttu-id="35e78-246">应用程序对受其控制的不受信任的数据进行反序列化时，恶意用户很可能会滥用这些反序列化功能。</span><span class="sxs-lookup"><span data-stu-id="35e78-246">It's frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data that is under their control.</span></span> <span data-ttu-id="35e78-247">具体来说，就是在反序列化过程中调用危险方法。</span><span class="sxs-lookup"><span data-stu-id="35e78-247">Specifically, invoke dangerous methods in the process of deserialization.</span></span> <span data-ttu-id="35e78-248">如果攻击者成功执行不安全的反序列化攻击，就能实施更多攻击，如 DoS 攻击、绕过身份验证和执行远程代码。</span><span class="sxs-lookup"><span data-stu-id="35e78-248">Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</span></span>|
|[<span data-ttu-id="35e78-249">CA5361：不禁用较强加密的 SChannel 使用</span><span class="sxs-lookup"><span data-stu-id="35e78-249">CA5361: Do not disable SChannel use of strong crypto</span></span>](ca5361.md)|<span data-ttu-id="35e78-250">将 `Switch.System.Net.DontEnableSchUseStrongCrypto` 设置为 `true` 会减弱传出的传输层安全性连接中使用的加密性。</span><span class="sxs-lookup"><span data-stu-id="35e78-250">Setting `Switch.System.Net.DontEnableSchUseStrongCrypto` to `true` weakens the cryptography used in outgoing Transport Layer Security (TLS) connections.</span></span> <span data-ttu-id="35e78-251">较弱的加密性会泄露应用程序与服务器之间通信的机密性，使攻击者更易于窃听敏感数据。</span><span class="sxs-lookup"><span data-stu-id="35e78-251">Weaker cryptography can compromise the confidentiality of communication between your application and the server, making it easier for attackers to eavesdrop sensitive data.</span></span>|
|[<span data-ttu-id="35e78-252">CA5362:反序列化对象图中存在潜在引用循环</span><span class="sxs-lookup"><span data-stu-id="35e78-252">CA5362: Potential reference cycle in deserialized object graph</span></span>](ca5362.md)|<span data-ttu-id="35e78-253">反序列化不受信任的数据时，处理反序列化对象图的任何代码都需要在处理引用循环时不进入无限循环。</span><span class="sxs-lookup"><span data-stu-id="35e78-253">If deserializing untrusted data, then any code processing the deserialized object graph needs to handle reference cycles without going into infinite loops.</span></span> <span data-ttu-id="35e78-254">这包括反序列化回叫中的一部分代码和在反序列化完成后处理对象图的代码。</span><span class="sxs-lookup"><span data-stu-id="35e78-254">This includes both code that's part of a deserialization callback and code that processes the object graph after deserialization completed.</span></span> <span data-ttu-id="35e78-255">否则攻击者可能会利用带有包含引用循环的恶意数据执行拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-255">Otherwise, an attacker could perform a Denial-of-Service attack with malicious data containing a reference cycle.</span></span>|
|[<span data-ttu-id="35e78-256">CA5363：请勿禁用请求验证</span><span class="sxs-lookup"><span data-stu-id="35e78-256">CA5363: Do not disable request validation</span></span>](ca5363.md)|<span data-ttu-id="35e78-257">请求验证是 ASP.NET 中的一项功能，可检查 HTTP 请求并确定这些请求是否包含可能导致跨站点脚本编写等注入攻击的潜在危险内容。</span><span class="sxs-lookup"><span data-stu-id="35e78-257">Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content that can lead to injection attacks, including cross-site-scripting.</span></span>|
|[<span data-ttu-id="35e78-258">CA5364：不使用已弃用的安全协议</span><span class="sxs-lookup"><span data-stu-id="35e78-258">CA5364: Do not use deprecated security protocols</span></span>](ca5364.md)|<span data-ttu-id="35e78-259">传输层安全性 (TLS) 通常使用超文本传输协议安全 (HTTPS) 保障计算机之间的通信安全。</span><span class="sxs-lookup"><span data-stu-id="35e78-259">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="35e78-260">早期版本的 TLS 协议不如 TLS 1.2 和 TLS 1.3 安全，且更容易出现新的漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-260">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="35e78-261">避免使用旧版本的协议，以便最大程度降低风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-261">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="35e78-262">CA5365:请勿禁用 HTTP 头检查</span><span class="sxs-lookup"><span data-stu-id="35e78-262">CA5365: Do Not Disable HTTP Header Checking</span></span>](ca5365.md)|<span data-ttu-id="35e78-263">通过 HTTP 标头检查，可对在响应头中找到的回车符和换行符（\r 和 \n）进行编码。</span><span class="sxs-lookup"><span data-stu-id="35e78-263">HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers.</span></span> <span data-ttu-id="35e78-264">此编码有助于避免注入攻击，这些注入攻击会攻击对标头包含的不受信数据进行回显的应用程序。</span><span class="sxs-lookup"><span data-stu-id="35e78-264">This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</span></span>|
|[<span data-ttu-id="35e78-265">CA5366:将 XmlReader 用于数据集读取 XML</span><span class="sxs-lookup"><span data-stu-id="35e78-265">CA5366: Use XmlReader For DataSet Read XML</span></span>](ca5366.md)|<span data-ttu-id="35e78-266">使用 <xref:System.Data.DataSet> 读取包含不受信数据的 XML，可能会加载危险的外部引用，应使用具有安全解析程序或禁用了 DTD 处理的 <xref:System.Xml.XmlReader> 来限制这种行为。</span><span class="sxs-lookup"><span data-stu-id="35e78-266">Using a <xref:System.Data.DataSet> to read XML with untrusted data may load dangerous external references, which should be restricted by using an <xref:System.Xml.XmlReader> with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="35e78-267">CA5367:请勿序列化具有 Pointer 字段的类型</span><span class="sxs-lookup"><span data-stu-id="35e78-267">CA5367: Do Not Serialize Types With Pointer Fields</span></span>](ca5367.md)|<span data-ttu-id="35e78-268">此规则检查是否存在带有指针字段或属性的可序列化类。</span><span class="sxs-lookup"><span data-stu-id="35e78-268">This rule checks whether there's a serializable class with a pointer field or property.</span></span> <span data-ttu-id="35e78-269">无法进行序列化的成员可能是指针，例如使用 <xref:System.NonSerializedAttribute> 进行标记的静态成员或字段。</span><span class="sxs-lookup"><span data-stu-id="35e78-269">Members that can't be serialized can be a pointer, such as static members or fields marked with <xref:System.NonSerializedAttribute>.</span></span>|
|[<span data-ttu-id="35e78-270">CA5368:针对派生自 Page 的类设置 ViewStateUserKey</span><span class="sxs-lookup"><span data-stu-id="35e78-270">CA5368: Set ViewStateUserKey For Classes Derived From Page</span></span>](ca5368.md)|<span data-ttu-id="35e78-271">设置 <xref:System.Web.UI.Page.ViewStateUserKey> 属性有助于防止对应用程序的攻击，方法是允许你为各个用户的视图状态变量分配标识符，这样攻击者就无法使用变量生成攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-271">Setting the <xref:System.Web.UI.Page.ViewStateUserKey> property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that attackers cannot use the variable to generate an attack.</span></span> <span data-ttu-id="35e78-272">否则会出现“跨网站请求伪造”漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-272">Otherwise, there will be vulnerabilities to cross-site request forgery.</span></span>|
|[<span data-ttu-id="35e78-273">CA5369：将 XmlReader 用于反序列化</span><span class="sxs-lookup"><span data-stu-id="35e78-273">CA5369: Use XmlReader for Deserialize</span></span>](ca5369.md)|<span data-ttu-id="35e78-274">处理不受信任的 DTD 和 XML 架构时可能会加载危险的外部引用，应使用具有安全解析程序或禁用了 DTD 和 XML 内联架构处理的 XmlReader 来限制这种行为。</span><span class="sxs-lookup"><span data-stu-id="35e78-274">Processing untrusted DTD and XML schemas may enable loading dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="35e78-275">CA5370：将 XmlReader 用于验证读取器</span><span class="sxs-lookup"><span data-stu-id="35e78-275">CA5370: Use XmlReader for validating reader</span></span>](ca5370.md)|<span data-ttu-id="35e78-276">处理不受信任的 DTD 和 XML 架构时可能会加载危险的外部引用。</span><span class="sxs-lookup"><span data-stu-id="35e78-276">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="35e78-277">此危险的加载行为可使用具有安全解析程序或者禁用了 DTD 和 XML 内联架构处理的 XmlReader 来进行限制。</span><span class="sxs-lookup"><span data-stu-id="35e78-277">This dangerous loading can be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="35e78-278">CA5371：将 XmlReader 用于架构读取</span><span class="sxs-lookup"><span data-stu-id="35e78-278">CA5371: Use XmlReader for schema read</span></span>](ca5371.md)|<span data-ttu-id="35e78-279">处理不受信任的 DTD 和 XML 架构时可能会加载危险的外部引用。</span><span class="sxs-lookup"><span data-stu-id="35e78-279">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="35e78-280">请使用具有安全解析程序或者禁用了 DTD 和 XML 内联架构处理的 XmlReader 对其进行限制。</span><span class="sxs-lookup"><span data-stu-id="35e78-280">Using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled restricts this.</span></span>|
|[<span data-ttu-id="35e78-281">CA5372：将 XmlReader 用于 XPathDocument</span><span class="sxs-lookup"><span data-stu-id="35e78-281">CA5372: Use XmlReader for XPathDocument</span></span>](ca5372.md)|<span data-ttu-id="35e78-282">处理来自不受信任的数据的 XML 时可能会加载危险的外部引用，可使用具有安全解析程序或禁用了 DTD 处理的 XmlReader 对其进行限制。</span><span class="sxs-lookup"><span data-stu-id="35e78-282">Processing XML from untrusted data may load dangerous external references, which can be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="35e78-283">CA5373：请勿使用已过时的密钥派生功能</span><span class="sxs-lookup"><span data-stu-id="35e78-283">CA5373: Do not use obsolete key derivation function</span></span>](ca5373.md)|<span data-ttu-id="35e78-284">此规则会检测对弱密钥派生方法 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> 和 `Rfc2898DeriveBytes.CryptDeriveKey` 的调用。</span><span class="sxs-lookup"><span data-stu-id="35e78-284">This rule detects the invocation of weak key derivation methods <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> and `Rfc2898DeriveBytes.CryptDeriveKey`.</span></span> <span data-ttu-id="35e78-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> 使用了弱算法 PBKDF1。</span><span class="sxs-lookup"><span data-stu-id="35e78-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> used a weak algorithm PBKDF1.</span></span>|
|[<span data-ttu-id="35e78-286">CA5374:请勿使用 XslTransform</span><span class="sxs-lookup"><span data-stu-id="35e78-286">CA5374: Do Not Use XslTransform</span></span>](ca5374.md)|<span data-ttu-id="35e78-287">此规则检查 <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 是否在代码中进行了实例化。</span><span class="sxs-lookup"><span data-stu-id="35e78-287">This rule checks if <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is instantiated in the code.</span></span> <span data-ttu-id="35e78-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 现已过时且不应使用。</span><span class="sxs-lookup"><span data-stu-id="35e78-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is now obsolete and shouldn't be used.</span></span>|
|[<span data-ttu-id="35e78-289">CA5375:请勿使用帐户共享访问签名</span><span class="sxs-lookup"><span data-stu-id="35e78-289">CA5375: Do not use account shared access signature</span></span>](ca5375.md)|<span data-ttu-id="35e78-290">帐户 SAS 可以委派对 blob 容器、表、队列和文件共享执行读取、写入和删除操作的访问权限，而这是服务 SAS 所不允许的。</span><span class="sxs-lookup"><span data-stu-id="35e78-290">An account SAS can delegate access to read, write, and delete operations on blob containers, tables, queues, and file shares that are not permitted with a service SAS.</span></span> <span data-ttu-id="35e78-291">但是它不支持容器级别的策略，并且其灵活性和对授予的权限的控制力更低。</span><span class="sxs-lookup"><span data-stu-id="35e78-291">However, it doesn't support container-level policies and has less flexibility and control over the permissions that are granted.</span></span> <span data-ttu-id="35e78-292">一旦恶意用户获取它后，存储帐户的信息很容易泄露。</span><span class="sxs-lookup"><span data-stu-id="35e78-292">Once malicious users get it, your storage account will be compromised easily.</span></span>|
|[<span data-ttu-id="35e78-293">CA5376:使用 SharedAccessProtocol HttpsOnly</span><span class="sxs-lookup"><span data-stu-id="35e78-293">CA5376: Use SharedAccessProtocol HttpsOnly</span></span>](ca5376.md)|<span data-ttu-id="35e78-294">SAS 是无法在 HTTP 上以纯文本形式传输的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="35e78-294">SAS is sensitive data that can't be transported in plain text on HTTP.</span></span>|
|[<span data-ttu-id="35e78-295">CA5377:使用容器级别访问策略</span><span class="sxs-lookup"><span data-stu-id="35e78-295">CA5377: Use container level access policy</span></span>](ca5377.md)|<span data-ttu-id="35e78-296">容器级别的访问策略可以随时修改或撤销。</span><span class="sxs-lookup"><span data-stu-id="35e78-296">A container-level access policy can be modified or revoked at any time.</span></span> <span data-ttu-id="35e78-297">它具有更高的灵活性，对授予的权限的控制力更强。</span><span class="sxs-lookup"><span data-stu-id="35e78-297">It provides greater flexibility and control over the permissions that are granted.</span></span>|
|[<span data-ttu-id="35e78-298">CA5378：不禁用 ServicePointManagerSecurityProtocols</span><span class="sxs-lookup"><span data-stu-id="35e78-298">CA5378: Do not disable ServicePointManagerSecurityProtocols</span></span>](ca5378.md)|<span data-ttu-id="35e78-299">将 `DisableUsingServicePointManagerSecurityProtocols` 设置为 `true` 会将 Windows Communication Framework (WCF) 的传输层安全性 (TLS) 连接限制为使用 TLS 1.0。</span><span class="sxs-lookup"><span data-stu-id="35e78-299">Setting `DisableUsingServicePointManagerSecurityProtocols` to `true` limits Windows Communication Framework's (WCF) Transport Layer Security (TLS) connections to using TLS 1.0.</span></span> <span data-ttu-id="35e78-300">该版本的 TLS 将被弃用。</span><span class="sxs-lookup"><span data-stu-id="35e78-300">That version of TLS will be deprecated.</span></span>|
|[<span data-ttu-id="35e78-301">CA5379：确保密钥派生功能算法足够强</span><span class="sxs-lookup"><span data-stu-id="35e78-301">CA5379: Ensure key derivation function algorithm is sufficiently strong</span></span>](ca5379.md)|<span data-ttu-id="35e78-302"><xref:System.Security.Cryptography.Rfc2898DeriveBytes> 类默认使用 <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> 算法。</span><span class="sxs-lookup"><span data-stu-id="35e78-302">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class defaults to using the <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorithm.</span></span> <span data-ttu-id="35e78-303">应指定在 <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> 或更高版本的构造函数的某些重载中使用哈希算法。</span><span class="sxs-lookup"><span data-stu-id="35e78-303">You should specify the hash algorithm to use in some overloads of the constructor with <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> or higher.</span></span> <span data-ttu-id="35e78-304">请注意，<xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> 属性只具有 `get` 访问器，而没有 `overriden` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="35e78-304">Note, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> property only has a `get` accessor and doesn't have a `overriden` modifier.</span></span>|
|[<span data-ttu-id="35e78-305">CA5380：请勿将证书添加到根存储中</span><span class="sxs-lookup"><span data-stu-id="35e78-305">CA5380: Do not add certificates to root store</span></span>](ca5380.md)|<span data-ttu-id="35e78-306">此规则会对将证书添加到“受信任的根证书颁发机构”证书存储的代码进行检测。</span><span class="sxs-lookup"><span data-stu-id="35e78-306">This rule detects code that adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="35e78-307">默认情况下，“受信任的根证书颁发机构”证书存储配置有一组符合 Microsoft 根证书计划要求的公共 CA。</span><span class="sxs-lookup"><span data-stu-id="35e78-307">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="35e78-308">CA5381：请确保证书未添加到根存储中</span><span class="sxs-lookup"><span data-stu-id="35e78-308">CA5381: Ensure certificates are not added to root store</span></span>](ca5381.md)|<span data-ttu-id="35e78-309">此规则会对可能将证书添加到“受信任的根证书颁发机构”证书存储的代码进行检测。</span><span class="sxs-lookup"><span data-stu-id="35e78-309">This rule detects code that potentially adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="35e78-310">默认情况下，“受信任的根证书颁发机构”证书存储配置有一组符合 Microsoft 根证书计划要求的公共证书颁发机构 (CA)。</span><span class="sxs-lookup"><span data-stu-id="35e78-310">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public certification authorities (CAs) that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="35e78-311">CA5382:在 ASP.NET Core 中使用安全 Cookie</span><span class="sxs-lookup"><span data-stu-id="35e78-311">CA5382: Use secure cookies in ASP.NET Core</span></span>](ca5382.md)|<span data-ttu-id="35e78-312">HTTPS 上可用的应用程序必须使用安全 Cookie，这会向浏览器指示，Cookie 只能使用传输层安全性 (TLS) 进行传输。</span><span class="sxs-lookup"><span data-stu-id="35e78-312">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="35e78-313">CA5383:确保在 ASP.NET Core 中使用安全 Cookie</span><span class="sxs-lookup"><span data-stu-id="35e78-313">CA5383: Ensure use secure cookies in ASP.NET Core</span></span>](ca5383.md)|<span data-ttu-id="35e78-314">HTTPS 上可用的应用程序必须使用安全 Cookie，这会向浏览器指示，Cookie 只能使用传输层安全性 (TLS) 进行传输。</span><span class="sxs-lookup"><span data-stu-id="35e78-314">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="35e78-315">CA5384:不使用数字签名算法(DSA)</span><span class="sxs-lookup"><span data-stu-id="35e78-315">CA5384: Do not use digital signature algorithm (DSA)</span></span>](ca5384.md)|<span data-ttu-id="35e78-316">DSA 是一种弱非对称加密算法。</span><span class="sxs-lookup"><span data-stu-id="35e78-316">DSA is a weak asymmetric encryption algorithm.</span></span>|
|[<span data-ttu-id="35e78-317">CA5385:设置具有足够密钥大小的 Rivest–Shamir–Adleman (RSA)算法</span><span class="sxs-lookup"><span data-stu-id="35e78-317">CA5385: Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size</span></span>](ca5385.md)|<span data-ttu-id="35e78-318">小于 2048 位的 RSA 密钥更容易受到暴力攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-318">An RSA key smaller than 2048 bits is more vulnerable to brute force attacks.</span></span>|
|[<span data-ttu-id="35e78-319">CA5386：避免对 SecurityProtocolType 值进行硬编码</span><span class="sxs-lookup"><span data-stu-id="35e78-319">CA5386: Avoid hardcoding SecurityProtocolType value</span></span>](ca5386.md)|<span data-ttu-id="35e78-320">传输层安全性 (TLS) 通常使用安全超文本传输协议 (HTTPS) 保障计算机之间的通信安全。</span><span class="sxs-lookup"><span data-stu-id="35e78-320">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="35e78-321">协议版本 TLS 1.0 和 TLS 1.1 已弃用，目前使用 TLS 1.2 和 TLS 1.3。</span><span class="sxs-lookup"><span data-stu-id="35e78-321">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="35e78-322">TLS 1.2 和 TLS 1.3 将来可能也会弃用。</span><span class="sxs-lookup"><span data-stu-id="35e78-322">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="35e78-323">要确保应用程序的安全性，请避免对协议版本进行硬编码，并且至少以 .NET Framework v4.7.1 为目标。</span><span class="sxs-lookup"><span data-stu-id="35e78-323">To ensure that your application remains secure, avoid hardcoding a protocol version and target at least .NET Framework v4.7.1.</span></span>|
|[<span data-ttu-id="35e78-324">CA5387:请勿使用迭代计数不足的弱密钥派生功能</span><span class="sxs-lookup"><span data-stu-id="35e78-324">CA5387: Do not use weak key derivation function with insufficient iteration count</span></span>](ca5387.md)|<span data-ttu-id="35e78-325">此规则检查加密密钥是否由迭代计数小于 100,000 的 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 生成。</span><span class="sxs-lookup"><span data-stu-id="35e78-325">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count of less than 100,000.</span></span> <span data-ttu-id="35e78-326">迭代计数较高有助于缓解尝试猜测已生成的加密密钥的字典攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-326">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="35e78-327">CA5388:使用弱密钥派生功能时，请确保迭代计数足够大</span><span class="sxs-lookup"><span data-stu-id="35e78-327">CA5388: Ensure sufficient iteration count when using weak key derivation function</span></span>](ca5388.md)|<span data-ttu-id="35e78-328">此规则检查加密密钥是否由迭代计数可能小于 100,000 的 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 生成。</span><span class="sxs-lookup"><span data-stu-id="35e78-328">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count that may be less than 100,000.</span></span> <span data-ttu-id="35e78-329">迭代计数较高有助于缓解尝试猜测已生成的加密密钥的字典攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-329">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="35e78-330">CA5389：请勿将存档项的路径添加到目标文件系统路径中</span><span class="sxs-lookup"><span data-stu-id="35e78-330">CA5389: Do not add archive item's path to the target file system path</span></span>](ca5389.md)|<span data-ttu-id="35e78-331">文件路径可以是相对的，并且可能导致文件系统访问预期文件系统目标路径以外的内容，从而导致攻击者通过“布局和等待”技术恶意更改配置和执行远程代码。</span><span class="sxs-lookup"><span data-stu-id="35e78-331">File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</span></span>|
|[<span data-ttu-id="35e78-332">CA5390:请勿编码加密密钥</span><span class="sxs-lookup"><span data-stu-id="35e78-332">CA5390: Do not hard-code encryption key</span></span>](ca5390.md)|<span data-ttu-id="35e78-333">要成功使用对称算法，密钥必须只有发送方和接收方知道。</span><span class="sxs-lookup"><span data-stu-id="35e78-333">For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver.</span></span> <span data-ttu-id="35e78-334">如果密钥是硬编码的，就容易被发现。</span><span class="sxs-lookup"><span data-stu-id="35e78-334">When a key is hard-coded, it is easily discovered.</span></span> <span data-ttu-id="35e78-335">即使使用编译的二进制文件，恶意用户也容易将其提取出来。</span><span class="sxs-lookup"><span data-stu-id="35e78-335">Even with compiled binaries, it is easy for malicious users to extract it.</span></span> <span data-ttu-id="35e78-336">私钥泄露后，密码文本可直接被解密并且不再受保护。</span><span class="sxs-lookup"><span data-stu-id="35e78-336">Once the private key is compromised, the cipher text can be decrypted directly and is not protected anymore.</span></span>|
|[<span data-ttu-id="35e78-337">CA5391:在 ASP.NET Core MVC 控制器中使用防伪造令牌</span><span class="sxs-lookup"><span data-stu-id="35e78-337">CA5391: Use antiforgery tokens in ASP.NET Core MVC controllers</span></span>](ca5391.md)|<span data-ttu-id="35e78-338">处理 `POST`、`PUT`、`PATCH` 或 `DELETE` 请求而不验证防伪造令牌可能易受到跨网站请求伪造攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-338">Handling a `POST`, `PUT`, `PATCH`, or `DELETE` request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks.</span></span> <span data-ttu-id="35e78-339">跨网站请求伪造攻击可将经过身份验证的用户的恶意请求发送到 ASP.NET Core MVC 控制器。</span><span class="sxs-lookup"><span data-stu-id="35e78-339">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</span></span>|
|[<span data-ttu-id="35e78-340">CA5392:对 P/Invoke 使用 DefaultDllImportSearchPaths 属性</span><span class="sxs-lookup"><span data-stu-id="35e78-340">CA5392: Use DefaultDllImportSearchPaths attribute for P/Invokes</span></span>](ca5392.md)|<span data-ttu-id="35e78-341">默认情况下，使用 <xref:System.Runtime.InteropServices.DllImportAttribute> 的 P/Invoke 函数会探测大量目录，包括要加载的库的当前工作目录。</span><span class="sxs-lookup"><span data-stu-id="35e78-341">By default, P/Invoke functions using <xref:System.Runtime.InteropServices.DllImportAttribute> probe a number of directories, including the current working directory for the library to load.</span></span> <span data-ttu-id="35e78-342">这对于某些应用程序来说是一个安全隐患，会导致 DLL 劫持。</span><span class="sxs-lookup"><span data-stu-id="35e78-342">This can be a security issue for certain applications, leading to DLL hijacking.</span></span>|
|[<span data-ttu-id="35e78-343">CA5393:请勿使用不安全的 DllImportSearchPath 值</span><span class="sxs-lookup"><span data-stu-id="35e78-343">CA5393: Do not use unsafe DllImportSearchPath value</span></span>](ca5393.md)|<span data-ttu-id="35e78-344">默认的 DLL 搜索目录和程序集目录中可能存在恶意 DLL。</span><span class="sxs-lookup"><span data-stu-id="35e78-344">There could be a malicious DLL in the default DLL search directories and assembly directories.</span></span> <span data-ttu-id="35e78-345">或者根据应用程序运行的位置，应用程序的目录中可能存在恶意 DLL。</span><span class="sxs-lookup"><span data-stu-id="35e78-345">Or, depending on where your application is run from, there could be a malicious DLL in the application's directory.</span></span>|
|[<span data-ttu-id="35e78-346">CA5394:请勿使用不安全的随机性</span><span class="sxs-lookup"><span data-stu-id="35e78-346">CA5394: Do not use insecure randomness</span></span>](ca5394.md)|<span data-ttu-id="35e78-347">如果使用加密较弱的伪随机数生成器，攻击者可以预测将要生成的安全敏感值。</span><span class="sxs-lookup"><span data-stu-id="35e78-347">Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated.</span></span>|
|[<span data-ttu-id="35e78-348">CA5395:缺少操作方法的 HttpVerb 属性</span><span class="sxs-lookup"><span data-stu-id="35e78-348">CA5395: Miss HttpVerb attribute for action methods</span></span>](ca5395.md)|<span data-ttu-id="35e78-349">创建、编辑或以其它方式修改数据等所有操作方法都需要使用防伪特性来保护，以避免受跨网站请求伪造攻击的影响。</span><span class="sxs-lookup"><span data-stu-id="35e78-349">All the action methods that create, edit, delete, or otherwise modify data needs to be protected with the antiforgery attribute from cross-site request forgery attacks.</span></span> <span data-ttu-id="35e78-350">执行 GET 操作应是没有副作用且不会修改持久数据的安全操作。</span><span class="sxs-lookup"><span data-stu-id="35e78-350">Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</span></span>|
|[<span data-ttu-id="35e78-351">CA5396:将 HttpCookie 的 HttpOnly 设置为 true</span><span class="sxs-lookup"><span data-stu-id="35e78-351">CA5396: Set HttpOnly to true for HttpCookie</span></span>](ca5396.md)|<span data-ttu-id="35e78-352">请确保将安全敏感的 HTTP Cookie 标记为 HttpOnly，这是一个深度防御措施。</span><span class="sxs-lookup"><span data-stu-id="35e78-352">As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly.</span></span> <span data-ttu-id="35e78-353">这表明 Web 浏览器应禁止脚本访问 Cookie。</span><span class="sxs-lookup"><span data-stu-id="35e78-353">This indicates web browsers should disallow scripts from accessing the cookies.</span></span> <span data-ttu-id="35e78-354">注入恶意脚本是常见的窃取 Cookie 的方式。</span><span class="sxs-lookup"><span data-stu-id="35e78-354">Injected malicious scripts are a common way of stealing cookies.</span></span>|
|[<span data-ttu-id="35e78-355">CA5397：不使用已弃用的 SslProtocols 值</span><span class="sxs-lookup"><span data-stu-id="35e78-355">CA5397: Do not use deprecated SslProtocols values</span></span>](ca5397.md)|<span data-ttu-id="35e78-356">传输层安全性 (TLS) 通常使用安全超文本传输协议 (HTTPS) 保障计算机之间的通信安全。</span><span class="sxs-lookup"><span data-stu-id="35e78-356">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="35e78-357">早期版本的 TLS 协议不如 TLS 1.2 和 TLS 1.3 安全，且更容易出现新的漏洞。</span><span class="sxs-lookup"><span data-stu-id="35e78-357">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="35e78-358">避免使用旧版本的协议，以便最大程度降低风险。</span><span class="sxs-lookup"><span data-stu-id="35e78-358">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="35e78-359">CA5398：避免硬编码的 SslProtocols 值</span><span class="sxs-lookup"><span data-stu-id="35e78-359">CA5398: Avoid hardcoded SslProtocols values</span></span>](ca5398.md)|<span data-ttu-id="35e78-360">传输层安全性 (TLS) 通常使用安全超文本传输协议 (HTTPS) 保障计算机之间的通信安全。</span><span class="sxs-lookup"><span data-stu-id="35e78-360">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="35e78-361">协议版本 TLS 1.0 和 TLS 1.1 已弃用，目前使用 TLS 1.2 和 TLS 1.3。</span><span class="sxs-lookup"><span data-stu-id="35e78-361">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="35e78-362">将来可能也会弃用 TLS 1.2 和 TLS 1.3。</span><span class="sxs-lookup"><span data-stu-id="35e78-362">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="35e78-363">要确保应用程序的安全性，请避免对协议版本进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="35e78-363">To ensure that your application remains secure, avoid hardcoding a protocol version.</span></span>|
|[<span data-ttu-id="35e78-364">CA5399:绝对禁用 HttpClient 证书吊销列表检查</span><span class="sxs-lookup"><span data-stu-id="35e78-364">CA5399: Definitely disable HttpClient certificate revocation list check</span></span>](ca5399.md)|<span data-ttu-id="35e78-365">撤销的证书不再受信任。</span><span class="sxs-lookup"><span data-stu-id="35e78-365">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="35e78-366">攻击者可能使用它来传递某些恶意数据或窃取 HTTPS 通信中的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="35e78-366">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="35e78-367">CA5400:确保未禁用 HttpClient 证书吊销列表检查</span><span class="sxs-lookup"><span data-stu-id="35e78-367">CA5400: Ensure HttpClient certificate revocation list check is not disabled</span></span>](ca5400.md)|<span data-ttu-id="35e78-368">撤销的证书不再受信任。</span><span class="sxs-lookup"><span data-stu-id="35e78-368">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="35e78-369">攻击者可能使用它来传递某些恶意数据或窃取 HTTPS 通信中的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="35e78-369">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="35e78-370">CA5401:不要将 CreateEncryptor 与非默认 IV 结合使用</span><span class="sxs-lookup"><span data-stu-id="35e78-370">CA5401: Do not use CreateEncryptor with non-default IV</span></span>](ca5401.md)|<span data-ttu-id="35e78-371">对称加密应始终使用非可重复的初始化向量，以防止字典攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-371">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="35e78-372">CA5402:将 CreateEncryptor 与默认 IV 结合使用</span><span class="sxs-lookup"><span data-stu-id="35e78-372">CA5402: Use CreateEncryptor with the default IV</span></span>](ca5402.md)|<span data-ttu-id="35e78-373">对称加密应始终使用非可重复的初始化向量，以防止字典攻击。</span><span class="sxs-lookup"><span data-stu-id="35e78-373">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="35e78-374">CA5403：请勿硬编码证书</span><span class="sxs-lookup"><span data-stu-id="35e78-374">CA5403: Do not hard-code certificate</span></span>](ca5403.md)|<span data-ttu-id="35e78-375"><xref:System.Security.Cryptography.X509Certificates.X509Certificate> 或 <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> 构造函数的 `data` 或 `rawData` 参数是硬编码的。</span><span class="sxs-lookup"><span data-stu-id="35e78-375">The `data` or `rawData` parameter of a <xref:System.Security.Cryptography.X509Certificates.X509Certificate> or <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> constructor is hard-coded.</span></span>|
