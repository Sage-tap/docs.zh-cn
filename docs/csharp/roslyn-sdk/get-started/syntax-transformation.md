---
title: 语法转换 (Roslyn API) 入门
description: 介绍如何遍历、查询及浏览语法树。
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: f12727332256acd9bbe828b9149376080facd156
ms.sourcegitcommit: 652f62fc8f3ab6a264681b6eb5211ac7539bd115
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "105964816"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="b3600-103">语法转换入门</span><span class="sxs-lookup"><span data-stu-id="b3600-103">Get started with syntax transformation</span></span>

<span data-ttu-id="b3600-104">本教程基于[语法分析入门](syntax-analysis.md)和[语义分析入门](semantic-analysis.md)快速入门中介绍的概念和技巧。</span><span class="sxs-lookup"><span data-stu-id="b3600-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="b3600-105">如果尚未执行此操作，应在开始之前完成这些快速入门。</span><span class="sxs-lookup"><span data-stu-id="b3600-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="b3600-106">在本快速入门教程，你将了解用于创建和转换语法树的技巧。</span><span class="sxs-lookup"><span data-stu-id="b3600-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="b3600-107">结合你在前面的快速入门中了解的技巧，可以创建第一个命令行重构！</span><span class="sxs-lookup"><span data-stu-id="b3600-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="b3600-108">不可变性和 .NET 编译器平台</span><span class="sxs-lookup"><span data-stu-id="b3600-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="b3600-109">不可变性是 .NET 编译器平台的基本原则。</span><span class="sxs-lookup"><span data-stu-id="b3600-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="b3600-110">在创建不可变数据结构后，不能对其进行更改。</span><span class="sxs-lookup"><span data-stu-id="b3600-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="b3600-111">不可变数据结构可以由多个使用者同时安全地共享和分析。</span><span class="sxs-lookup"><span data-stu-id="b3600-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="b3600-112">一个使用者以不可预测的方式影响另一个使用者不存在任何风险。</span><span class="sxs-lookup"><span data-stu-id="b3600-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="b3600-113">分析器不需要锁或其他并发度量值。</span><span class="sxs-lookup"><span data-stu-id="b3600-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="b3600-114">此规则适用于语法树、编译、符号、语义模型，以及你所遇到的所有其他数据结构。</span><span class="sxs-lookup"><span data-stu-id="b3600-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="b3600-115">API 不是修改现有结构，而是基于旧结构的特定差异创建新对象。</span><span class="sxs-lookup"><span data-stu-id="b3600-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="b3600-116">将此概念应用到语法树中，以使用转换来创建新树。</span><span class="sxs-lookup"><span data-stu-id="b3600-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="b3600-117">创建和转换树</span><span class="sxs-lookup"><span data-stu-id="b3600-117">Create and transform trees</span></span>

<span data-ttu-id="b3600-118">选择两个策略之一进行语法转换。</span><span class="sxs-lookup"><span data-stu-id="b3600-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="b3600-119">当你在寻找要替换的特定节点时，或者想要在其中插入新代码的特定位置时，最好使用工厂方法。</span><span class="sxs-lookup"><span data-stu-id="b3600-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="b3600-120">当你想要扫描一个你想要替换的代码模式的整个项目时，最好使用重写工具。</span><span class="sxs-lookup"><span data-stu-id="b3600-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="b3600-121">使用工厂方法创建节点</span><span class="sxs-lookup"><span data-stu-id="b3600-121">Create nodes with factory methods</span></span>

<span data-ttu-id="b3600-122">第一个语法转换演示工厂方法。</span><span class="sxs-lookup"><span data-stu-id="b3600-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="b3600-123">将 `using System.Collections;` 语句替换为 `using System.Collections.Generic;` 语句。</span><span class="sxs-lookup"><span data-stu-id="b3600-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="b3600-124">此示例演示如何使用 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> 工厂方法创建 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3600-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="b3600-125">对于每一类节点、令牌或琐事，都有创建该类型实例的工厂方法。</span><span class="sxs-lookup"><span data-stu-id="b3600-125">For each kind of **node**, **token**, or **trivia**, there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="b3600-126">可以通过以自下而上的方式按层次结构组合节点来创建语法树。</span><span class="sxs-lookup"><span data-stu-id="b3600-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="b3600-127">然后，转换现有程序，用你所创建的新树替换现有节点。</span><span class="sxs-lookup"><span data-stu-id="b3600-127">Then, you'll transform the existing program by replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="b3600-128">启动 Visual Studio，并新建 C#“独立代码分析工具”项目。</span><span class="sxs-lookup"><span data-stu-id="b3600-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="b3600-129">在 Visual Studio 中，选择“文件”   > “新建”   > “项目”  ，显示新建项目对话框。</span><span class="sxs-lookup"><span data-stu-id="b3600-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="b3600-130">在“Visual C#” > “扩展性”下，选择“独立代码分析工具”。</span><span class="sxs-lookup"><span data-stu-id="b3600-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="b3600-131">本快速入门教程有两个示例项目，因此将解决方案命名为“SyntaxTransformationQuickStart”，并将项目命名为“ConstructionCS”。</span><span class="sxs-lookup"><span data-stu-id="b3600-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="b3600-132">单击 **“确定”** 。</span><span class="sxs-lookup"><span data-stu-id="b3600-132">Click **OK**.</span></span>

<span data-ttu-id="b3600-133">此项目使用 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> 类方法构造 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> 来表示 `System.Collections.Generic` 命名空间。</span><span class="sxs-lookup"><span data-stu-id="b3600-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="b3600-134">将以下 using 指令添加到 `Program.cs` 顶部。</span><span class="sxs-lookup"><span data-stu-id="b3600-134">Add the following using directive to the top of the `Program.cs`.</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="b3600-135">创建 **命名语法节点** 以创建表示 `using System.Collections.Generic;` 语句的树。</span><span class="sxs-lookup"><span data-stu-id="b3600-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="b3600-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> 是在 C# 中显示的四种类型名称的基类。</span><span class="sxs-lookup"><span data-stu-id="b3600-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="b3600-137">将这四种类型名称组合在一起，以创建任何可通过 C# 语言显示的名称：</span><span class="sxs-lookup"><span data-stu-id="b3600-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="b3600-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>，表示简单的单个标识符名称，如 `System` 和 `Microsoft`。</span><span class="sxs-lookup"><span data-stu-id="b3600-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="b3600-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>，表示泛型类型或方法名称，如 `List<int>`。</span><span class="sxs-lookup"><span data-stu-id="b3600-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="b3600-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>，表示窗体 `<left-name>.<right-identifier-or-generic-name>` 的限定名称，如 `System.IO`。</span><span class="sxs-lookup"><span data-stu-id="b3600-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="b3600-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>，表示使用程序集外部别名的名称，如 `LibraryV2::Foo`。</span><span class="sxs-lookup"><span data-stu-id="b3600-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="b3600-142">若要创建 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> 节点，请使用 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3600-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="b3600-143">在 `Program.cs` 的 `Main` 方法中添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="b3600-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="b3600-144">前面的代码创建 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> 对象，并将其分配给变量 `name`。</span><span class="sxs-lookup"><span data-stu-id="b3600-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="b3600-145">许多 Roslyn API 返回基类，使其更轻松地处理相关类型。</span><span class="sxs-lookup"><span data-stu-id="b3600-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="b3600-146">变量 `name`，即 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>，可以在生成 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> 时重用。</span><span class="sxs-lookup"><span data-stu-id="b3600-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="b3600-147">在生成示例时，不要使用类型推理。</span><span class="sxs-lookup"><span data-stu-id="b3600-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="b3600-148">你将自动执行此项目中的这一步。</span><span class="sxs-lookup"><span data-stu-id="b3600-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="b3600-149">你已创建名称。</span><span class="sxs-lookup"><span data-stu-id="b3600-149">You've created the name.</span></span> <span data-ttu-id="b3600-150">现在，可以通过构建 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> 在树中生成更多节点。</span><span class="sxs-lookup"><span data-stu-id="b3600-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="b3600-151">新树使用 `name` 作为左侧名称，并使用 `Collections` 命名空间新的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> 作为 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> 的右侧。</span><span class="sxs-lookup"><span data-stu-id="b3600-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="b3600-152">将下列代码添加到 `program.cs`：</span><span class="sxs-lookup"><span data-stu-id="b3600-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="b3600-153">再次运行代码并查看结果。</span><span class="sxs-lookup"><span data-stu-id="b3600-153">Run the code again, and see the results.</span></span> <span data-ttu-id="b3600-154">你将构建一个表示代码的节点树。</span><span class="sxs-lookup"><span data-stu-id="b3600-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="b3600-155">你将继续运行此模式，以便生成命名空间 `System.Collections.Generic` 的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>。</span><span class="sxs-lookup"><span data-stu-id="b3600-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="b3600-156">将下列代码添加到 `Program.cs`：</span><span class="sxs-lookup"><span data-stu-id="b3600-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="b3600-157">再次运行此程序，以查看你已为要添加的代码生成的树。</span><span class="sxs-lookup"><span data-stu-id="b3600-157">Run the program again to see that you've built the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="b3600-158">创建修改后的树</span><span class="sxs-lookup"><span data-stu-id="b3600-158">Create a modified tree</span></span>

<span data-ttu-id="b3600-159">你已构建一个小型语法树，其中包含一个语句。</span><span class="sxs-lookup"><span data-stu-id="b3600-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="b3600-160">用于创建新节点的 API 是创建单个语句或其他小代码块的正确选择。</span><span class="sxs-lookup"><span data-stu-id="b3600-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="b3600-161">但是，若要生成更大的代码块，应使用替换节点或将节点插入到现有树的方法。</span><span class="sxs-lookup"><span data-stu-id="b3600-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="b3600-162">请记住语法树不可变。</span><span class="sxs-lookup"><span data-stu-id="b3600-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="b3600-163">语法 API 不提供用于完成构造后修改现有语法树的任何机制。</span><span class="sxs-lookup"><span data-stu-id="b3600-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="b3600-164">相反，它提供基于对现有数的更改生成新树的方法。</span><span class="sxs-lookup"><span data-stu-id="b3600-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="b3600-165">`With*` 方法在派生自 <xref:Microsoft.CodeAnalysis.SyntaxNode> 的具体类中定义，或者在 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> 类中声明的扩展方法中定义。</span><span class="sxs-lookup"><span data-stu-id="b3600-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="b3600-166">这些方法通过将更改应用于现有节点的子属性来创建一个新节点。</span><span class="sxs-lookup"><span data-stu-id="b3600-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="b3600-167">此外，<xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 扩展方法可以用来替换子树中的子代节点。</span><span class="sxs-lookup"><span data-stu-id="b3600-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="b3600-168">此方法还会更新父结点，以指向新创建的子节点，并在整个树中重复这一过程，该过程称为“重新遍历树”。</span><span class="sxs-lookup"><span data-stu-id="b3600-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="b3600-169">下一步是创建一个表示整个（小型）程序的树，然后修改它。</span><span class="sxs-lookup"><span data-stu-id="b3600-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="b3600-170">将以下代码添加到 `Program` 类的开头：</span><span class="sxs-lookup"><span data-stu-id="b3600-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="b3600-171">该示例代码使用 `System.Collections` 命名空间而不是 `System.Collections.Generic` 命名空间。</span><span class="sxs-lookup"><span data-stu-id="b3600-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="b3600-172">接下来，将以下代码添加到 `Main` 方法的底部来分析文本，并创建树：</span><span class="sxs-lookup"><span data-stu-id="b3600-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="b3600-173">此示例使用 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> 方法将 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> 节点中的名称替换为在前面代码中构造的名称。</span><span class="sxs-lookup"><span data-stu-id="b3600-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="b3600-174">使用 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> 方法创建一个新的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> 节点，将 `System.Collections` 名称更新为在前面代码中创建的名称。</span><span class="sxs-lookup"><span data-stu-id="b3600-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="b3600-175">将以下代码添加到 `Main` 方法底部：</span><span class="sxs-lookup"><span data-stu-id="b3600-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="b3600-176">运行程序，并仔细查看输出。</span><span class="sxs-lookup"><span data-stu-id="b3600-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="b3600-177">`newUsing` 尚未置于根树中。</span><span class="sxs-lookup"><span data-stu-id="b3600-177">The `newUsing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="b3600-178">原始树尚未更改。</span><span class="sxs-lookup"><span data-stu-id="b3600-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="b3600-179">使用 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 扩展方法添加以下代码以创建新树。</span><span class="sxs-lookup"><span data-stu-id="b3600-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="b3600-180">新树是将现有导入替换为更新后的 `newUsing` 节点的结果。</span><span class="sxs-lookup"><span data-stu-id="b3600-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="b3600-181">将此新树分配给现有 `root` 变量：</span><span class="sxs-lookup"><span data-stu-id="b3600-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="b3600-182">再次运行程序。</span><span class="sxs-lookup"><span data-stu-id="b3600-182">Run the program again.</span></span> <span data-ttu-id="b3600-183">现在，树正确地导入了 `System.Collections.Generic` 命名空间。</span><span class="sxs-lookup"><span data-stu-id="b3600-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="b3600-184">使用 `SyntaxRewriters` 转换树</span><span class="sxs-lookup"><span data-stu-id="b3600-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="b3600-185">`With*` 和 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 方法提供了方便的方法来转换语法树的单独分支。</span><span class="sxs-lookup"><span data-stu-id="b3600-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="b3600-186"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> 类在语法树上执行多个转换。</span><span class="sxs-lookup"><span data-stu-id="b3600-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="b3600-187"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> 类是 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType> 的一个子类。</span><span class="sxs-lookup"><span data-stu-id="b3600-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b3600-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> 将转换应用于特定类型的 <xref:Microsoft.CodeAnalysis.SyntaxNode>。</span><span class="sxs-lookup"><span data-stu-id="b3600-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="b3600-189">你可以将转换应用于多个类型的 <xref:Microsoft.CodeAnalysis.SyntaxNode> 对象，只要它们显示在语法树中。</span><span class="sxs-lookup"><span data-stu-id="b3600-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="b3600-190">本快速入门教程中的第二个项目创建命令行重构，以便在可以使用类型推理的任何位置删除本地变量声明中的显式类型。</span><span class="sxs-lookup"><span data-stu-id="b3600-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="b3600-191">新建 C#“独立代码分析工具”项目。</span><span class="sxs-lookup"><span data-stu-id="b3600-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="b3600-192">在 Visual Studio 中，右键单击 `SyntaxTransformationQuickStart` 解决方案节点。</span><span class="sxs-lookup"><span data-stu-id="b3600-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="b3600-193">选择“添加” > “新项目”以显示“新项目对话框”。</span><span class="sxs-lookup"><span data-stu-id="b3600-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="b3600-194">在“Visual C#”   > “扩展性”  下，选择“独立代码分析工具”  。</span><span class="sxs-lookup"><span data-stu-id="b3600-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="b3600-195">给项目 `TransformationCS` 命名，然后单击“确定”。</span><span class="sxs-lookup"><span data-stu-id="b3600-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="b3600-196">第一步是创建一个派生自 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> 的类，以执行转换。</span><span class="sxs-lookup"><span data-stu-id="b3600-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="b3600-197">向项目添加一个新类文件。</span><span class="sxs-lookup"><span data-stu-id="b3600-197">Add a new class file to the project.</span></span> <span data-ttu-id="b3600-198">在 Visual Studio 中，依次选择“项目” > “添加类...”。在“添加新项”对话框中键入 `TypeInferenceRewriter.cs` 作为文件名。</span><span class="sxs-lookup"><span data-stu-id="b3600-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="b3600-199">使用指令将以下内容添加到 `TypeInferenceRewriter.cs` 文件：</span><span class="sxs-lookup"><span data-stu-id="b3600-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="b3600-200">接下来，使 `TypeInferenceRewriter` 类扩展 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> 类：</span><span class="sxs-lookup"><span data-stu-id="b3600-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="b3600-201">添加以下代码以声明一个私有只读字段，以保存 <xref:Microsoft.CodeAnalysis.SemanticModel> 并在构造函数中将其初始化。</span><span class="sxs-lookup"><span data-stu-id="b3600-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="b3600-202">稍后你将需要此字段以确定可以使用类型推理的位置：</span><span class="sxs-lookup"><span data-stu-id="b3600-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="b3600-203">重写 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> 方法：</span><span class="sxs-lookup"><span data-stu-id="b3600-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="b3600-204">许多 Roslyn API 声明返回类型，它们是返回的实际运行时类型的基类。</span><span class="sxs-lookup"><span data-stu-id="b3600-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="b3600-205">在许多情况下，一种类型的节点可能会被另一种节点完全替换，甚至删除。</span><span class="sxs-lookup"><span data-stu-id="b3600-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="b3600-206">在此示例中，<xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> 方法返回 <xref:Microsoft.CodeAnalysis.SyntaxNode>，而不是派生类型的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>。</span><span class="sxs-lookup"><span data-stu-id="b3600-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="b3600-207">此重写工具根据现有节点返回一个新的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>。</span><span class="sxs-lookup"><span data-stu-id="b3600-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="b3600-208">本快速入门教程处理本地变量声明。</span><span class="sxs-lookup"><span data-stu-id="b3600-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="b3600-209">你无法将其扩展到其他声明，如 `foreach` 循环、`for` 循环、LINQ 表达式和 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="b3600-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="b3600-210">此外，此重写工具仅转换最简单形式的声明：</span><span class="sxs-lookup"><span data-stu-id="b3600-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="b3600-211">如果想要自行浏览，请考虑扩展这些类型变量声明的已完成示例：</span><span class="sxs-lookup"><span data-stu-id="b3600-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="b3600-212">将以下代码添加到 `VisitLocalDeclarationStatement` 方法主体以跳过重写这些形式的声明：</span><span class="sxs-lookup"><span data-stu-id="b3600-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="b3600-213">该方法表明，通过返回未修改的 `node` 参数没有发生重写。</span><span class="sxs-lookup"><span data-stu-id="b3600-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="b3600-214">如果上述两个 `if` 表达式都为 true，则该节点表示一个可能的初始化声明。</span><span class="sxs-lookup"><span data-stu-id="b3600-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="b3600-215">添加这些语句以提取声明中指定的类型名称，并使用 <xref:Microsoft.CodeAnalysis.SemanticModel> 字段将其绑定来获取类型符号：</span><span class="sxs-lookup"><span data-stu-id="b3600-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="b3600-216">现在，添加此语句以绑定初始值设定项表达式：</span><span class="sxs-lookup"><span data-stu-id="b3600-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="b3600-217">最后，如果初始值设定项表达式的类型与指定类型相匹配，则添加以下 `if` 语句，将现有类型名称替换为 `var` 关键字：</span><span class="sxs-lookup"><span data-stu-id="b3600-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="b3600-218">此条件是必需的，因为声明可能将初始值设定项表达式转换为基类或接口。</span><span class="sxs-lookup"><span data-stu-id="b3600-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="b3600-219">如果这是需要的，则分配左侧和右侧的类型不匹配。</span><span class="sxs-lookup"><span data-stu-id="b3600-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="b3600-220">在这些情况下删除显式类型将更改程序语义。</span><span class="sxs-lookup"><span data-stu-id="b3600-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="b3600-221">`var` 指定为标识符而不是关键字，因为 `var` 是上下文关键字。</span><span class="sxs-lookup"><span data-stu-id="b3600-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="b3600-222">前导和尾随琐事（空白）从旧类型名转换为 `var` 关键字以保持垂直空白和缩进。</span><span class="sxs-lookup"><span data-stu-id="b3600-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="b3600-223">使用 `ReplaceNode`（而非 `With*`来转换 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> 更为简单，因为类型名称实际上是声明语句的孙级。</span><span class="sxs-lookup"><span data-stu-id="b3600-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="b3600-224">你已完成 `TypeInferenceRewriter`。</span><span class="sxs-lookup"><span data-stu-id="b3600-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="b3600-225">现在返回到 `Program.cs` 文件来完成该示例。</span><span class="sxs-lookup"><span data-stu-id="b3600-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="b3600-226">创建测试 <xref:Microsoft.CodeAnalysis.Compilation> 并从中获取 <xref:Microsoft.CodeAnalysis.SemanticModel>。</span><span class="sxs-lookup"><span data-stu-id="b3600-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="b3600-227">使用该 <xref:Microsoft.CodeAnalysis.SemanticModel> 尝试 `TypeInferenceRewriter`。</span><span class="sxs-lookup"><span data-stu-id="b3600-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="b3600-228">你将在最后执行此步骤。</span><span class="sxs-lookup"><span data-stu-id="b3600-228">You'll do this step last.</span></span> <span data-ttu-id="b3600-229">在此期间，声明一个表示测试编译的占位符变量：</span><span class="sxs-lookup"><span data-stu-id="b3600-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="b3600-230">暂停一段时间后，应会看到错误波形曲线，报告不存在 `CreateTestCompilation` 方法。</span><span class="sxs-lookup"><span data-stu-id="b3600-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="b3600-231">按 Ctrl+句点打开灯泡，然后按 Enter 以调用“生成方法存根(Stub)”命令。</span><span class="sxs-lookup"><span data-stu-id="b3600-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="b3600-232">此命令将在 `Program` 类中生成 `CreateTestCompilation` 方法的方法存根(Stub)。</span><span class="sxs-lookup"><span data-stu-id="b3600-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="b3600-233">稍后你将返回填写此方法：</span><span class="sxs-lookup"><span data-stu-id="b3600-233">You'll come back to fill in this method later:</span></span>

![使用中的 C# 生成方法](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="b3600-235&quot;>编写以下代码以循环访问测试 <xref:Microsoft.CodeAnalysis.Compilation> 中的每个 <xref:Microsoft.CodeAnalysis.SyntaxTree>。</span><span class=&quot;sxs-lookup&quot;><span data-stu-id=&quot;b3600-235&quot;>Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id=&quot;b3600-236&quot;>对于每一个，都使用 <xref:Microsoft.CodeAnalysis.SemanticModel> 初始化该树的新 `TypeInferenceRewriter`：</span><span class=&quot;sxs-lookup&quot;><span data-stu-id=&quot;b3600-236&quot;>For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees &quot;Iterate all the source trees in the test compilation")]

<span data-ttu-id="b3600-237">在你创建的 `foreach` 语句中，添加以下代码以在每个源树上执行转换。</span><span class="sxs-lookup"><span data-stu-id="b3600-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="b3600-238">如果进行了任何编辑，这段代码将有条件地写出新的转换树。</span><span class="sxs-lookup"><span data-stu-id="b3600-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="b3600-239">如果遇到一个或多个可以使用类型推理进行简化的本地变量声明，则重写工具应该只修改一个树：</span><span class="sxs-lookup"><span data-stu-id="b3600-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="b3600-240">应看到 `File.WriteAllText` 代码下的波形曲线。</span><span class="sxs-lookup"><span data-stu-id="b3600-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="b3600-241">选择灯泡，并添加所需的 `using System.IO;` 语句。</span><span class="sxs-lookup"><span data-stu-id="b3600-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="b3600-242">即将完成！</span><span class="sxs-lookup"><span data-stu-id="b3600-242">You're almost done!</span></span> <span data-ttu-id="b3600-243">还剩一步，即创建测试 <xref:Microsoft.CodeAnalysis.Compilation>。</span><span class="sxs-lookup"><span data-stu-id="b3600-243">There's one step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="b3600-244">因为你在本快速入门教程期间尚未使用类型推理，所以它将是一个完美的测试用例。</span><span class="sxs-lookup"><span data-stu-id="b3600-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="b3600-245">遗憾的是，从 C# 项目文件中创建编译不在本演练范围内。</span><span class="sxs-lookup"><span data-stu-id="b3600-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="b3600-246">但幸运的是，如果你已仔细按照说明进行操作，那还是有希望的。</span><span class="sxs-lookup"><span data-stu-id="b3600-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="b3600-247">将 `CreateTestCompilation` 方法的内容替换为以下代码。</span><span class="sxs-lookup"><span data-stu-id="b3600-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="b3600-248">它将创建一个与本快速入门教程所述的项目相匹配的测试编译：</span><span class="sxs-lookup"><span data-stu-id="b3600-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="b3600-249">运行项目，祈求好运吧。</span><span class="sxs-lookup"><span data-stu-id="b3600-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="b3600-250">在 Visual Studio 中，选择“调试” > “启动调试”。</span><span class="sxs-lookup"><span data-stu-id="b3600-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="b3600-251">应该会收到 Visual Studio 的提醒，指示项目中的文件已更改。</span><span class="sxs-lookup"><span data-stu-id="b3600-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="b3600-252">单击“全部同意”以重载已修改的文件。</span><span class="sxs-lookup"><span data-stu-id="b3600-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="b3600-253">检查这些文件以观察效果。</span><span class="sxs-lookup"><span data-stu-id="b3600-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="b3600-254">请注意，如果没有所有那些显式和冗余类型的说明符，代码会看起来更加简洁。</span><span class="sxs-lookup"><span data-stu-id="b3600-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="b3600-255">祝贺你！</span><span class="sxs-lookup"><span data-stu-id="b3600-255">Congratulations!</span></span> <span data-ttu-id="b3600-256">你已使用编译器 API 编写你自己的重构，以便在 C# 项目的所有文件中搜索某些语法模式、分析匹配这些模式的源代码语义，并对其进行转换。</span><span class="sxs-lookup"><span data-stu-id="b3600-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="b3600-257">现在，你已正式成为重构作者了！</span><span class="sxs-lookup"><span data-stu-id="b3600-257">You're now officially a refactoring author!</span></span>
