---
description: 用于安全性的 C# 编译器选项。 三个选项将控制签名程序集或地址空间布局。
title: C# 编译器选项 - 安全选项
ms.date: 03/12/2021
f1_keywords:
- cs.build.options
helpviewer_keywords:
- PublicSign compiler option [C#]
- DelaySign compiler option [C#]
- KeyFile compiler option [C#]
- KeyContainer compiler option [C#]
- HighEntropyVA compiler option [C#]
ms.openlocfilehash: db7b612fa2e4ddb566ac2ba5ef9e4e66c5f0b0ab
ms.sourcegitcommit: 0bb8074d524e0dcf165430b744bb143461f17026
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/15/2021
ms.locfileid: "103482406"
---
# <a name="c-compiler-options-for-security-options"></a><span data-ttu-id="76330-104">用于安全选项的 C# 编译器选项</span><span class="sxs-lookup"><span data-stu-id="76330-104">C# Compiler Options for security options</span></span>

<span data-ttu-id="76330-105">以下选项可控制编译器安全选项。</span><span class="sxs-lookup"><span data-stu-id="76330-105">The following options control compiler security options.</span></span> <span data-ttu-id="76330-106">新的 MSBuild 语法以粗体显示。</span><span class="sxs-lookup"><span data-stu-id="76330-106">The new MSBuild syntax is shown in **Bold**.</span></span> <span data-ttu-id="76330-107">旧的 csc.exe 语法以 `code style` 显示。</span><span class="sxs-lookup"><span data-stu-id="76330-107">The older *csc.exe* syntax is shown in `code style`.</span></span>

- <span data-ttu-id="76330-108">**PublicSign** / `-publicsign`：公开对程序集签名。</span><span class="sxs-lookup"><span data-stu-id="76330-108">**PublicSign** / `-publicsign`: Publicly sign the assembly.</span></span>
- <span data-ttu-id="76330-109">**DelaySign** / `-delaysign`：仅使用强名称密钥的公共部分对程序集进行延迟签名。</span><span class="sxs-lookup"><span data-stu-id="76330-109">**DelaySign** / `-delaysign`: Delay-sign the assembly using only the public portion of the strong name key.</span></span>
- <span data-ttu-id="76330-110">**KeyFile** / `-keyfile`：指定强名称密钥文件。</span><span class="sxs-lookup"><span data-stu-id="76330-110">**KeyFile** / `-keyfile` : Specify a strong name key file.</span></span>
- <span data-ttu-id="76330-111">**KeyContainer** / `-keycontainer`：指定强名称密钥容器。</span><span class="sxs-lookup"><span data-stu-id="76330-111">**KeyContainer** / `-keycontainer`: Specify a strong name key container.</span></span>
- <span data-ttu-id="76330-112">**HighEntropyVA** / `-highentropyva`：启用高熵地址空间布局随机化 (ASLR)</span><span class="sxs-lookup"><span data-stu-id="76330-112">**HighEntropyVA** / `-highentropyva`: Enable high-entropy Address Space Layout Randomization (ASLR)</span></span>

## <a name="publicsign"></a><span data-ttu-id="76330-113">PublicSign</span><span class="sxs-lookup"><span data-stu-id="76330-113">PublicSign</span></span>

<span data-ttu-id="76330-114">此选项会导致编译器应用公钥，但不会实际对程序集签名。</span><span class="sxs-lookup"><span data-stu-id="76330-114">This option causes the compiler to apply a public key but doesn't actually sign the assembly.</span></span> <span data-ttu-id="76330-115">PublicSign 选项还会在程序集中设置位，以告知运行时该文件已签名。</span><span class="sxs-lookup"><span data-stu-id="76330-115">The **PublicSign** option also sets a bit in the assembly that tells the runtime that the file is signed.</span></span>

```xml
<PublicSign>true</PublicSign>
```

<span data-ttu-id="76330-116">PublicSign 选项需要使用 [KeyFile](#keyfile) 或 [KeyContainer](#keycontainer) 选项。</span><span class="sxs-lookup"><span data-stu-id="76330-116">The **PublicSign** option requires the use of the [**KeyFile**](#keyfile) or [**KeyContainer**](#keycontainer) option.</span></span> <span data-ttu-id="76330-117">keyFile 和 KeyContainer 选项指定公钥。</span><span class="sxs-lookup"><span data-stu-id="76330-117">The **keyFile** and **KeyContainer** options specify the public key.</span></span> <span data-ttu-id="76330-118">PublicSign 和 PublicSign 选项互斥。</span><span class="sxs-lookup"><span data-stu-id="76330-118">The **PublicSign** and **PublicSign** options are mutually exclusive.</span></span> <span data-ttu-id="76330-119">公共签名有时称为“假签名”或“OSS 签名”，它包括输出程序集中的公钥并设置“已签名”标记。</span><span class="sxs-lookup"><span data-stu-id="76330-119">Sometimes called "fake sign" or "OSS sign", public signing includes the public key in an output assembly and sets the "signed" flag.</span></span> <span data-ttu-id="76330-120">公共签名实际上并不使用私钥对程序集进行签名。</span><span class="sxs-lookup"><span data-stu-id="76330-120">Public signing doesn't actually sign the assembly with a private key.</span></span> <span data-ttu-id="76330-121">开发人员为开放源代码项目使用公共签名。</span><span class="sxs-lookup"><span data-stu-id="76330-121">Developers use public sign for open-source projects.</span></span>  <span data-ttu-id="76330-122">当人们无权访问用于对程序集进行签名的私钥时，他们会生成与已发布的“完全签名”程序集兼容的程序集。</span><span class="sxs-lookup"><span data-stu-id="76330-122">People build assemblies that are compatible with the released "fully signed" assemblies when they don' have access to the private key used to sign the assemblies.</span></span> <span data-ttu-id="76330-123">由于很少有使用者实际需要检查程序集是否完全签名，因此这些公开生成的程序集几乎适用于每个使用完全签名程序集的方案。</span><span class="sxs-lookup"><span data-stu-id="76330-123">Since few consumers actually need to check if the assembly is fully signed, these publicly built assemblies are useable in almost every scenario where the fully signed one would be used.</span></span>

## <a name="delaysign"></a><span data-ttu-id="76330-124">DelaySign</span><span class="sxs-lookup"><span data-stu-id="76330-124">DelaySign</span></span>

<span data-ttu-id="76330-125">此选项会使编译器在输出文件中保留空间，以便以后添加数字签名。</span><span class="sxs-lookup"><span data-stu-id="76330-125">This option causes the compiler to reserve space in the output file so that a digital signature can be added later.</span></span>

```xml
<DelaySign>true</DelaySign>
```

<span data-ttu-id="76330-126">如果需要完全签名的程序集，请使用 DelaySign-。</span><span class="sxs-lookup"><span data-stu-id="76330-126">Use **DelaySign-** if you want a fully signed assembly.</span></span> <span data-ttu-id="76330-127">如果仅需要将公钥置于程序集中，则使用 DelaySign。</span><span class="sxs-lookup"><span data-stu-id="76330-127">Use **DelaySign** if you only want to place the public key in the assembly.</span></span> <span data-ttu-id="76330-128">除非与 [KeyFile](#keyfile) 或 [KeyContainer](#keycontainer) 一同使用，否则 DelaySign 选项将不起作用。</span><span class="sxs-lookup"><span data-stu-id="76330-128">The **DelaySign** option has no effect unless used with [**KeyFile**](#keyfile) or [**KeyContainer**](#keycontainer).</span></span> <span data-ttu-id="76330-129">[KeyContainer](#keycontainer) 和 [PublicSign](#publicsign) 选项互斥。</span><span class="sxs-lookup"><span data-stu-id="76330-129">The [**KeyContainer**](#keycontainer) and [**PublicSign**](#publicsign) options are mutually exclusive.</span></span> <span data-ttu-id="76330-130">在请求完全签名的程序集时，编译器会对包含清单（程序集元数据）的文件进行哈希处理，并使用私钥对哈希进行签名。</span><span class="sxs-lookup"><span data-stu-id="76330-130">When you request a fully signed assembly, the compiler hashes the file that contains the manifest (assembly metadata) and signs that hash with the private key.</span></span> <span data-ttu-id="76330-131">该操作创建一个数字签名，它存储在包含清单的文件中。</span><span class="sxs-lookup"><span data-stu-id="76330-131">That operation creates a digital signature that is stored in the file that contains the manifest.</span></span> <span data-ttu-id="76330-132">在对程序集延迟签名时，编译器不会计算和存储签名。</span><span class="sxs-lookup"><span data-stu-id="76330-132">When an assembly is delay signed, the compiler doesn't compute and store the signature.</span></span> <span data-ttu-id="76330-133">相反，编译器会在文件中保留空间，便于稍后添加签名。</span><span class="sxs-lookup"><span data-stu-id="76330-133">Instead, the compiler but reserves space in the file so the signature can be added later.</span></span>

<span data-ttu-id="76330-134">使用 DelaySign，测试人员可以将程序集放入全局缓存中。</span><span class="sxs-lookup"><span data-stu-id="76330-134">Using **DelaySign** allows a tester to put the assembly in the global cache.</span></span> <span data-ttu-id="76330-135">测试完成后，可使用[程序集链接器](../../../framework/tools/al-exe-assembly-linker.md)实用工具将私钥置于程序集中，对程序集进行完全签名。</span><span class="sxs-lookup"><span data-stu-id="76330-135">After testing, you can fully sign the assembly by placing the private key in the assembly using the [Assembly Linker](../../../framework/tools/al-exe-assembly-linker.md) utility.</span></span> <span data-ttu-id="76330-136">有关详细信息，请参阅[创建和使用具有强名称的程序集](../../../standard/assembly/create-use-strong-named.md)和[延迟为程序集签名](../../../standard/assembly/delay-sign.md)。</span><span class="sxs-lookup"><span data-stu-id="76330-136">For more information, see [Creating and Using Strong-Named Assemblies](../../../standard/assembly/create-use-strong-named.md) and [Delay Signing an Assembly](../../../standard/assembly/delay-sign.md).</span></span>

## <a name="keyfile"></a><span data-ttu-id="76330-137">KeyFile</span><span class="sxs-lookup"><span data-stu-id="76330-137">KeyFile</span></span>

<span data-ttu-id="76330-138">指定包含加密密钥的文件名。</span><span class="sxs-lookup"><span data-stu-id="76330-138">Specifies the filename containing the cryptographic key.</span></span>

```xml
<KeyFile>filename</KeyFile>
```

<span data-ttu-id="76330-139">`file` 是包含强名称密钥的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="76330-139">`file` is the name of the file containing the strong name key.</span></span> <span data-ttu-id="76330-140">使用此选项时，编译器在程序集清单中插入指定字段的公钥，然后使用私钥对最终的程序集进行签名。</span><span class="sxs-lookup"><span data-stu-id="76330-140">When this option is used, the compiler inserts the public key from the specified file into the assembly manifest and then signs the final assembly with the private key.</span></span> <span data-ttu-id="76330-141">若要生成密钥文件，请在命令行键入 `sn -k file`。</span><span class="sxs-lookup"><span data-stu-id="76330-141">To generate a key file, type `sn -k file` at the command line.</span></span> <span data-ttu-id="76330-142">如果你使用 [-target:module](output.md#targettype) 进行编译，密钥文件的名称将保存在模块中，并在你使用 [AddModules](inputs.md#addmodules) 编译程序集时，合并到创建的程序集中。</span><span class="sxs-lookup"><span data-stu-id="76330-142">If you compile with [**-target:module**](output.md#targettype), the name of the key file is held in the module and incorporated into the assembly created when you compile an assembly with [**AddModules**](inputs.md#addmodules).</span></span> <span data-ttu-id="76330-143">你也可以使用 [Keycontainer](#keycontainer) 将加密信息传递给编译器。</span><span class="sxs-lookup"><span data-stu-id="76330-143">You can also pass your encryption information to the compiler with [**Keycontainer**](#keycontainer).</span></span> <span data-ttu-id="76330-144">如果需要部分签名的程序集，请使用 [DelaySign](#delaysign)。</span><span class="sxs-lookup"><span data-stu-id="76330-144">Use [**DelaySign**](#delaysign) if you want a partially signed assembly.</span></span> <span data-ttu-id="76330-145">如果在同一编译中同时指定 KeyFile 和 KeyContainer，则编译器将首先尝试使用密钥容器。</span><span class="sxs-lookup"><span data-stu-id="76330-145">In case both **KeyFile** and **KeyContainer** are specified in the same compilation, the compiler will first try the key container.</span></span> <span data-ttu-id="76330-146">如果成功，则使用密钥容器中的信息对程序集签名。</span><span class="sxs-lookup"><span data-stu-id="76330-146">If that succeeds, then the assembly is signed with the information in the key container.</span></span> <span data-ttu-id="76330-147">如果编译器没有找到密钥容器，它将尝试使用通过 [KeyFile](#keyfile) 指定的文件。</span><span class="sxs-lookup"><span data-stu-id="76330-147">If the compiler doesn't find the key container, it will try the file specified with [**KeyFile**](#keyfile).</span></span> <span data-ttu-id="76330-148">如果成功，则使用密钥文件中的信息对程序集签名，并且将密钥信息安装到密钥容器中。</span><span class="sxs-lookup"><span data-stu-id="76330-148">If that succeeds, the assembly is signed with the information in the key file and the key information will be installed in the key container.</span></span> <span data-ttu-id="76330-149">在下一次编译中，密钥容器将生效。</span><span class="sxs-lookup"><span data-stu-id="76330-149">On the next compilation, the key container will be valid.</span></span> <span data-ttu-id="76330-150">密钥文件可能仅包含公钥。</span><span class="sxs-lookup"><span data-stu-id="76330-150">A key file might contain only the public key.</span></span> <span data-ttu-id="76330-151">有关详细信息，请参阅[创建和使用具有强名称的程序集](../../../standard/assembly/create-use-strong-named.md)和[延迟为程序集签名](../../../standard/assembly/delay-sign.md)。</span><span class="sxs-lookup"><span data-stu-id="76330-151">For more information, see [Creating and Using Strong-Named Assemblies](../../../standard/assembly/create-use-strong-named.md) and [Delay Signing an Assembly](../../../standard/assembly/delay-sign.md).</span></span>

## <a name="keycontainer"></a><span data-ttu-id="76330-152">KeyContainer</span><span class="sxs-lookup"><span data-stu-id="76330-152">KeyContainer</span></span>

<span data-ttu-id="76330-153">指定加密密钥容器的名称。</span><span class="sxs-lookup"><span data-stu-id="76330-153">Specifies the name of the cryptographic key container.</span></span>

```xml
<KeyContainer>container</KeyContainer>
```

<span data-ttu-id="76330-154">`container` 是强名称密钥容器的名称。</span><span class="sxs-lookup"><span data-stu-id="76330-154">`container` is the name of the strong name key container.</span></span> <span data-ttu-id="76330-155">当使用 KeyContainer 选项时，编译器将创建一个可共享的组件。</span><span class="sxs-lookup"><span data-stu-id="76330-155">When the **KeyContainer** option is used, the compiler creates a sharable component.</span></span> <span data-ttu-id="76330-156">编译器在程序集清单中插入指定容器的公钥，然后使用私钥对最终的程序集进行签名。</span><span class="sxs-lookup"><span data-stu-id="76330-156">The compiler inserts a public key from the specified container into the assembly manifest and signs the final assembly with the private key.</span></span> <span data-ttu-id="76330-157">若要生成密钥文件，请在命令行键入 `sn -k file`。</span><span class="sxs-lookup"><span data-stu-id="76330-157">To generate a key file, type `sn -k file` at the command line.</span></span> <span data-ttu-id="76330-158">`sn -i` 将密钥对安装到容器中。</span><span class="sxs-lookup"><span data-stu-id="76330-158">`sn -i` installs the key pair into a container.</span></span> <span data-ttu-id="76330-159">编译器在 CoreCLR 上运行时，不支持此选项。</span><span class="sxs-lookup"><span data-stu-id="76330-159">This option isn't supported when the compiler runs on CoreCLR.</span></span> <span data-ttu-id="76330-160">若要在基于 CoreCLR 生成时对程序集进行签名，请使用 [KeyFile](#keyfile) 选项。</span><span class="sxs-lookup"><span data-stu-id="76330-160">To sign an assembly when building on CoreCLR, use the [**KeyFile**](#keyfile) option.</span></span> <span data-ttu-id="76330-161">如果你使用 [TargetType](output.md#targettype) 进行编译，那么，当你使用 [AddModules](inputs.md#addmodules) 将此模块编译到程序集时，密钥文件的名称将保存在模块中，而且会并入程序集。</span><span class="sxs-lookup"><span data-stu-id="76330-161">If you compile with [**TargetType**](output.md#targettype), the name of the key file is held in the module and incorporated into the assembly when you compile this module into an assembly with [**AddModules**](inputs.md#addmodules).</span></span> <span data-ttu-id="76330-162">还可以将此选项指定为任何 Microsoft 中间语言 (MSIL) 模块的源代码中的自定义特性 (<xref:System.Reflection.AssemblyKeyNameAttribute?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="76330-162">You can also specify this option as a custom attribute (<xref:System.Reflection.AssemblyKeyNameAttribute?displayProperty=nameWithType>) in the source code for any Microsoft intermediate language (MSIL) module.</span></span> <span data-ttu-id="76330-163">此外，可使用 [KeyFile](#keyfile) 将加密信息传递给编译器。</span><span class="sxs-lookup"><span data-stu-id="76330-163">You can also pass your encryption information to the compiler with [**KeyFile**](#keyfile).</span></span> <span data-ttu-id="76330-164">使用 [DelaySign](#delaysign) 可将公钥添加到程序集清单中，但在程序集被测试之前，会对其进行签名。</span><span class="sxs-lookup"><span data-stu-id="76330-164">Use [**DelaySign**](#delaysign) to add the public key  to the assembly manifest but signing the assembly until it has been tested.</span></span> <span data-ttu-id="76330-165">有关详细信息，请参阅[创建和使用具有强名称的程序集](../../../standard/assembly/create-use-strong-named.md)和[延迟为程序集签名](../../../standard/assembly/delay-sign.md)。</span><span class="sxs-lookup"><span data-stu-id="76330-165">For more information, see [Creating and Using Strong-Named Assemblies](../../../standard/assembly/create-use-strong-named.md) and [Delay Signing an Assembly](../../../standard/assembly/delay-sign.md).</span></span>

## <a name="highentropyva"></a><span data-ttu-id="76330-166">HighEntropyVA</span><span class="sxs-lookup"><span data-stu-id="76330-166">HighEntropyVA</span></span>

<span data-ttu-id="76330-167">HighEntropyVA 编译器选项可告知 Windows 内核，特定的可执行文件是否支持高熵地址空间布局随机化 (ASLR)。</span><span class="sxs-lookup"><span data-stu-id="76330-167">The **HighEntropyVA** compiler option tells the Windows kernel whether a particular executable supports high entropy Address Space Layout Randomization (ASLR).</span></span>

```xml
<HighEntropyVA>true</HighEntropyVA>
```

<span data-ttu-id="76330-168">此选项指定 64 位可执行文件或由 [PlatformTarget](output.md#platformtarget) 编译器选项标记的可执行文件支持高熵虚拟地址空间。</span><span class="sxs-lookup"><span data-stu-id="76330-168">This option specifies that a 64-bit executable or an executable that is marked by the [**PlatformTarget**](output.md#platformtarget) compiler option supports a high entropy virtual address space.</span></span> <span data-ttu-id="76330-169">默认情况下，此选项处于禁用状态。</span><span class="sxs-lookup"><span data-stu-id="76330-169">The option is disabled by default.</span></span> <span data-ttu-id="76330-170">可以使用 HighEntropyVA 启用它。</span><span class="sxs-lookup"><span data-stu-id="76330-170">Use **HighEntropyVA** to enable it.</span></span>

<span data-ttu-id="76330-171">当随机化进程的地址空间布局包含在 ASLR 中时，HighEntropyVA 选项允许 Windows 内核的兼容版本使用更高程度的熵。</span><span class="sxs-lookup"><span data-stu-id="76330-171">The **HighEntropyVA** option enables compatible versions of the Windows kernel to use higher degrees of entropy when randomizing the address space layout of a process as part of ASLR.</span></span> <span data-ttu-id="76330-172">使用更高程度的熵意味着，可向内存区域（例如堆栈或堆）分配更多的地址。</span><span class="sxs-lookup"><span data-stu-id="76330-172">Using higher degrees of entropy means a larger number of addresses can be allocated to memory regions such as stacks and heaps.</span></span> <span data-ttu-id="76330-173">因此，猜测特定内存区域的位置会更加困难。</span><span class="sxs-lookup"><span data-stu-id="76330-173">As a result, it's more difficult to guess the location of a particular memory region.</span></span> <span data-ttu-id="76330-174">HighEntropyVA 编译器选项需要目标可执行文件及其依赖的任何模块在作为 64 位进程运行时，能够处理大于 4 GB 的指针值。</span><span class="sxs-lookup"><span data-stu-id="76330-174">The **HighEntropyVA** compiler option requires the target executable and any modules that it depends can handle pointer values larger than 4 gigabytes (GB) when they're running as a 64-bit process.</span></span>
