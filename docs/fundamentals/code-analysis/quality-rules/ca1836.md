---
title: CA1836：可用时最好使用 IsEmpty，而不是 Count（代码分析）
description: 了解代码分析规则 CA1836：可用时最好使用 IsEmpty，而不是 Count
ms.date: 06/09/2020
ms.topic: reference
f1_keywords:
- UseCountProperly
- CA1836
helpviewer_keywords:
- UseCountProperly
- CA1836
author: Jozkee
ms.author: dacantu
ms.openlocfilehash: b47bfeb5ac733dd45d5885686f2d873309750978
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "99720054"
---
# <a name="ca1836-prefer-isempty-over-count-when-available"></a><span data-ttu-id="07d79-103">CA1836:可用时最好使用 IsEmpty (而不是 Count)</span><span class="sxs-lookup"><span data-stu-id="07d79-103">CA1836: Prefer IsEmpty over Count when available</span></span>

| | <span data-ttu-id="07d79-104">值</span><span class="sxs-lookup"><span data-stu-id="07d79-104">Value</span></span> |
|-|-|
| <span data-ttu-id="07d79-105">**规则 ID**</span><span class="sxs-lookup"><span data-stu-id="07d79-105">**Rule ID**</span></span> |<span data-ttu-id="07d79-106">CA1836</span><span class="sxs-lookup"><span data-stu-id="07d79-106">CA1836</span></span>|
| <span data-ttu-id="07d79-107">**类别**</span><span class="sxs-lookup"><span data-stu-id="07d79-107">**Category**</span></span> |[<span data-ttu-id="07d79-108">“性能”</span><span class="sxs-lookup"><span data-stu-id="07d79-108">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="07d79-109">**修复是中断修复还是非中断修复**</span><span class="sxs-lookup"><span data-stu-id="07d79-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="07d79-110">非中断</span><span class="sxs-lookup"><span data-stu-id="07d79-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="07d79-111">原因</span><span class="sxs-lookup"><span data-stu-id="07d79-111">Cause</span></span>

<span data-ttu-id="07d79-112">使用了 `Count` 或 `Length` 属性或 <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 扩展方法，通过将值与 `0` 或 `1` 进行比较来确定对象是否包含任何项，以及对象是否具有更有效的 `IsEmpty` 属性可以代替使用。</span><span class="sxs-lookup"><span data-stu-id="07d79-112">The `Count` or `Length` property or the <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> extension method was used to determine whether or not the object contains any items by comparing the value to `0` or `1`, and the object has a more efficient `IsEmpty` property that could be used instead.</span></span>

## <a name="rule-description"></a><span data-ttu-id="07d79-113">规则说明</span><span class="sxs-lookup"><span data-stu-id="07d79-113">Rule description</span></span>

<span data-ttu-id="07d79-114">当将 `Count` 和 `Length` 属性或 <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 和 <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> LINQ 方法用于确定对象是否包含任何项以及对象是否具有更有效的 `IsEmpty` 属性时，此规则将标记对它们的调用。</span><span class="sxs-lookup"><span data-stu-id="07d79-114">This rule flags the calls to the `Count` and `Length` properties or <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> and <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> LINQ methods when they are used to determine if the object contains any items and the object has a more efficient `IsEmpty` property.</span></span>

<span data-ttu-id="07d79-115">此规则的分析最初与类似规则 CA1827、CA1828 和 CA1829 重叠，这些规则的分析器与 CA1836 的分析器合并在一起，以在发生重叠时报告最佳诊断。</span><span class="sxs-lookup"><span data-stu-id="07d79-115">The analysis of this rule originally overlapped with similar rules CA1827, CA1828, and CA1829; the analyzers of such rules were merged along with the one for CA1836 to report the best diagnosis in case of overlap.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="07d79-116">如何解决冲突</span><span class="sxs-lookup"><span data-stu-id="07d79-116">How to fix violations</span></span>

<span data-ttu-id="07d79-117">若要解决冲突，在使用 `IsEmpty` 属性访问来确定对象是否为空的操作中，当使用 <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 或 <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 方法调用或 `Length` 或 `Count` 属性访问时，请将其替换。</span><span class="sxs-lookup"><span data-stu-id="07d79-117">To fix a violation, replace the <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method call or the `Length` or `Count` property access when it's used in an operation that determines if the object is empty with use of the `IsEmpty` property access.</span></span> <span data-ttu-id="07d79-118">例如，以下两个代码片段显示了规则冲突及其解决方法：</span><span class="sxs-lookup"><span data-stu-id="07d79-118">For example, the following two code snippets show a violation of the rule and how to fix it:</span></span>

```csharp
using System.Collections.Concurrent;

class C
{
    ConcurrentQueue<int> _queue;
    public bool IsEmpty => _queue.Count == 0;
}
```

```csharp
using System.Collections.Concurrent;

class C
{
    ConcurrentQueue<int> _queue;
    public bool IsEmpty => _queue.IsEmpty;
}
```

> [!TIP]
> <span data-ttu-id="07d79-119">Visual Studio 中为此规则提供了代码修复。</span><span class="sxs-lookup"><span data-stu-id="07d79-119">A code fix is available for this rule in Visual Studio.</span></span> <span data-ttu-id="07d79-120">若要使用它，请将光标置于冲突上，然后按 Ctrl+。 </span><span class="sxs-lookup"><span data-stu-id="07d79-120">To use it, position the cursor on the violation and press **Ctrl**+**.**</span></span> <span data-ttu-id="07d79-121">（句点）。</span><span class="sxs-lookup"><span data-stu-id="07d79-121">(period).</span></span> <span data-ttu-id="07d79-122">从显示的选项列表中选择“最好使用’IsEmpty’而不是‘Count’”来确定对象是否包含任何项。</span><span class="sxs-lookup"><span data-stu-id="07d79-122">Choose **Prefer 'IsEmpty' over 'Count' to determine whether the object contains or not any items** from the list of options that's presented.</span></span>
>
> ![CA1836 的代码修补程序 - 最好使用“IsEmpty”而不是“Count”来确定对象是否包含任何项](media/ca1836-codefix.png)

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="07d79-124">何时禁止显示警告</span><span class="sxs-lookup"><span data-stu-id="07d79-124">When to suppress warnings</span></span>

<span data-ttu-id="07d79-125">如果不关心不必要的项枚举是否会对计数计算的性能产生影响，可禁止显示此规则的冲突警告。</span><span class="sxs-lookup"><span data-stu-id="07d79-125">It's safe to suppress a violation of this rule if you're not concerned about the performance impact from unnecessary item enumeration to compute the count.</span></span>

## <a name="related-rules"></a><span data-ttu-id="07d79-126">相关规则</span><span class="sxs-lookup"><span data-stu-id="07d79-126">Related rules</span></span>

- [<span data-ttu-id="07d79-127">CA1827:如果可以使用 Any，请勿使用 Count/LongCount</span><span class="sxs-lookup"><span data-stu-id="07d79-127">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md)
- [<span data-ttu-id="07d79-128">CA1828:如果可以使用 AnyAsync，请勿使用 CountAsync/LongCountAsync</span><span class="sxs-lookup"><span data-stu-id="07d79-128">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md)
- [<span data-ttu-id="07d79-129">CA1829：如果可以使用 AnyAsync，请勿使用 CountAsync/LongCountAsync</span><span class="sxs-lookup"><span data-stu-id="07d79-129">CA1829: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md)

## <a name="see-also"></a><span data-ttu-id="07d79-130">另请参阅</span><span class="sxs-lookup"><span data-stu-id="07d79-130">See also</span></span>

- [<span data-ttu-id="07d79-131">性能规则</span><span class="sxs-lookup"><span data-stu-id="07d79-131">Performance rules</span></span>](performance-warnings.md)
