---
title: CA1810：以内联方式初始化引用类型静态字段（代码分析）
description: 了解代码分析规则 CA1810：以内联方式初始化引用类型静态字段
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- InitializeReferenceTypeStaticFieldsInline
- CA1810
helpviewer_keywords:
- InitializeReferenceTypeStaticFieldsInline
- CA1810
author: gewarren
ms.author: gewarren
dev_langs:
- CSharp
- VB
ms.openlocfilehash: f7234bf9c6941b25984d3b0e2cf3e4d31216d5ad
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "99776886"
---
# <a name="ca1810-initialize-reference-type-static-fields-inline"></a><span data-ttu-id="8ebbc-103">CA1810:以内联方式初始化引用类型的静态字段</span><span class="sxs-lookup"><span data-stu-id="8ebbc-103">CA1810: Initialize reference type static fields inline</span></span>

| | <span data-ttu-id="8ebbc-104">值</span><span class="sxs-lookup"><span data-stu-id="8ebbc-104">Value</span></span> |
|-|-|
| <span data-ttu-id="8ebbc-105">**规则 ID**</span><span class="sxs-lookup"><span data-stu-id="8ebbc-105">**Rule ID**</span></span> |<span data-ttu-id="8ebbc-106">CA1810</span><span class="sxs-lookup"><span data-stu-id="8ebbc-106">CA1810</span></span>|
| <span data-ttu-id="8ebbc-107">**类别**</span><span class="sxs-lookup"><span data-stu-id="8ebbc-107">**Category**</span></span> |[<span data-ttu-id="8ebbc-108">“性能”</span><span class="sxs-lookup"><span data-stu-id="8ebbc-108">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="8ebbc-109">**修复是中断修复还是非中断修复**</span><span class="sxs-lookup"><span data-stu-id="8ebbc-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="8ebbc-110">非中断</span><span class="sxs-lookup"><span data-stu-id="8ebbc-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="8ebbc-111">原因</span><span class="sxs-lookup"><span data-stu-id="8ebbc-111">Cause</span></span>

<span data-ttu-id="8ebbc-112">引用类型声明显式静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-112">A reference type declares an explicit static constructor.</span></span>

## <a name="rule-description"></a><span data-ttu-id="8ebbc-113">规则说明</span><span class="sxs-lookup"><span data-stu-id="8ebbc-113">Rule description</span></span>

<span data-ttu-id="8ebbc-114">当一个类型声明显式静态构造函数时，实时 (JIT) 编译器会向该类型的每个静态方法和实例构造函数中添加一项检查，以确保之前已调用该静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-114">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="8ebbc-115">访问任何静态成员或创建该类型的实例时，将触发静态初始化。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-115">Static initialization is triggered when any static member is accessed or when an instance of the type is created.</span></span> <span data-ttu-id="8ebbc-116">但是，如果声明一个类型的变量，但不使用它，则不会触发静态初始化；这在初始化会更改全局状态的情况下非常重要。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-116">However, static initialization is not triggered if you declare a variable of the type but do not use it, which can be important if the initialization changes global state.</span></span>

<span data-ttu-id="8ebbc-117">当所有静态数据都以内联方式初始化并且未声明显式静态构造函数时，Microsoft 中间语言 (MSIL) 编译器会将 `beforefieldinit` 标志和隐式静态构造函数（该构造函数初始化静态数据）添加到 MSIL 类型定义。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-117">When all static data is initialized inline and an explicit static constructor is not declared, Microsoft intermediate language (MSIL) compilers add the `beforefieldinit` flag and an implicit static constructor, which initializes the static data, to the MSIL type definition.</span></span> <span data-ttu-id="8ebbc-118">JIT 编译器遇到 `beforefieldinit` 标志时，大多数情况下不会添加静态构造函数检查。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-118">When the JIT compiler encounters the `beforefieldinit` flag, most of the time the static constructor checks are not added.</span></span> <span data-ttu-id="8ebbc-119">静态初始化可以保证在访问任何静态字段之前的某个时间发生，但不能在调用静态方法或实例构造函数之前发生。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-119">Static initialization is guaranteed to occur at some time before any static fields are accessed but not before a static method or instance constructor is invoked.</span></span> <span data-ttu-id="8ebbc-120">请注意，在声明类型的变量后，可能会随时发生静态初始化。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-120">Note that static initialization can occur at any time after a variable of the type is declared.</span></span>

<span data-ttu-id="8ebbc-121">静态构造函数检查会降低性能。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-121">Static constructor checks can decrease performance.</span></span> <span data-ttu-id="8ebbc-122">通常，静态构造函数仅用于初始化静态字段，在这种情况下，必须确保仅在首次访问静态字段之前发生静态初始化。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-122">Often a static constructor is used only to initialize static fields, in which case you must only make sure that static initialization occurs before the first access of a static field.</span></span> <span data-ttu-id="8ebbc-123">`beforefieldinit` 行为适用于这些类型和大多数其他类型。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-123">The `beforefieldinit` behavior is appropriate for these and most other types.</span></span> <span data-ttu-id="8ebbc-124">仅当静态初始化影响全局状态并且满足以下任一条件时，它才是不适当的：</span><span class="sxs-lookup"><span data-stu-id="8ebbc-124">It is only inappropriate when static initialization affects global state and one of the following is true:</span></span>

- <span data-ttu-id="8ebbc-125">影响全局状态的成本非常昂贵，如果不使用该类型，则不需要这样做。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-125">The effect on global state is expensive and is not required if the type is not used.</span></span>

- <span data-ttu-id="8ebbc-126">可以在不访问该类型的任何静态字段的情况下访问全局状态效果。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-126">The global state effects can be accessed without accessing any static fields of the type.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="8ebbc-127">如何解决冲突</span><span class="sxs-lookup"><span data-stu-id="8ebbc-127">How to fix violations</span></span>

<span data-ttu-id="8ebbc-128">要修复与该规则的冲突，请在声明它时初始化所有静态数据并移除静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-128">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="8ebbc-129">何时禁止显示警告</span><span class="sxs-lookup"><span data-stu-id="8ebbc-129">When to suppress warnings</span></span>

<span data-ttu-id="8ebbc-130">如果不考虑性能，或者，如果静态初始化导致的全局状态更改成本非常昂贵，或者必须保证在调用该类型的静态方法或创建该类型的实例之前进行静态初始化，则可以安全地禁止显示此规则发出的警告。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-130">It is safe to suppress a warning from this rule if performance is not a concern; or if global state changes that are caused by static initialization are expensive or must be guaranteed to occur before a static method of the type is called or an instance of the type is created.</span></span>

## <a name="example"></a><span data-ttu-id="8ebbc-131">示例</span><span class="sxs-lookup"><span data-stu-id="8ebbc-131">Example</span></span>

<span data-ttu-id="8ebbc-132">下面的示例演示了类型 `StaticConstructor`（该类型违反了规则）以及类型 `NoStaticConstructor`（该类型使用内联初始化替换静态构造函数来满足规则）。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-132">The following example shows a type, `StaticConstructor`, that violates the rule and a type, `NoStaticConstructor`, that replaces the static constructor with inline initialization to satisfy the rule.</span></span>

:::code language="csharp" source="snippets/csharp/all-rules/ca1810.cs" id="snippet1":::

:::code language="vb" source="snippets/vb/all-rules/ca1810-initialize-reference-type-static-fields-inline_1.vb":::

<span data-ttu-id="8ebbc-133">请注意在 `NoStaticConstructor` 类的 MSIL 定义上添加的 `beforefieldinit` 标志。</span><span class="sxs-lookup"><span data-stu-id="8ebbc-133">Note the addition of the `beforefieldinit` flag on the MSIL definition for the `NoStaticConstructor` class.</span></span>

```il
.class public auto ansi StaticConstructor
extends [mscorlib]System.Object
{
} // end of class StaticConstructor

.class public auto ansi beforefieldinit NoStaticConstructor
extends [mscorlib]System.Object
{
} // end of class NoStaticConstructor
```

## <a name="related-rules"></a><span data-ttu-id="8ebbc-134">相关规则</span><span class="sxs-lookup"><span data-stu-id="8ebbc-134">Related rules</span></span>

- [<span data-ttu-id="8ebbc-135">CA2207:以内联方式初始化值类型的静态字段</span><span class="sxs-lookup"><span data-stu-id="8ebbc-135">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)
