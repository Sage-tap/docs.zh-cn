---
title: 应用程序复原能力模式
description: 构建适用于 Azure 的云本机 .NET 应用 |应用程序复原模式
author: robvet
ms.date: 01/19/2021
ms.openlocfilehash: 9a59a7d93b61b0dea11680f6caf0bd3b68a0f853
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505916"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="f84a5-103">应用程序复原能力模式</span><span class="sxs-lookup"><span data-stu-id="f84a5-103">Application resiliency patterns</span></span>

<span data-ttu-id="f84a5-104">第一道防线是应用程序复原能力。</span><span class="sxs-lookup"><span data-stu-id="f84a5-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="f84a5-105">虽然您可以投入大量时间来编写自己的复原框架，此类产品已经存在。</span><span class="sxs-lookup"><span data-stu-id="f84a5-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="f84a5-106">[Polly](http://www.thepollyproject.org/) 是一个全面的 .net 复原和暂时性故障处理库，使开发人员能够以流畅且线程安全的方式表达复原策略。</span><span class="sxs-lookup"><span data-stu-id="f84a5-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="f84a5-107">Polly 面向用 .NET Framework 或 .NET 5 构建的应用程序。</span><span class="sxs-lookup"><span data-stu-id="f84a5-107">Polly targets applications built with either the .NET Framework or .NET 5.</span></span> <span data-ttu-id="f84a5-108">下表介绍了 Polly 库中提供的复原功能（称为 `policies` ）。</span><span class="sxs-lookup"><span data-stu-id="f84a5-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="f84a5-109">它们可单独应用或组合在一起。</span><span class="sxs-lookup"><span data-stu-id="f84a5-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="f84a5-110">策略</span><span class="sxs-lookup"><span data-stu-id="f84a5-110">Policy</span></span> | <span data-ttu-id="f84a5-111">体验</span><span class="sxs-lookup"><span data-stu-id="f84a5-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="f84a5-112">重试</span><span class="sxs-lookup"><span data-stu-id="f84a5-112">Retry</span></span> | <span data-ttu-id="f84a5-113">配置针对指定操作的重试操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="f84a5-114">断路器</span><span class="sxs-lookup"><span data-stu-id="f84a5-114">Circuit Breaker</span></span> | <span data-ttu-id="f84a5-115">当故障超过配置的阈值时，阻止预定义时间段内请求的操作</span><span class="sxs-lookup"><span data-stu-id="f84a5-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="f84a5-116">超时</span><span class="sxs-lookup"><span data-stu-id="f84a5-116">Timeout</span></span> | <span data-ttu-id="f84a5-117">对调用方可以等待响应的持续时间的限制。</span><span class="sxs-lookup"><span data-stu-id="f84a5-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="f84a5-118">隔舱</span><span class="sxs-lookup"><span data-stu-id="f84a5-118">Bulkhead</span></span> | <span data-ttu-id="f84a5-119">将操作限制为固定大小的资源池，以防止从对资源 swamping 的调用失败。</span><span class="sxs-lookup"><span data-stu-id="f84a5-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="f84a5-120">缓存</span><span class="sxs-lookup"><span data-stu-id="f84a5-120">Cache</span></span> | <span data-ttu-id="f84a5-121">自动存储响应。</span><span class="sxs-lookup"><span data-stu-id="f84a5-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="f84a5-122">回退</span><span class="sxs-lookup"><span data-stu-id="f84a5-122">Fallback</span></span> | <span data-ttu-id="f84a5-123">定义发生故障时的结构化行为。</span><span class="sxs-lookup"><span data-stu-id="f84a5-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="f84a5-124">请注意上图中的如何将复原策略应用于请求消息，无论是来自外部客户端还是后端服务。</span><span class="sxs-lookup"><span data-stu-id="f84a5-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="f84a5-125">目标是对可能暂时不可用的服务的请求进行补偿。</span><span class="sxs-lookup"><span data-stu-id="f84a5-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="f84a5-126">通常，这些生存期较短的中断会自行列出，其中包含下表中所示的 HTTP 状态代码。</span><span class="sxs-lookup"><span data-stu-id="f84a5-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="f84a5-127">HTTP 状态代码</span><span class="sxs-lookup"><span data-stu-id="f84a5-127">HTTP Status Code</span></span>| <span data-ttu-id="f84a5-128">原因</span><span class="sxs-lookup"><span data-stu-id="f84a5-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="f84a5-129">404</span><span class="sxs-lookup"><span data-stu-id="f84a5-129">404</span></span> | <span data-ttu-id="f84a5-130">未找到</span><span class="sxs-lookup"><span data-stu-id="f84a5-130">Not Found</span></span> |
| <span data-ttu-id="f84a5-131">408</span><span class="sxs-lookup"><span data-stu-id="f84a5-131">408</span></span> | <span data-ttu-id="f84a5-132">请求超时</span><span class="sxs-lookup"><span data-stu-id="f84a5-132">Request timeout</span></span> |
| <span data-ttu-id="f84a5-133">429</span><span class="sxs-lookup"><span data-stu-id="f84a5-133">429</span></span> | <span data-ttu-id="f84a5-134">请求过多 (你很可能已受到限制) </span><span class="sxs-lookup"><span data-stu-id="f84a5-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="f84a5-135">502</span><span class="sxs-lookup"><span data-stu-id="f84a5-135">502</span></span> | <span data-ttu-id="f84a5-136">网关错误</span><span class="sxs-lookup"><span data-stu-id="f84a5-136">Bad gateway</span></span> |
| <span data-ttu-id="f84a5-137">503</span><span class="sxs-lookup"><span data-stu-id="f84a5-137">503</span></span> | <span data-ttu-id="f84a5-138">服务不可用</span><span class="sxs-lookup"><span data-stu-id="f84a5-138">Service unavailable</span></span> |
| <span data-ttu-id="f84a5-139">504</span><span class="sxs-lookup"><span data-stu-id="f84a5-139">504</span></span> | <span data-ttu-id="f84a5-140">网关超时</span><span class="sxs-lookup"><span data-stu-id="f84a5-140">Gateway timeout</span></span> |

<span data-ttu-id="f84a5-141">问：是否要重试 HTTP 状态代码 403-禁止访问？</span><span class="sxs-lookup"><span data-stu-id="f84a5-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="f84a5-142">不能。</span><span class="sxs-lookup"><span data-stu-id="f84a5-142">No.</span></span> <span data-ttu-id="f84a5-143">此时，系统将正常运行，但通知调用方他们无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="f84a5-144">必须注意仅重试由失败导致的操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="f84a5-145">如第1章所述，Microsoft 开发云本机应用程序的开发人员应以 .NET 平台为目标。</span><span class="sxs-lookup"><span data-stu-id="f84a5-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET platform.</span></span> <span data-ttu-id="f84a5-146">版本2.1 引入了 [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) 库，用于创建用于与基于 URL 的资源交互的 HTTP 客户端实例。</span><span class="sxs-lookup"><span data-stu-id="f84a5-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="f84a5-147">工厂类取代了原始 HTTPClient 类，它支持许多增强功能，其中一个功能与 Polly 复原库 [紧密集成](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) 。</span><span class="sxs-lookup"><span data-stu-id="f84a5-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="f84a5-148">利用它，你可以轻松地在应用程序启动类中定义复原策略来处理部分故障和连接问题。</span><span class="sxs-lookup"><span data-stu-id="f84a5-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="f84a5-149">接下来，让我们展开重试和断路器模式。</span><span class="sxs-lookup"><span data-stu-id="f84a5-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="f84a5-150">重试模式</span><span class="sxs-lookup"><span data-stu-id="f84a5-150">Retry pattern</span></span>

<span data-ttu-id="f84a5-151">在分布式云本机环境中，对服务和云资源的调用可能会失败，这是由于暂时性 (短暂的) 故障，通常在短暂的一段时间内自行更正。</span><span class="sxs-lookup"><span data-stu-id="f84a5-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="f84a5-152">实现重试策略可帮助云本机服务降低这些方案。</span><span class="sxs-lookup"><span data-stu-id="f84a5-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="f84a5-153">使用 [重试模式](/azure/architecture/patterns/retry) ，服务可以重试失败的请求操作， (可配置的) 次，且等待时间呈指数级增长。</span><span class="sxs-lookup"><span data-stu-id="f84a5-153">The [Retry pattern](/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="f84a5-154">图6-2 显示了一个重试操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-154">Figure 6-2 shows a retry in action.</span></span>

![操作中的重试模式](./media/retry-pattern.png)

<span data-ttu-id="f84a5-156">**图 6-2**.</span><span class="sxs-lookup"><span data-stu-id="f84a5-156">**Figure 6-2**.</span></span> <span data-ttu-id="f84a5-157">操作中的重试模式</span><span class="sxs-lookup"><span data-stu-id="f84a5-157">Retry pattern in action</span></span>

<span data-ttu-id="f84a5-158">在上图中，已为请求操作实现重试模式。</span><span class="sxs-lookup"><span data-stu-id="f84a5-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="f84a5-159">它配置为允许最多四次重试，而不能使用回退时间间隔 (等待时间，) 从两秒开始，每次后续尝试都呈指数级增长。</span><span class="sxs-lookup"><span data-stu-id="f84a5-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="f84a5-160">第一次调用失败并返回 HTTP 状态代码500。</span><span class="sxs-lookup"><span data-stu-id="f84a5-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="f84a5-161">应用程序等待两秒钟，然后重试呼叫。</span><span class="sxs-lookup"><span data-stu-id="f84a5-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="f84a5-162">第二次调用也失败，并返回 HTTP 状态代码500。</span><span class="sxs-lookup"><span data-stu-id="f84a5-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="f84a5-163">现在，应用程序将回退间隔加倍到4秒，然后重试该调用。</span><span class="sxs-lookup"><span data-stu-id="f84a5-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="f84a5-164">最后，第三次调用成功。</span><span class="sxs-lookup"><span data-stu-id="f84a5-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="f84a5-165">在此方案中，重试操作最多尝试四次重试，同时在调用失败之前将回退持续时间加倍。</span><span class="sxs-lookup"><span data-stu-id="f84a5-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="f84a5-166">如果第四次重试失败，则将调用回退策略来正常处理此问题。</span><span class="sxs-lookup"><span data-stu-id="f84a5-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="f84a5-167">在重试调用以允许服务时间自动更正之前，请务必增加回退时间。</span><span class="sxs-lookup"><span data-stu-id="f84a5-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="f84a5-168">最佳做法是，在每次重试) 时，将以指数方式增加的回退 (翻倍，以允许适当的更正时间。</span><span class="sxs-lookup"><span data-stu-id="f84a5-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="f84a5-169">断路器模式</span><span class="sxs-lookup"><span data-stu-id="f84a5-169">Circuit breaker pattern</span></span>

<span data-ttu-id="f84a5-170">尽管重试模式可以在部分失败时帮助抢救请求放大，但在某些情况下，可能会由于意外的事件需要更长的时间来解决，导致失败。</span><span class="sxs-lookup"><span data-stu-id="f84a5-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="f84a5-171">这些故障轻则导致部分连接中断，重则导致服务完全瘫痪。</span><span class="sxs-lookup"><span data-stu-id="f84a5-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="f84a5-172">在这些情况下，应用程序不必再重试不太可能成功的操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="f84a5-173">要使问题更糟，对非响应式服务执行连续重试操作可以让你进入一个自行施加的拒绝服务方案，在这种情况下，你的服务将持续调用耗尽资源（如内存、线程和数据库连接），从而导致系统上使用相同资源的无关部分出现故障。</span><span class="sxs-lookup"><span data-stu-id="f84a5-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="f84a5-174">在这种情况下，操作会立即失败并仅在有可能成功的情况下尝试调用服务，这是最好的做法。</span><span class="sxs-lookup"><span data-stu-id="f84a5-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="f84a5-175">[断路器模式](/azure/architecture/patterns/circuit-breaker)可以防止应用程序重复尝试执行很可能失败的操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-175">The [Circuit Breaker pattern](/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="f84a5-176">在预定义的失败调用数后，它会阻止到服务的所有流量。</span><span class="sxs-lookup"><span data-stu-id="f84a5-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="f84a5-177">它会定期调用，以确定是否已解决错误。</span><span class="sxs-lookup"><span data-stu-id="f84a5-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="f84a5-178">图6-3 显示了操作中的断路器模式。</span><span class="sxs-lookup"><span data-stu-id="f84a5-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![操作中的断路器模式](./media/circuit-breaker-pattern.png)

<span data-ttu-id="f84a5-180">**图 6-3**。</span><span class="sxs-lookup"><span data-stu-id="f84a5-180">**Figure 6-3**.</span></span> <span data-ttu-id="f84a5-181">操作中的断路器模式</span><span class="sxs-lookup"><span data-stu-id="f84a5-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="f84a5-182">在上图中，已将断路器模式添加到原始重试模式。</span><span class="sxs-lookup"><span data-stu-id="f84a5-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="f84a5-183">请注意，100请求失败后，电路熔断器会打开，不再允许对服务进行调用。</span><span class="sxs-lookup"><span data-stu-id="f84a5-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="f84a5-184">CheckCircuit 值设置为30秒，指定库允许一个请求继续到服务的频率。</span><span class="sxs-lookup"><span data-stu-id="f84a5-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="f84a5-185">如果该调用成功，线路将关闭，并且服务再次可用于通信。</span><span class="sxs-lookup"><span data-stu-id="f84a5-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="f84a5-186">请记住，断路器模式的目的 *不同* 于重试模式。</span><span class="sxs-lookup"><span data-stu-id="f84a5-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="f84a5-187">重试模式使应用程序能够在预期成功的情况下重试操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="f84a5-188">断路器模式可以防止应用程序执行可能会失败的操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="f84a5-189">通常情况下，应用程序将使用重试模式通过断路器调用操作来 *合并* 这两种模式。</span><span class="sxs-lookup"><span data-stu-id="f84a5-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="f84a5-190">测试复原能力</span><span class="sxs-lookup"><span data-stu-id="f84a5-190">Testing for resiliency</span></span>

<span data-ttu-id="f84a5-191">针对复原的测试始终无法通过运行单元测试、集成测试等)  (测试应用程序功能。</span><span class="sxs-lookup"><span data-stu-id="f84a5-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests, and so on).</span></span> <span data-ttu-id="f84a5-192">相反，你必须测试端到端工作负荷在故障条件下的执行情况，这种情况仅间歇发生。</span><span class="sxs-lookup"><span data-stu-id="f84a5-192">Instead, you must test how the end-to-end workload performs under failure conditions, which only occur intermittently.</span></span> <span data-ttu-id="f84a5-193">例如：通过使进程崩溃、过期证书，使从属服务不可用等来注入故障。混乱的框架（如 [混乱）](https://github.com/Netflix/chaosmonkey) 可用于这样的混乱测试。</span><span class="sxs-lookup"><span data-stu-id="f84a5-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="f84a5-194">应用程序复原能力是处理请求的操作时必须执行的操作。</span><span class="sxs-lookup"><span data-stu-id="f84a5-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="f84a5-195">但这只是故事的一半。</span><span class="sxs-lookup"><span data-stu-id="f84a5-195">But, it's only half of the story.</span></span> <span data-ttu-id="f84a5-196">接下来，我们介绍 Azure 云中提供的复原功能。</span><span class="sxs-lookup"><span data-stu-id="f84a5-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f84a5-197">[上一页](resiliency.md)
>[下一页](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="f84a5-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
