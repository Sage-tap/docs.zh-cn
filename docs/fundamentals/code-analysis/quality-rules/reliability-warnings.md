---
title: 可靠性规则（代码分析）
description: 了解代码分析可靠性规则。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "96590536"
---
# <a name="reliability-rules"></a><span data-ttu-id="a6bbd-103">可靠性规则</span><span class="sxs-lookup"><span data-stu-id="a6bbd-103">Reliability rules</span></span>

<span data-ttu-id="a6bbd-104">支持库和应用程序可靠性（例如正确使用内存和线程）的可靠性规则。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="a6bbd-105">可靠性规则包括：</span><span class="sxs-lookup"><span data-stu-id="a6bbd-105">The reliability rules include:</span></span>

|<span data-ttu-id="a6bbd-106">规则</span><span class="sxs-lookup"><span data-stu-id="a6bbd-106">Rule</span></span>|<span data-ttu-id="a6bbd-107">描述</span><span class="sxs-lookup"><span data-stu-id="a6bbd-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="a6bbd-108">CA2000:丢失范围之前释放对象</span><span class="sxs-lookup"><span data-stu-id="a6bbd-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="a6bbd-109">由于可能发生异常事件，导致对象的终结器无法运行，因此，应显式释放对象，以避免对该对象的所有引用超出范围。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="a6bbd-110">CA2002:不要锁定具有弱标识的对象</span><span class="sxs-lookup"><span data-stu-id="a6bbd-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="a6bbd-111">当可以跨应用程序域边界直接进行访问对象时，则认为该对象具有弱标识。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="a6bbd-112">对于尝试获取对具有弱标识的对象的锁的线程，该线程可能会被其他应用程序域中持有对同一对象的锁的另一线程所阻止。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="a6bbd-113">CA2007：不直接等待任务</span><span class="sxs-lookup"><span data-stu-id="a6bbd-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="a6bbd-114">异步方法会直接[等待](../../../csharp/language-reference/operators/await.md) <xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="a6bbd-115">CA2008：不要在未传递 TaskScheduler 的情况下创建任务</span><span class="sxs-lookup"><span data-stu-id="a6bbd-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="a6bbd-116">任务创建或延续操作使用未指定 <xref:System.Threading.Tasks.TaskScheduler> 参数的方法重载。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="a6bbd-117">CA2009：请勿对 ImmutableCollection 值调用 ToImmutableCollection</span><span class="sxs-lookup"><span data-stu-id="a6bbd-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="a6bbd-118">没有必要在 <xref:System.Collections.Immutable> 命名空间的不可变集合上调用 `ToImmutable` 方法。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="a6bbd-119">CA2011:请勿在其资源库中分配属性</span><span class="sxs-lookup"><span data-stu-id="a6bbd-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="a6bbd-120">属性在自身的 [set 访问器](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)中被意外赋值。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="a6bbd-121">CA2012:正确使用 ValueTask</span><span class="sxs-lookup"><span data-stu-id="a6bbd-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="a6bbd-122">从成员调用中返回的 ValueTasks 旨在直接等待。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="a6bbd-123">多次尝试使用 ValueTask 或在已知完成之前直接访问其结果可能会导致异常或损坏。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="a6bbd-124">忽略此类 ValueTask 可能指示出现功能 Bug，还可能降低性能。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="a6bbd-125">CA2013:请勿将 ReferenceEquals 与值类型结合使用</span><span class="sxs-lookup"><span data-stu-id="a6bbd-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="a6bbd-126">使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> 比较值时，如果 objA 和 objB 是值类型，则在将其传递给 <xref:System.Object.ReferenceEquals%2A> 方法之前将它们装箱。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="a6bbd-127">这意味着，即使 objA 和 objB 都表示值类型的同一个实例，<xref:System.Object.ReferenceEquals%2A> 方法也会返回 false。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="a6bbd-128">CA2014：请勿在循环中使用 stackalloc。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="a6bbd-129">仅在当前方法调用结束时，Stackalloc 分配的堆栈空间才会释放。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="a6bbd-130">在循环中使用此方法可能导致无限堆栈增长，最终出现堆栈溢出的情况。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|<span data-ttu-id="a6bbd-131">[CA2015：请勿为派生自 MemoryManager&lt;T&gt;](ca2015.md) 的类型定义终结器</span><span class="sxs-lookup"><span data-stu-id="a6bbd-131">[CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;](ca2015.md)</span></span> | <span data-ttu-id="a6bbd-132">将终结器添加到派生自 <xref:System.Buffers.MemoryManager%601> 的类型可能使内存在仍被 <xref:System.Span%601> 使用时得到释放。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="a6bbd-133">CA2016：将 CancellationToken 参数转发到采用一个该参数的方法</span><span class="sxs-lookup"><span data-stu-id="a6bbd-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="a6bbd-134">将 `CancellationToken` 参数转发给方法来确保操作取消通知得到正确传播，或者在 `CancellationToken.None` 中显式传递，以指示有意不传播令牌。</span><span class="sxs-lookup"><span data-stu-id="a6bbd-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
